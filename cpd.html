<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia at Jan 22, 2013 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>CPD Results</title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
    <meta name="Date-Revision-yyyymmdd" content="20130122" />
    <meta http-equiv="Content-Language" content="en" />
        
        </head>
  <body class="composite">
    <div id="banner">
                    <div id="bannerLeft">
                stochdiff
                </div>
                    <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
            
        
                <div class="xleft">
        <span id="publishDate">Last Published: 2013-01-22</span>
                  &nbsp;| <span id="projectVersion">Version: 2.1.10</span>
                      </div>
            <div class="xright">                    <a href="${project.url}" title="stochdiff">stochdiff</a>
              
        
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
             
        
                                          <h5>Project Documentation</h5>
                  <ul>
                                                                                                        <li class="collapsed">
                          <a href="project-info.html" title="Project Information">Project Information</a>
                  </li>
                                                                                                                                                      <li class="expanded">
                          <a href="project-reports.html" title="Project Reports">Project Reports</a>
                    <ul>
                      <li class="none">
                          <a href="xref/index.html" title="Source Xref">Source Xref</a>
            </li>
                      <li class="none">
                          <a href="pmd.html" title="PMD Report">PMD Report</a>
            </li>
                      <li class="none">
            <strong>CPD Report</strong>
          </li>
                      <li class="none">
                          <a href="findbugs.html" title="FindBugs Report">FindBugs Report</a>
            </li>
                      <li class="none">
                          <a href="apidocs/index.html" title="JavaDocs">JavaDocs</a>
            </li>
              </ul>
        </li>
          </ul>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                   
        
            </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section"><h2>CPD Results<a name="CPD_Results"></a></h2><p>The following document contains the results of PMD's  <a class="externalLink" href="http://pmd.sourceforge.net/cpd.html">CPD</a> 4.3.</p></div><div class="section"><h2>Duplications<a name="Duplications"></a></h2><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.html#166">166</a></td></tr><tr class="a"><td>org/textensor/stochdiff/numeric/tmp/Tmp1A.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/tmp/Tmp1A.html#122">122</a></td></tr><tr class="b"><td colspan='2'><div><pre>        random = new MersenneTwister(getCalculationSeed());

        rtab = getReactionTable();
        speciesIDs = rtab.getSpeciesIDs();

        nreaction = rtab.getNReaction();
        rates = rtab.getRates();

        // Debug.dump(&quot;rates&quot;, rates);

        lnrates = ArrayUtil.log(rates, -999.);

        reactantIndices = rtab.getReactantIndices();
        productIndices = rtab.getProductIndices();

        reactantStochiometry = rtab.getReactantStochiometry();
        productStochiometry = rtab.getProductStochiometry();

        vgrid = getVolumeGrid();

        nel = vgrid.getNElements();

        nspec = rtab.getNSpecies();
        specieIDs = rtab.getSpecieIDs();
        volumes = vgrid.getElementVolumes();
        lnvolumes = ArrayUtil.log(volumes, -999.);

        // RO
        // ----------------------
        // System.out.println(&quot;Number of files        : &quot; + NspeciesFilef);
        // System.out.println(&quot;Total numer of species : &quot; + NspeciesIDsOutf);

        // ----------------------
        // RO
        extractOutputScheme(rtab); // see BaseCalc.java

        surfaceAreas = vgrid.getExposedAreas();

        // WK 6 18 2007
        submembranes = vgrid.getSubmembranes();
        regionLabels = vgrid.getRegionLabels();
        // WK

        fdiff = rtab.getDiffusionConstants();
        lnfdiff = ArrayUtil.log(fdiff, -999.);

        neighbors = vgrid.getPerElementNeighbors();
        couplingConstants = vgrid.getPerElementCouplingConstants();
        lnCC = ArrayUtil.log(couplingConstants, -999.);

        stimTab = getStimulationTable();
        stimtargets = vgrid.getAreaIndexes(stimTab.getTargetIDs());

        // workspace for the calculation
        wkA = new int[nel][nspec];
        wkB = new int[nel][nspec];
        wkReac = new int[nreaction];

        eltregions = vgrid.getRegionIndexes();
        double[][] regcon = getRegionConcentrations();
        double[][] regsd = getRegionSurfaceDensities();

        // apply initial conditions over the grid
        for (int i = 0; i &lt; nel; i++) {
            double v = volumes[i];
            double[] rcs = regcon[eltregions[i]];

            for (int j = 0; j &lt; nspec; j++) {
                double rnp = v * rcs[j] * PARTICLES_PUVC;
                int irnp = (int) rnp;
                double drnp = rnp - irnp;

                // random allocation to implement the remainder of the
                // density (some cells get an extra particle, some dont)
                if (random.random() &lt; drnp) {
                    irnp += 1;
                }
                wkA[i][j] = irnp;
                wkB[i][j] = irnp;
            }

            double a = surfaceAreas[i];
            double[] scs = regsd[eltregions[i]];
            if (a &gt; 0 &amp;&amp; scs != null) {
                for (int j = 0; j &lt; nspec; j++) {
                    if (Double.isNaN(scs[j])) {
                        // means not specified by the user;

                    } else {
                        wkA[i][j] = 0;
                        wkB[i][j] = 0;

                        double rnp = a * scs[j] * PARTICLES_PUASD;
                        int irnp = (int) rnp;
                        double drnp = rnp - irnp;

                        // random allocation to implement the remainder of the
                        // density (some cells get an extra particle, some dont)
                        if (random.random() &lt; drnp) {
                            irnp += 1;
                        }
                        wkA[i][j] += irnp;
                        wkB[i][j] += irnp;
                    }
                }

            }

            /*
             * if (i % 20 == 0) { E.info(&quot;elt &quot; + i + &quot; region &quot; + eltregions[i]
             * + &quot; n0 &quot; + wkA[i][0]); }
             */
        }

        if (sdRun.initialStateFile != null) {
            double[][] cc = readInitialState(sdRun.initialStateFile, nel, nspec, speciesIDs);
            if (cc != null) {
                for (int i = 0; i &lt; nel; i++) {
                    for (int j = 0; j &lt; nspec; j++) {
                        int np = (int) Math.round(cc[i][j] * volumes[i] / CONC_OF_N);
                        wkA[i][j] = np;
                        wkB[i][j] = np;
                    }
                }
            }
        }

        dt = sdRun.fixedStepDt;
        lndt = Math.log(dt);

        // take logs of integers once only and store;
        intlogs = new double[10000];
        intlogs[0] = -99;
        for (int i = 1; i &lt; intlogs.length; i++) {
            intlogs[i] = Math.log(i);
        }

        // final things we need is something to generate particle numbers
        // for steps of given n, p
        if (useBinomial())
            interpSG = InterpolatingStepGenerator.getBinomialGenerator();
        else if (usePoisson()) {
            interpSG = InterpolatingStepGenerator.getPoissonGenerator();
        } else {
            E.error(&quot;unknown probability distribution&quot;);
        }

        if (doShared() || doParticle() || doIndependent()) {
            if (doShared()) {
                E.info(&quot;Using SHARED destination allocation&quot;);
            } else {
                E.info(&quot;Using PER PARTICLE destination allocation&quot;);
            }
            lnpSharedOut = new double[nel][nspec];
            pSharedOut = new double[nel][nspec];
            fSharedExit = new double[nel][nspec][];

            int maxnn = 0;
            for (int iel = 0; iel &lt; nel; iel++) {
                for (int k = 0; k &lt; nspec; k++) {
                    int nn = neighbors[iel].length;
                    fSharedExit[iel][k] = new double[nn];
                    if (nn &gt; maxnn) {
                        maxnn = nn;
                    }
                }
            }
            E.info(&quot;max no of neighbors for a single element is &quot; + maxnn);

            for (int iel = 0; iel &lt; nel; iel++) {
                for (int k = 0; k &lt; nspec; k++) {
                    int inbr[] = neighbors[iel];
                    double lngnbr[] = lnCC[iel];
                    int nnbr = inbr.length;
                    // int np0 = wkA[iel][k];

                    double ptot = 0.;
                    double[] pcnbr = new double[nnbr];

                    for (int j = 0; j &lt; nnbr; j++) {
                        double lnpgo = lnfdiff[k] + lngnbr[j] + lndt - lnvolumes[iel];
                        // probability is dt * K_diff * contact_area /
                        // (center_to_center_distance * source_volume)
                        // gnbr contains the gometry: contact_area / distance

                        double p = Math.exp(lnpgo);
                        ptot += p;
                        pcnbr[j] = ptot;
                    }

                    double lnptot = Math.log(ptot);
                    if (lnptot &gt; -1.) {
                        // WK 9 11 2007
                        System.out.println(&quot;WK===================================&quot;);
                        System.out.println(&quot;In DIFFUSION: probability TOO HIGH!&quot;);
                        System.out.println(&quot;Reduce your timestep, and try again...&quot;);
                        System.out.println(&quot;WK====================================&quot;);
                        System.exit(0);

                        /*
                         * if (nwarn &lt; 4) {
                         * E.shortWarning(&quot;p too large at element &quot; + iel +
                         * &quot; species &quot; + k + &quot; - capping from &quot; +
                         * Math.exp(lnptot) + &quot; to &quot; + Math.exp(-1.)); nwarn++;
                         * } lnptot= -1.;
                         */
                        // WK
                    }

                    pSharedOut[iel][k] = ptot;
                    lnpSharedOut[iel][k] = lnptot;
                    for (int j = 0; j &lt; nnbr; j++) {
                        fSharedExit[iel][k][j] = pcnbr[j] / ptot;
                    }
                }
            }
        }
    }

    @SuppressWarnings(&quot;boxing&quot;)
    private String getGridConcsText(double time) {
        StringBuffer sb = new StringBuffer();
        // TODO tag specific to integer quantities;
        int nspecout = ispecout.length;
        if (nspecout == 0) {
            return &quot;&quot;;
        }

        sb.append(&quot;gridConcentrations &quot; + nel + &quot; &quot; + nspecout + &quot; &quot; + time + &quot; &quot;);
        for (int i = 0; i &lt; nspecout; i++) {
            sb.append(specieIDs[ispecout[i]] + &quot; &quot;);
        }
        sb.append(&quot;\n&quot;);

        for (int i = 0; i &lt; nel; i++) {
            for (int j = 0; j &lt; nspecout; j++) {
                if (writeConcentration) {
                    sb.append(stringd((CONC_OF_N * wkA[i][ispecout[j]] / volumes[i])));

                } else {
                    sb.append(stringi(wkA[i][ispecout[j]]));
                }
            }
            sb.append(&quot;\n&quot;);
        }
        return sb.toString();
    }

    private String getGridConcsPlainText_dumb(int filenum, double time) {
        StringBuffer sb = new StringBuffer();
        sb.append(stringd(time));

        for (int j = 0; j &lt; specIndexesOut[filenum].length; j++) {
            for (int i = 0; i &lt; nel; i++) {
                if (regionsOut[filenum].equals(&quot;default&quot;) || regionsOut[filenum].equals(regionLabels[eltregions[i]])) {

                    int npart = wkA[i][specIndexesOut[filenum][j]];
                    if (writeConcentration) {
                        sb.append(stringd((CONC_OF_N * npart / volumes[i])));
                    } else {
                        sb.append(stringi(npart));
                    }
                }
            }
        }
        sb.append(&quot;\n&quot;);

        return sb.toString();
    }

    @SuppressWarnings(&quot;boxing&quot;)
    private String getStateText() {
        StringBuffer sb = new StringBuffer();
        sb.append(&quot;nrds &quot; + nel + &quot; &quot; + specieIDs.length + &quot;\n&quot;);
        for (int i = 0; i &lt; specieIDs.length; i++) {
            sb.append(specieIDs[i] + &quot; &quot;);
        }
        sb.append(&quot;\n&quot;);
        for (int i = 0; i &lt; nel; i++) {
            for (int j = 0; j &lt; specieIDs.length; j++) {
                sb.append(stringd((CONC_OF_N * wkA[i][j] / volumes[i])));
            }
            sb.append(&quot;\n&quot;);
        }
        return sb.toString();
    }



    public final int run() {
        init();

        if (resultWriter != null) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.html#544">544</a></td></tr><tr class="a"><td>org/textensor/stochdiff/numeric/tmp/Tmp1A.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/tmp/Tmp1A.html#465">465</a></td></tr><tr class="b"><td colspan='2'><div><pre>                resultWriter.writeToFinalSiblingFile(getStateText(), sdRun.stateSavePrefix + Math.round(time) + &quot;.nrds&quot;);
                stateSaveTime += sdRun.getStateSaveInterval();
            }
        }

        long endTime = System.currentTimeMillis();
        E.info(&quot;total time &quot; + (endTime - startTime) + &quot;ms&quot;);
        return 0;

    }

    // NB the following method is one of the only two that need optimizing
    // (the other is nGo in the interpolating step generator)
    // things to do (in the c version)
    // - use BLAS calls for array operations,
    // - remove the two remaining exps
    // - unwrap inner conditionals for different reaction types
    // - make nGo inlinable

    public double advance(double tnow) {

        // add in any injections
        double[][] stims = stimTab.getStimsForInterval(tnow, dt);
        for (int i = 0; i &lt; stims.length; i++) {
            double[] astim = stims[i];
            for (int j = 0; j &lt; astim.length; j++) {
                if (astim[j] &gt; 0.) {
                    // the stimulus could be spread over a number of elements
                    // as yet, assume equal probability of entering any of these
                    // elements (TODO)
                    // the random &lt; asr ensures we get the right number of
                    // particles even the average entry per volume is less than
                    // one
                    // TODO - allow stim type (deterministic or poisson etc) in
                    // config;

                    int nk = stimtargets[i].length;
                    if (nk &gt; 0) {
                        double as = astim[j] / nk;
                        int ias = (int) as;
                        double asr = as - ((int) as);

                        for (int k = 0; k &lt; nk; k++) {
                            int nin = (ias + (random.random() &lt; asr ? 1 : 0));
                            ninjected += nin;

                            wkA[stimtargets[i][k]][j] += nin;
                        }
                    }
                }
            }
        }

        // initialize wkB to the current values.
        // It will hold the midstep values for the leapfrog, after diffusion
        // but before reactions.
        for (int i = 0; i &lt; nel; i++) {
            for (int j = 0; j &lt; nspec; j++) {
                wkB[i][j] = wkA[i][j];
                // if (wkB[i][j] &lt; 0)
                // System.out.println(&quot;ERROR - NEGATIVE POPULATION at volume_element &quot;
                // + i + &quot;, specie &quot; + j);
                // E.error(&quot;ERROR - NEGATIVE POPULATION at volume_element &quot; + i
                // + &quot;, specie &quot; + j);
            }
        }

        // diffusion step;
        for (int iel = 0; iel &lt; nel; iel++) {

            for (int k = 0; k &lt; nspec; k++) {
                if (lnfdiff[k] &gt; -90) {

                    int np0 = wkA[iel][k];

                    if (np0 &gt; 0) {

                        switch(algoID) {
                        case INDEPENDENT:
                            // WK 8 28 2007
                            // parallelDiffusionStep(iel, k);
                            parallelAndSharedDiffusionStep(iel, k);
                            // WK
                            break;
                        case SHARED:
                            // WK 9 11 2007
                            // sharedDiffusionStep(iel, k);
                            parallelAndSharedDiffusionStep(iel, k);
                            // WK
                            break;
                        case PARTICLE:
                            particleDiffusionStep(iel, k);
                            break;

                        default:
                            assert false;
                        }
                    }
                }
            }
        }

        // for the reaction step, the source array is wkB and the
        // destination is wkA
        for (int i = 0; i &lt; nel; i++) {
            for (int j = 0; j &lt; nspec; j++) {
                wkA[i][j] = wkB[i][j];
            }
        }

        // reaction step;
        for (int iel = 0; iel &lt; nel; iel++) {
            double lnvol = lnvolumes[iel];

            // start and end quantities for each species in a single
            // volume
            int[] nstart = wkB[iel];
            int[] nend = wkA[iel];
            for (int isp = 0; isp &lt; nspecie; isp++) {
                nend[isp] = nstart[isp];
            }

            for (int ireac = 0; ireac &lt; nreaction; ireac++) {
                // total number of possible reactions is the number of
                // particles in the smallest reactant population

                int[] ri = reactantIndices[ireac];
                int[] pi = productIndices[ireac];

                int[] rs = reactantStochiometry[ireac];
                int[] ps = productStochiometry[ireac];

                double lnp = lnrates[ireac] + lndt;

                int n = nstart[ri[0]];

                if (ri[1] &gt;= 0) {
                    int nk = nstart[ri[1]];

                    if (nk &lt; n) {
                        lnp += intlog(n);
                        n = nk;
                    } else {
                        lnp += intlog(nk);
                    }
                    lnp -= lnvol;
                    lnp -= LN_PARTICLES_PUVC;
                }

                if (lnp &gt; -1.) {
                    if (nwarn &lt; 5) {
                        E.shortWarning(&quot;p too large at element &quot; + iel + &quot; reaction &quot; + ireac + &quot; capping from &quot;
                                       + Math.exp(lnp) + &quot; to &quot; + &quot; exp(-1.)&quot;);
                        nwarn++;
                    }
                    lnp = -1.;
                }

                if (n &lt;= 0) {

                } else {
                    int ngo = 0;
                    if (n == 1) {
                        // TODO use table to get rid of exp
                        ngo = (random.random() &lt; Math.exp(lnp) ? 1 : 0);
                    } else if (n &lt; StepGenerator.NMAX_STOCHASTIC) {
                        ngo = interpSG.nGo(n, lnp, random.random());

                    } else {
                        if (useBinomial()) {
                            if (n * (Math.exp(lnp)) &lt; NP) {
                                ngo = StepGenerator.gaussianStep(n, Math.exp(lnp), random.gaussian(), random.random(),
                                                                 random.poisson(n * (Math.exp(lnp))), NP);
                                if (ngo &lt; 0) {
                                    ngo = 0;

                                    System.out.println(&quot;in advance (reaction), if (n*Math.exp(lnp)) &lt; &quot; + NP
                                                       + &quot;): ngo is NEGATIVE.&quot;);
                                    System.out.println(&quot;ngo: &quot; + ngo + &quot; n: &quot; + n + &quot; Math.exp(lnp): &quot; + Math.exp(lnp));
                                }
                            } else {
                                ngo = StepGenerator.gaussianStep(n, Math.exp(lnp), random.gaussian(), random.random());
                                if (ngo &lt; 0) {
                                    ngo = 0;

                                    System.out.println(&quot;in advance (reaction), if (n*Math.exp(lnp)) &gt;= &quot; + NP
                                                       + &quot;): ngo is NEGATIVE.&quot;);
                                    System.out.println(&quot;ngo: &quot; + ngo + &quot; n: &quot; + n + &quot; Math.exp(lnp): &quot; + Math.exp(lnp));
                                }
                            }

                        } else {
                            ngo = StepGenerator.poissonStep(n, Math.exp(lnp), random.gaussian(), random.random());
                            if (ngo &lt; 0) {
                                ngo = 0;

                                System.out.println(&quot;in advance (reaction), if not using binomial: ngo is NEGATIVE.&quot;);
                                System.out.println(&quot;ngo: &quot; + ngo + &quot; n: &quot; + n + &quot; Math.exp(lnp): &quot; + Math.exp(lnp));
                            }
                        }
                    }
                    // WK 7 2 2008: if ngo is negative, exit.
                    // if (ngo &lt; 0)
                    // {
                    // System.out.println(&quot;in advance: ngo is NEGATIVE. Exiting...&quot;);
                    // System.exit(0);
                    // }
                    // WK

                    // update the new quantities in npn;
                    int ri0 = ri[0];
                    int ri1 = ri[1];
                    int rs0 = rs[0];
                    int rs1 = rs[1];

                    int navail = nend[ri0] / rs[0];
                    // AB changed navail &gt; nend[ri1] / rs1 to navail &lt; nend[ri1]
                    // / rs1
                    if (ri1 &gt;= 0 &amp;&amp; navail &gt; nend[ri1] / rs1) {

                        navail = nend[ri1] / rs1;
                    }
                    if (ngo &gt; navail) {
                        // TODO as for diffusion, we've got more particles going
                        // than there actually are. Should regenerate all
                        // reactions on theis element
                        // or use a binomial to share them out
                        // or use a smaller timestep;

                        if (nwarn &lt; 10) {
                            E.shortWarning(&quot;reaction &quot; + ireac + &quot; ran out of particles - need &quot; + ngo + &quot; but have &quot;
                                           + navail);
                            nwarn++;
                        }

                        ngo = navail;

                    }

                    // WK 9 25 2007: setting inc/decrements (i.e., ngo*xxx) to
                    // zero explicitly
                    // to avoid floating point error
                    if (ngo == 0) {
                        int pi0 = pi[0];
                        int pi1 = pi[1];
                        nend[ri0] -= 0;
                        if (ri1 &gt;= 0)
                            nend[ri1] -= 0;
                        nend[pi0] += 0;
                        if (pi1 &gt;= 0)
                            nend[pi1] += 0;
                    } else {
                        // WK
                        nend[ri0] -= ngo * rs0;

                        if (ri1 &gt;= 0) {
                            nend[ri1] -= ngo * rs1;
                        }
                        // WK 3/16/2010
                        if (nend[ri0] &lt; 0) {
                            System.out.println(&quot;nend[ri0] is NEGATIVE!&quot;);
                        }
                        if (ri1 &gt;= 0 &amp;&amp; nend[ri1] &lt; 0) {
                            System.out.println(&quot;nend[ri1] is NEGATIVE!&quot;);
                        }
                        // WK

                        int pi0 = pi[0];
                        int pi1 = pi[1];

                        nend[pi0] += ngo * ps[0];
                        if (pi1 &gt;= 0) {
                            nend[pi1] += ngo * ps[1];
                        }
                    }

                    // TODO this &quot;if (ri[1] &gt;= 0)&quot; business is not great
                    // it applies for the A+B-&gt;C case, where there is a
                    // second reactant. We could probably do better by
                    // unrolling the four cases into separate blocks according
                    // to the reaction type
                    // - a good case for code generation.
                }
            }
        }

        // now wkA contains the actual numbers again;
        return dt;
    }

    // WK 8 28 2007
    private final void parallelAndSharedDiffusionStep(int iel, int k) {
        int np0 = wkA[iel][k];
        int inbr[] = neighbors[iel];
        double[] fshare = fSharedExit[iel][k];

        int ngo = 0;
        int ngo_remaining = 0; // for independent diffusion step      ***KTB edit - this is number of molecules not yet diffused
        int num_molecules_diffused_so_far = 0;

        if (np0 == 1) {
            ngo = (random.random() &lt; pSharedOut[iel][k] ? 1 : 0);
        } else if (np0 &lt; StepGenerator.NMAX_STOCHASTIC) {
            ngo = interpSG.nGo(np0, Math.log(pSharedOut[iel][k]), random.random());

            if (ngo &lt; 0) {
                System.out.println(&quot;in parallelAndSharedDiffusionStep 1st else: ngo is NEGATIVE. Exiting...&quot;);</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.html#972">972</a></td></tr><tr class="a"><td>org/textensor/stochdiff/numeric/tmp/Tmp1A.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/tmp/Tmp1A.html#893">893</a></td></tr><tr class="b"><td colspan='2'><div><pre>                }
                // WK

                wkB[iel][k] -= ngo;
                wkB[inbr[j]][k] += ngo;
                ngo_remaining-=ngo;
            } //end of loop through all but last neighbor

            ngo = ngo_remaining;

            wkB[iel][k] -= ngo;
            wkB[inbr[inbr.length - 1]][k] += ngo;
            // WK 3/16/2010
            if (wkB[iel][k] &lt; 0) {
                System.out.println(&quot;In INDEPENDENT DIFFUSION, wkB[iel][k] NEGATIVE!!!&quot;);
            }
            //

        }
    }

    // WK

    private final void parallelDiffusionStep(int iel, int k) {
        int inbr[] = neighbors[iel];
        double lngnbr[] = lnCC[iel];
        int nnbr = inbr.length;
        int np0 = wkA[iel][k];

        for (int j = 0; j &lt; nnbr; j++) {
            // use logs here so the operations are all additions
            // and the compiler should be able to be clever

            double lnpgo = lnfdiff[k] + lngnbr[j] + lndt - lnvolumes[iel];
            // probability is dt * K_diff * contact_area /
            // (center_to_center_distance * source_volume)
            // gnbr contains the gometry: contact_area / distance

            if (lnpgo &gt; -1.) {
                if (nwarn &lt; 4) {
                    E.shortWarning(&quot;p too large at element &quot; + iel + &quot; transition &quot; + j + &quot; to  &quot; + inbr[j]
                                   + &quot; - capping &quot; + Math.exp(lnpgo) + &quot; coupling is &quot; + lngnbr[j]);
                    nwarn++;
                }
                lnpgo = -1.;
            }

            int ngo = 0;
            if (np0 == 1) {
                // TODO - use table anyway - avoid exp!
                ngo = (random.random() &lt; Math.exp(lnpgo) ? 1 : 0);
            } else if (np0 &lt; StepGenerator.NMAX_STOCHASTIC) {
                ngo = interpSG.nGo(np0, lnpgo, random.random());
            } else {
                if (useBinomial()) {
                    if (np0 * (Math.exp(lnpgo)) &gt;= 10) {
                        ngo = StepGenerator.gaussianStep(np0, Math.exp(lnpgo), random.gaussian(), random.random());
                    } else {
                        ngo = StepGenerator.gaussianStep(np0, Math.exp(lnpgo), random.gaussian(), random.random(),
                                                         random.poisson(np0 * (Math.exp(lnpgo))), NP);
                    }
                } else {
                    ngo = StepGenerator.poissonStep(np0, Math.exp(lnpgo), random.gaussian(), random.random());
                }
            }

            // System.out.println(&quot;iel j ngo &quot; + iel + &quot; &quot; + j + &quot; &quot; + ngo + &quot; &quot;
            // + np0);

            if (ngo &gt; wkB[iel][k]) {
                if (nwarn &lt; 10) {
                    E.shortWarning(&quot;ran out of particles - curtailing last transition from &quot; + ngo + &quot; to &quot;
                                   + wkB[iel][k] + &quot; leaving point &quot; + iel + &quot; species &quot; + k);
                } else if (nwarn == 10) {
                    E.info(&quot;Suppressing future warnings&quot;);
                }
                nwarn++;

                ngo = wkB[iel][k];
                // TODO probably worth flagging if this ever happens
                // it means your steps could be too large
                // MATH if it does happen, there is a consistent
                // bias in that the last exit is the one that
                // is curtailed. We should actually restart
                // this set of jumps and get new fluxes to all
                // neighbours
            }

            wkB[iel][k] -= ngo;
            wkB[inbr[j]][k] += ngo;
        }
    }

    private final void sharedDiffusionStep(int iel, int k) {

        int np0 = wkA[iel][k];
        int inbr[] = neighbors[iel];
        // int nnbr = inbr.length;
        double[] fshare = fSharedExit[iel][k];
        double lnptot = lnpSharedOut[iel][k];

        int ngo = 0;
        if (np0 == 1) {
            // TODO - use table anyway - avoid exp!
            ngo = (random.random() &lt; Math.exp(lnptot) ? 1 : 0);

        } else if (np0 &lt; StepGenerator.NMAX_STOCHASTIC) {
            ngo = interpSG.nGo(np0, lnptot, random.random());

        } else {
            if (useBinomial()) {
                ngo = StepGenerator.gaussianStep(np0, Math.exp(lnptot), random.gaussian(), random.random());
            } else {
                ngo = StepGenerator.poissonStep(np0, Math.exp(lnptot), random.gaussian(), random.random());
            }
        }

        wkB[iel][k] -= ngo;
        for (int i = 0; i &lt; ngo; i++) {
            double r = random.random();
            int io = 0;
            while (r &gt; fshare[io]) {
                io++;
            }
            wkB[inbr[io]][k] += 1;
        }
    }

    private final void particleDiffusionStep(int iel, int k) {
        int np0 = wkA[iel][k];
        int inbr[] = neighbors[iel];
        // int nnbr = inbr.length;
        double[] fshare = fSharedExit[iel][k];
        double ptot = pSharedOut[iel][k];

        for (int i = 0; i &lt; np0; i++) {
            double r = random.random();

            if (r &lt; ptot) {
                wkB[iel][k] -= 1;
                double fr = r / ptot;
                int io = 0;
                while (fr &gt; fshare[io]) {
                    io++;
                }
                wkB[inbr[io]][k] += 1;
            }
        }
    }

    public final double intlog(int i) {
        double ret = 0.;
        if (i &lt;= 0) {
            ret = -99.;
        } else {
            ret = (i &lt; intlogs.length ? intlogs[i] : Math.log(i));
        }
        return ret;
    }

    public long getParticleCount() {
        long ret = 0;
        for (int i = 0; i &lt; nel; i++) {
            for (int j = 0; j &lt; nspec; j++) {
                ret += wkA[i][j];
            }
        }

        E.info(&quot;number injected = &quot; + ninjected);
        return ret;
    }

    protected String getGridConcsHeadings_dumb(int filenum, VolumeGrid vgrid) {
        StringBuffer sb = new StringBuffer();

        sb.append(&quot;time&quot;);
        for (int j = 0; j &lt; specIndexesOut[filenum].length; j++) {

            for (int i = 0; i &lt; nel; i++) {

                // WK 6 17 2007
                if (regionsOut[filenum].equals(&quot;default&quot;) || regionsOut[filenum].equals(regionLabels[eltregions[i]])) {
                    sb.append(&quot; Vol_&quot; + i);
                    sb.append(&quot;_&quot; + regionLabels[eltregions[i]]);

                    if (vgrid.getGroupID(i) != null) {
                        sb.append(&quot;.&quot; + vgrid.getGroupID(i));

                    } else if (vgrid.getLabel(i) != null) {
                        String tempLabel = vgrid.getLabel(i);
                        if (tempLabel.indexOf(&quot;.&quot;) &gt; 0) {
                            sb.append(&quot;.&quot; + tempLabel.substring(0, tempLabel.indexOf(&quot;.&quot;)));
                        }
                    }
                    if (submembranes[i] == true) {
                        sb.append(&quot;_submembrane&quot;);
                    } else {
                        sb.append(&quot;_cytosol&quot;);
                    }
                    if (vgrid.getLabel(i) != null) {
                        String tempLabel = vgrid.getLabel(i);
                        if (tempLabel.indexOf(&quot;.&quot;) &gt; 0) {
                            sb.append(&quot;_&quot; + tempLabel.substring(tempLabel.indexOf(&quot;.&quot;) + 1, tempLabel.length()));
                        } else {
                            sb.append(&quot;_&quot; + vgrid.getLabel(i));
                        }
                    }
                    // WK
                    sb.append(&quot;_Spc_&quot; + specieIDs[specIndexesOut[filenum][j]]);

                }
            }
        }
        sb.append(&quot;\n&quot;);
        return sb.toString();
    }

}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/serial/xml/XMLWriter.java</td><td><a href="./xref/org/catacomb/serial/xml/XMLWriter.html#183">183</a></td></tr><tr class="a"><td>org/textensor/xml/XMLWriter.java</td><td><a href="./xref/org/textensor/xml/XMLWriter.html#158">158</a></td></tr><tr class="b"><td colspan='2'><div><pre>                appendObject(sbv, psk + &quot;   &quot;, null, listobj);
            }
        }


        sbv.append(psk);
        sbv.append(&quot;&lt;/&quot; + tag + &quot;&gt;\n&quot;);
    }



    private void appendNV(StringBuffer sbv, String sk, String name, String value) {
        sbv.append(sk + &quot;&lt;&quot; + name + &quot;&gt;&quot;);
        appendString(sbv, value);
        sbv.append(&quot;&lt;/&quot; + name + &quot;&gt;\n&quot;);
    }


    private void appendNV(StringBuffer sbv, String sk, String name, boolean value) {
        sbv.append(sk + &quot;&lt;&quot; + name + &quot;&gt;&quot;);
        sbv.append(value ? &quot;1&quot; : &quot;0&quot;);
        sbv.append(&quot;&lt;/&quot; + name + &quot;&gt;\n&quot;);
    }



    private void appendNV(StringBuffer sbv, String sk, String name, int value) {
        sbv.append(sk + &quot;&lt;&quot; + name + &quot;&gt;&quot;);
        sbv.append(&quot;&quot; + value);
        sbv.append(&quot;&lt;/&quot; + name + &quot;&gt;\n&quot;);
    }


    private void appendNV(StringBuffer sbv, String sk, String name, double value) {
        sbv.append(sk + &quot;&lt;&quot; + name + &quot;&gt;&quot;);
        sbv.append(&quot;&quot; + value);
        sbv.append(&quot;&lt;/&quot; + name + &quot;&gt;\n&quot;);
    }



    private void appendNV(StringBuffer sbv, String sk, String name, String[] value) {
        sbv.append(sk + &quot;&lt;&quot; + name + &quot;&gt;\n&quot;);

        for (int i = 0; i &lt; value.length; i++) {
            sbv.append(sk);
            sbv.append(&quot;   &quot;);
            appendString(sbv, (value[i] != null ? value[i] : &quot;&quot;));
            sbv.append(&quot;\n&quot;);
        }
        sbv.append(sk + &quot;&lt;/&quot; + name + &quot;&gt;\n&quot;);
    }


    private void appendNV(StringBuffer sbv, String sk, String name, int[] value) {
        sbv.append(sk + &quot;&lt;&quot; + name + &quot;&gt;&quot;);
        for (int i = 0; i &lt; value.length; i++) {
            if (i % 16 == 0)
                sbv.append(&quot;\n&quot; + sk + &quot;   &quot;);
            sbv.append(&quot; &quot; + value[i] + &quot; &quot;);
        }
        sbv.append(&quot;\n&quot;);
        sbv.append(sk + &quot;&lt;/&quot; + name + &quot;&gt;\n&quot;);
    }


    private void appendNV(StringBuffer sbv, String sk, String name, boolean[] value) {
        sbv.append(sk + &quot;&lt;&quot; + name + &quot;&gt;\n&quot; + sk + &quot;  &quot;);
        for (int i = 0; i &lt; value.length; i++) {
            sbv.append(&quot; &quot; + (value[i] ? 1 : 0) + &quot; &quot;);
        }
        sbv.append(&quot;\n&quot;);
        sbv.append(sk + &quot;&lt;/&quot; + name + &quot;&gt;\n&quot;);
    }


    private void appendNV(StringBuffer sbv, String sk, String name, double[] value) {
        sbv.append(sk + &quot;&lt;&quot; + name + &quot;&gt;&quot;);
        for (int i = 0; i &lt; value.length; i++) {
            if (i % 4 == 0)
                sbv.append(&quot;\n&quot; + sk + &quot;   &quot;);
            sbv.append(&quot; &quot; + value[i] + &quot; &quot;);
        }
        sbv.append(&quot;\n&quot;);
        sbv.append(sk + &quot;&lt;/&quot; + name + &quot;&gt;\n&quot;);
    }



    private void appendNV(StringBuffer sbv, String sk, String name, int[][] value) {
        sbv.append(sk + &quot;&lt;&quot; + name + &quot;&gt;\n&quot;);
        for (int i = 0; i &lt; value.length; i++) {
            sbv.append(sk);
            sbv.append(&quot;   &lt;row&gt;&quot;);
            int[] ii = value[i];
            for (int k = 0; k &lt; ii.length; k++) {
                if (k % 16 == 0)
                    sbv.append(&quot;\n &quot; + sk + &quot;      &quot;);
                sbv.append(&quot; &quot; + ii[k] + &quot; &quot;);
            }
            sbv.append(&quot;\n&quot;);
            sbv.append(sk);
            sbv.append(&quot;   &quot;);
            sbv.append(&quot;&lt;/row&gt;\n&quot;);
        }
        sbv.append(sk + &quot;&lt;/&quot; + name + &quot;&gt;\n&quot;);
    }



    private void appendNV(StringBuffer sbv, String sk, String name, double[][] value) {
        sbv.append(sk + &quot;&lt;&quot; + name + &quot;&gt;\n&quot;);
        for (int i = 0; i &lt; value.length; i++) {
            sbv.append(sk);
            sbv.append(&quot;   &lt;row&gt;&quot;);
            double[] ii = value[i];
            for (int k = 0; k &lt; ii.length; k++) {
                if (k % 4 == 0)
                    sbv.append(&quot;\n &quot; + sk + &quot;      &quot;);
                sbv.append(&quot; &quot; + ii[k] + &quot; &quot;);
            }
            sbv.append(&quot;\n&quot;);
            sbv.append(sk);
            sbv.append(&quot;   &quot;);
            sbv.append(&quot;&lt;/row&gt;\n&quot;);
        }
        sbv.append(sk + &quot;&lt;/&quot; + name + &quot;&gt;\n&quot;);

    }



    private void appendString(StringBuffer sbv, String sssin) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/util/FileUtil.java</td><td><a href="./xref/org/catacomb/util/FileUtil.html#78">78</a></td></tr><tr class="a"><td>org/textensor/util/FileUtil.java</td><td><a href="./xref/org/textensor/util/FileUtil.html#80">80</a></td></tr><tr class="b"><td colspan='2'><div><pre>                E.error(&quot;Cant read file &quot; + f);
            }
        }
        return sdat;
    }



    public static boolean writeStringToFile(String sdat, File f) {
        String fnm = f.getName();
        boolean ok = false;
        if (f != null) {
            boolean dogz = (fnm.endsWith(&quot;.gz&quot;));
            try {
                OutputStream fos = new FileOutputStream(f);
                if (dogz) {
                    fos = new GZIPOutputStream(fos);
                }
                OutputStreamWriter osw = new OutputStreamWriter(fos);

                osw.write(sdat, 0, sdat.length());
                osw.close();
                ok = true;

            } catch (IOException ex) {
                E.error(&quot;file writing error, trying to write file &quot; + fnm);
                ex.printStackTrace();
            }
        }
        return ok;
    }



    public static String getRootName(File f) {
        String fnm = f.getName();
        String root = fnm.substring(0, fnm.lastIndexOf(&quot;.&quot;));
        return root;
    }



    public static void writeBytes(byte[] ba, File f) {
        writeByteArrayToFile(ba, f);
    }


    public static void writeByteArrayToFile(byte[] ba, File f) {
        if (f == null) {
            return;
        }
        try {
            OutputStream os = new BufferedOutputStream(new FileOutputStream(f));
            os.write(ba);
            os.flush();
        } catch (Exception e) {
            E.error(&quot;cant write byte array &quot; + ba + &quot; to &quot; + f);
        }
    }



    public static void copyFile(File fsrc, File fdest) {
        if (fsrc.exists()) {
            try {
                InputStream in = new FileInputStream(fsrc);
                OutputStream out = new FileOutputStream(fdest);

                // Transfer bytes from in to out
                byte[] buf = new byte[1024];
                int len;
                while ((len = in.read(buf)) &gt; 0) {
                    out.write(buf, 0, len);
                }
                in.close();
                out.close();
            } catch (Exception ex) {
                E.error(&quot;file copy exception&quot;);
            }

        } else {
            E.warning(&quot;copy - missing file &quot; + fsrc);
        }
    }



    public static String findPath(File f, String name) {
        String ret = null;

        for (File fs : f.listFiles()) {
            if (fs.getName().equals(name)) {
                ret = &quot;&quot;;
                break;
            }
        }

        if (ret == null) {
            for (File fd : f.listFiles()) {
                if (fd.isDirectory()) {
                    String s = findPath(fd, name);
                    if (s != null) {
                        if (s.equals(&quot;&quot;)) {
                            ret = fd.getName();
                        } else {
                            ret = fd.getName() + &quot;/&quot; + s;
                        }
                        break;
                    }
                }
            }
        }
        return ret;
    }



    public static String readFirstLine(File f) {

        String ret = null;
        if (f != null) {
            try {
                InputStream ins = new FileInputStream(f);
                InputStreamReader insr = new InputStreamReader(ins);
                BufferedReader fr = new BufferedReader(insr);
                ret = fr.readLine();
                fr.close();

            } catch (IOException ex) {
                E.error(&quot;file read error &quot;);
                ex.printStackTrace();
            }
        }
        return ret;
    }



    public static String getRelativeDirectory(File ftgt, File rtFolder) {
        File fpar = ftgt.getParentFile();
        int ns = 0;

        String sret = null;

        while (fpar != null &amp;&amp; !(fpar.equals(rtFolder))) {
            if (sret == null) {
                sret = fpar.getName();
            } else {
                sret = fpar.getName() + &quot;/&quot; + sret;
            }
            fpar = fpar.getParentFile();

            ns += 1;
            if (ns &gt; 8) {
                E.error(&quot;too many steps trying to get relative files ? &quot; + ftgt.getAbsolutePath() + &quot; &quot;
                        + rtFolder.getAbsolutePath());
                break;
            }
        }

        return sret;
    }


    // TODO make this smarter (or use GlobFileFilter from jakarta ORO ?)
    public static ArrayList&lt;File&gt; matchingFiles(String srcPattern) {
        ArrayList&lt;File&gt; ret = new ArrayList&lt;File&gt;();
        if (srcPattern.indexOf(&quot;*&quot;) &lt; 0) {
            File fd = new File(srcPattern);
            if (fd.exists() &amp;&amp; fd.isDirectory()) {
                for (File f : fd.listFiles()) {
                    ret.add(f);
                }
            }

        } else {
            int istar = srcPattern.indexOf(&quot;*&quot;);
            String sa = srcPattern.substring(0, istar);
            String sb = srcPattern.substring(istar + 1, srcPattern.length());
            File ftop = new File(sa);
            for (File fg : ftop.listFiles()) {
                File fp = new File(fg, sb);
                if (fp.exists()) {
                    ret.add(fp);
                }
            }
        }
        return ret;
    }</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/serial/xml/XMLTokenizer.java</td><td><a href="./xref/org/catacomb/serial/xml/XMLTokenizer.html#220">220</a></td></tr><tr class="a"><td>org/textensor/xml/XMLTokenizer.java</td><td><a href="./xref/org/textensor/xml/XMLTokenizer.html#224">224</a></td></tr><tr class="b"><td colspan='2'><div><pre>                        int[] ipr = new int[3];
                        while (ipr[0] != ims || ipr[1] != ims || ipr[2] != iabc) {
                            itok = ntok(streamTokenizer);

                            if (streamTokenizer.ttype == StreamTokenizer.TT_WORD) {
                                svalue += streamTokenizer.sval + &quot; &quot;;
                            } else if (streamTokenizer.ttype == StreamTokenizer.TT_NUMBER) {
                                svalue += &quot; &quot; + streamTokenizer.nval;
                            }
                            if (streamTokenizer.sval != null &amp;&amp; streamTokenizer.sval.endsWith(&quot;--&quot;)) {
                                ipr[1] = ims;
                                ipr[2] = ims;
                            } else {
                                ipr[0] = ipr[1];
                                ipr[1] = ipr[2];
                                ipr[2] = itok;
                            }
                        }
                        streamTokenizer.pushBack();
                    } else {
                        E.error(&quot;found &lt;!- but not followed by -  at &quot; + streamTokenizer.lineno());
                    }
                } else {
                    E.error(&quot;found &lt;! but not followed by -  at &quot; + streamTokenizer.lineno());
                }
                setStringValue(xmlt, svalue);


            } else if (sv.startsWith(&quot;/&quot;)) {
                xmlt.setType(XMLToken.CLOSE);
                setStringValue(xmlt, sv.substring(1, sv.length()));

            } else {
                if (sv.endsWith(&quot;/&quot;)) {
                    xmlt.setType(XMLToken.OPENCLOSE);
                    setStringValue(xmlt, sv.substring(0, sv.length() - 1));
                } else {
                    xmlt.setType(XMLToken.OPEN);
                    setStringValue(xmlt, sv);
                }
            }

            itok = ntok(streamTokenizer);
            if (itok == iabc) {
                // fine - end of tag;

            } else if (streamTokenizer.ttype == StreamTokenizer.TT_WORD) {
                String[] attNV = new String[160]; // EFF check eff
                int natt = 0;

                while (itok != iabc) {

                    if (streamTokenizer.ttype == StreamTokenizer.TT_WORD) {
                        if (streamTokenizer.sval.equals(&quot;/&quot;)) {
                            xmlt.setType(XMLToken.OPENCLOSE);

                        } else {
                            attNV[2 * natt] = streamTokenizer.sval;
                            itok = ntok(streamTokenizer);
                            if (itok == ieq) {
                                itok = ntok(streamTokenizer);

                                if (itok == iq) {
                                    attNV[2 * natt + 1] = streamTokenizer.sval;
                                    natt++;
                                } else {
                                    E.shortError(&quot;expecting quoted string &quot; + &quot; while reading atributes &quot;
                                                 + &quot;but got &quot; + stok(itok) + &quot; sval=&quot; + streamTokenizer.sval
                                                 + &quot; nval=&quot; + streamTokenizer.nval);
                                    E.info(&quot;original string was &quot; + srcString);
                                }
                            } else {
                                E.shortError(&quot;at &quot; + streamTokenizer.lineno()
                                             + &quot; expecting = while reading attributes &quot; + &quot;but got &quot; + stok(itok)
                                             + &quot; sval=&quot; + streamTokenizer.sval + &quot; nval=&quot; + streamTokenizer.nval);
                                E.info(&quot;original string was &quot; + srcString);
                            }
                        }
                    } else {
                        E.shortError(&quot;at line &quot; + streamTokenizer.lineno()
                                     + &quot; found non-word while reading attributes &quot; + stok(itok)
                                     + &quot;  item so far = &quot; + this);
                        E.info(&quot;original string was &quot; + srcString);
                    }
                    itok = ntok(streamTokenizer);
                }
                String[] sat = new String[2 * natt];
                for (int i = 0; i &lt; 2 * natt; i++) {
                    sat[i] = attNV[i];
                }
                xmlt.setAttributes(sat);

            } else {
                E.error(&quot;expecting word &quot; + stok(itok));

            }

        } else {
            // just return the token as a string;
            xmlt.setType(XMLToken.STRING);
            setStringValue(xmlt, stok(itok));

        }
        return xmlt;
    }



    private int ntok(StreamTokenizer st) {
        int itok = -1;
        try {
            itok = st.nextToken();
        } catch (IOException e) {
            err(&quot; &quot; + e);
            itok = -999;
        }

        /*
         * if (count &lt; 20) { E.info(&quot;token &quot; + count + &quot; &quot; + itok + &quot; &quot; + st.sval + &quot; &quot; +
         * st.nval); count += 1; }
         */

        return itok;
    }


    private String stok(int itok) {
        return &quot;&quot; + (char)itok;
    }


    private void err(String s) {
        System.out.println(s);
    }

}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/numeric/math/Matrix.java</td><td><a href="./xref/org/catacomb/numeric/math/Matrix.html#65">65</a></td></tr><tr class="a"><td>org/textensor/stochdiff/numeric/math/Matrix.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/math/Matrix.html#111">111</a></td></tr><tr class="b"><td colspan='2'><div><pre>        return m;
    }


    public void setDims(int d1, int d2) {
        n1 = d1;
        n2 = d2;
    }


    public void identise() {
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                a[i][j] = 0.;
            }
            a[i][i] = 1.;
        }
    }


    public void randomise() {
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                a[i][j] = Math.random();
            }
        }
    }


    public void zero() {
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                a[i][j] = 0.;
            }
        }
    }



    public Matrix identity() {
        Matrix m = copy();
        m.identise();
        return m;
    }


    public Matrix random() {
        Matrix m = copy();
        m.randomise();
        return m;
    }



    public void add(double d) {
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                a[i][j] += d;
            }
        }
    }



    public static Matrix[] average(Matrix[] ma, Matrix[] mb, double f) {
        int n = ma.length;
        Matrix[] res = new Matrix[n];
        for (int i = 0; i &lt; n; i++) {
            res[i] = average(ma[i], mb[i], f);
        }
        return res;
    }


    public static Matrix average(Matrix ma, Matrix mb, double f) {
        double g = 1. - f;
        int n = ma.n;
        Matrix res = new Matrix(n);
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                res.a[i][j] = f * mb.a[i][j] + g * ma.a[i][j];
            }
        }
        return res;
    }



    public void add(Matrix m) {
        if (m.n != n) {
            Sp(&quot;incompativle dims in Matrix.mplyBy &quot; + n + &quot; &quot; + m.n);

        } else {
            for (int i = 0; i &lt; n; i++) {
                for (int j = 0; j &lt; n; j++) {
                    a[i][j] += m.a[i][j];
                }
            }
        }
    }


    public Matrix sum(Matrix m) {
        Matrix mr = copy();
        mr.zero();
        if (m.n != n) {
            Sp(&quot;incompativle dims in Matrix.mplyBy &quot; + n + &quot; &quot; + m.n);

        } else {
            for (int i = 0; i &lt; n; i++) {
                for (int j = 0; j &lt; n; j++) {
                    mr.a[i][j] = a[i][j] + m.a[i][j];
                }
            }
        }
        return mr;
    }


    public void mpyBy(double d) {
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                a[i][j] *= d;
            }
        }
    }


    public void mpyBy(Matrix m) {
        a = (prod(m)).a;
    }


    public Matrix prod(Matrix m) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/numeric/math/Matrix.java</td><td><a href="./xref/org/catacomb/numeric/math/Matrix.html#298">298</a></td></tr><tr class="a"><td>org/textensor/stochdiff/numeric/math/Matrix.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/math/Matrix.html#392">392</a></td></tr><tr class="b"><td colspan='2'><div><pre>                m.a[i][j] = a[j][i];
            }
        }
        return m;
    }


    public double det() {
        Matrix t = copy();
        t.LU();
        double d = 1.0 * t.sign;
        for (int i = 0; i &lt; n; i++) {
            d *= t.a[i][i];
        }
        return d;
    }



    public double[][] copyMat() {
        double[][] ar = new double[n][n];
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                ar[i][j] = a[i][j];
            }
        }
        return ar;
    }



    public void LU() {
        int i, imax, j, k;
        double big, dum, sum, temp;
        double vv[] = new double[n];
        double TINY = 1.0e-20;

        sign = 1;

        imax = -1;
        for (i = 0; i &lt; n; i++) {
            big = 0.0;
            for (j = 0; j &lt; n; j++) {
                if ((temp = Math.abs(a[i][j])) &gt; big) {
                    big = temp;
                }
            }
            if (big == 0.0) {
                Sp(&quot;Singular Matrix in routine LUDCMP&quot;);
            }
            vv[i] = 1.0 / big;
        }

        for (j = 0; j &lt; n; j++) {
            for (i = 0; i &lt; j; i++) {
                sum = a[i][j];
                for (k = 0; k &lt; i; k++) {
                    sum -= a[i][k] * a[k][j];
                }
                a[i][j] = sum;
            }
            big = 0.0;
            for (i = j; i &lt; n; i++) {
                sum = a[i][j];
                for (k = 0; k &lt; j; k++) {
                    sum -= a[i][k] * a[k][j];
                }
                a[i][j] = sum;
                if ((dum = vv[i] * Math.abs(sum)) &gt;= big) {
                    big = dum;
                    imax = i;
                }
            }
            if (j != imax) {
                for (k = 0; k &lt; n; k++) {
                    dum = a[imax][k];
                    a[imax][k] = a[j][k];
                    a[j][k] = dum;
                }
                sign = -sign;
                vv[imax] = vv[j];
            }
            perm[j] = imax;
            if (a[j][j] == 0.0) {
                a[j][j] = TINY;
            }
            if (j != n) {
                dum = 1.0 / (a[j][j]);
                for (i = j + 1; i &lt; n; i++) {
                    a[i][j] *= dum;
                }
            }
        }
    }



    public Matrix inverse() {
        Matrix t, r;
        t = copy();
        r = copy();
        t.LU();

        double[] c = new double[n];
        for (int j = 0; j &lt; n; j++) {
            for (int i = 0; i &lt; n; i++) {
                c[i] = 0.0;
            }
            c[j] = 1.0;
            t.lubksb(c);
            for (int i = 0; i &lt; n; i++) {
                r.a[i][j] = c[i];
            }
        }
        return r;
    }</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/interlish/reflect/Narrower.java</td><td><a href="./xref/org/catacomb/interlish/reflect/Narrower.html#104">104</a></td></tr><tr class="a"><td>org/textensor/xml/Narrower.java</td><td><a href="./xref/org/textensor/xml/Narrower.html#103">103</a></td></tr><tr class="b"><td colspan='2'><div><pre>            ArrayList&lt;? extends Object&gt; v = (ArrayList&lt;? extends Object&gt;)ob;
            int n = v.size();
            sret = new String[n];
            int iout = 0;
            for (Object sub : v) {
                sret[iout++] = (String)sub;
            }

        } else {
            err(&quot;ERROR - cant make string array from &quot; + ob);
        }
        return sret;
    }


    public static double[] makeDoubleArray(Object ob) {
        double[] dret = null;
        if (ob instanceof double[]) {
            dret = (double[])ob;

        } else if (ob instanceof ArrayList) {
            ArrayList v = (ArrayList)ob;
            int n = v.size();
            dret = new double[n];
            int iout = 0;
            for (Object sub : v) {
                dret[iout++] = makeDouble(sub);
            }

        } else if (ob instanceof String) {
            dret = readDoubleArray((String)ob);

        } else if (ob != null) {
            dret = new double[1];
            dret[0] = makeDouble(ob);
        }
        return dret;
    }


    public static int[] makeIntArray(Object ob) {
        int[] iret = null;
        if (ob instanceof int[]) {
            iret = (int[])ob;

        } else if (ob instanceof ArrayList) {
            ArrayList v = (ArrayList)ob;
            int n = v.size();
            iret = new int[n];
            int iout = 0;
            for (Object sub : v) {
                iret[iout++] = makeInt(sub);
            }

            // MISSING following needs repeating for other array types
        } else if (ob instanceof String) {
            String sob = (String)ob;
            StringTokenizer st = new StringTokenizer(sob, &quot; ,\n&quot;);
            int ntok = st.countTokens();

            iret = new int[ntok];
            for (int i = 0; i &lt; iret.length; i++) {
                iret[i] = Integer.parseInt(st.nextToken());
            }

        } else if (ob != null) {
            iret = new int[1];
            iret[0] = makeInt(ob);
        }
        return iret;
    }



    public static boolean[] makeBooleanArray(Object ob) {
        boolean[] bret = null;
        if (ob instanceof ArrayList) {
            ArrayList v = (ArrayList)ob;
            int n = v.size();
            bret = new boolean[n];
            int iout = 0;
            for (Object sub : v) {
                bret[iout++] = makeBoolean(sub);
            }
        } else if (ob != null) {
            bret = new boolean[1];
            bret[0] = makeBoolean(ob);
        }
        return bret;
    }


    public static int makeInt(Object arg) throws NumberFormatException {
        int iret = 0;
        if (arg instanceof Integer) {
            iret = ((Integer)arg).intValue();

        } else if (arg instanceof Double) {
            iret = (int)(((Double)arg).doubleValue());

        } else if (arg instanceof String) {
            String s = (String)arg;
            if (s.equals(&quot;false&quot;)) {
                iret = 0;
            } else if (s.equals(&quot;true&quot;)) {
                iret = 1;
            } else {
                iret = parseInt((String)arg);
            }
        } else {
            err(&quot;cant make an int from &quot; + arg + &quot; &quot; + arg.getClass());
        }
        return iret;
    }



    public static int parseInt(String sin) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/serial/xml/XMLTokenizer.java</td><td><a href="./xref/org/catacomb/serial/xml/XMLTokenizer.html#85">85</a></td></tr><tr class="a"><td>org/textensor/xml/XMLTokenizer.java</td><td><a href="./xref/org/textensor/xml/XMLTokenizer.html#86">86</a></td></tr><tr class="b"><td colspan='2'><div><pre>        if (sv.startsWith(&quot;xyz&quot;)) {
            if (cdataHM != null &amp;&amp; cdataHM.containsKey(sv)) {
                sv = cdataHM.get(sv);
            } else {
                E.warning(&quot;looks like a CDATA key, but not present? &quot; + sv);
            }
        }

        xmlt.setStringValue(sv);
    }


    public int lineno() {
        return streamTokenizer.lineno();
    }


    public void initializeStreamTokenizer(StreamTokenizer st) {
        st.resetSyntax();
        st.eolIsSignificant(false);
        st.slashStarComments(false);
        st.slashSlashComments(false);
        st.lowerCaseMode(false);
        String slim = &quot;AZaz09&quot;;
        st.wordChars(slim.charAt(0), slim.charAt(1));
        st.wordChars(slim.charAt(2), slim.charAt(3));
        st.wordChars(slim.charAt(4), slim.charAt(5));
        // st.wordChars(0x00A0, 0x00FF);


        String wsc = &quot; \t\n&quot;;
        for (int i = 0; i &lt; wsc.length(); i++) {
            int ic = wsc.charAt(i);
            st.whitespaceChars(ic, ic);
        }


        st.quoteChar(iq);

        String swc = &quot;_/.:&amp;;,()\'+-.[]{}$&quot;;
        for (int i = 0; i &lt; swc.length(); i++) {
            int ic = swc.charAt(i);
            st.wordChars(ic, ic);
        }
    }


    public XMLToken nextToken() {
        XMLToken xmlt = new XMLToken();
        int itok = ntok(streamTokenizer);


        if (streamTokenizer.ttype == StreamTokenizer.TT_EOF) {
            xmlt.setType(XMLToken.NONE);


        } else if (itok == iq) {
            xmlt.setType(XMLToken.STRING);
            // quoted string;
            String sss = streamTokenizer.sval;
            setStringValue(xmlt, StringEncoder.xmlUnescape(sss));


        } else if (streamTokenizer.ttype == StreamTokenizer.TT_WORD) {
            xmlt.setType(XMLToken.STRING);
            setStringValue(xmlt, StringEncoder.xmlUnescape(streamTokenizer.sval));

        } else if (streamTokenizer.ttype == StreamTokenizer.TT_NUMBER) {
            xmlt.setType(XMLToken.NUMBER);
            // boolean, int or double, all as doubles;
            double d = streamTokenizer.nval;
            ntok(streamTokenizer);
            if (streamTokenizer.ttype == StreamTokenizer.TT_WORD
                    &amp;&amp; ((streamTokenizer.sval).startsWith(&quot;E-&quot;)
                        || (streamTokenizer.sval).startsWith(&quot;E+&quot;) || (streamTokenizer.sval).startsWith(&quot;E&quot;))) { // POSERR
                // -
                // catches
                // wrong
                // things?

                String s = streamTokenizer.sval.substring(1, streamTokenizer.sval.length());
                int ppp = Integer.parseInt(s);
                // err (&quot;st.sval &quot; + st.sval);
                // err (&quot;read exponent: &quot; + ppp);
                d *= Math.pow(10., ppp);
            } else {
                streamTokenizer.pushBack();
            }
            xmlt.setDValue(d);


        } else if (itok == iabo) {
            itok = ntok(streamTokenizer);
            String sv = streamTokenizer.sval;

            if (itok == iqm) {
                // should be the first line of a file - read on until
                // the next question mark, just keeping the text in sinfo
                // for now;
                xmlt.setType(XMLToken.INTRO);
                String svalue = &quot;&quot;;
                itok = -1;
                while (itok != iqm) {
                    itok = ntok(streamTokenizer);
                    if (streamTokenizer.sval != null)
                        svalue += streamTokenizer.sval + &quot; &quot;;
                }
                setStringValue(xmlt, svalue);

            } else if (itok == iexc) {
                itok = ntok(streamTokenizer);
                String sval = streamTokenizer.sval;

                String svalue = &quot;&quot;;
                if (sval != null &amp;&amp; sval.startsWith(&quot;[CDATA[&quot;)) {
                    E.error(&quot;shouldn't get CDATA in xml tokenizer&quot;);

                } else if (sval != null &amp;&amp; sval.startsWith(&quot;--&quot;)) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/druid/swing/RolloverEffect.java</td><td><a href="./xref/org/catacomb/druid/swing/RolloverEffect.html#12">12</a></td></tr><tr class="a"><td>org/catacomb/graph/gui/RolloverEffect.java</td><td><a href="./xref/org/catacomb/graph/gui/RolloverEffect.html#12">12</a></td></tr><tr class="b"><td colspan='2'><div><pre>public class RolloverEffect extends MouseAdapter {

    JComponent button;

    int inormal;
    int iactive;

    Border normalBorder;
    Border activeBorder;

    public final static int NONE = 0;
    public final static int ETCHED_DOWN = 1;
    public final static int ETCHED_UP = 2;
    public final static int RAISED = 2;

    Color bgColor;

    int pL;
    int pR;
    int pT;
    int pB;

    private boolean hasPadding;

    public RolloverEffect(JComponent buttonIn) {
        this(buttonIn, ETCHED_DOWN, ETCHED_UP);
    }



    public RolloverEffect(JComponent buttonIn, int norm, int active) {
        hasPadding = false;
        bgColor = buttonIn.getBackground();

        inormal = norm;
        iactive = active;

        button = buttonIn;


        makeBorders();


        if (button instanceof AbstractButton) {
            ((AbstractButton)button).setBorderPainted(true);

        } else if (button instanceof JMenu) {
            ((JMenu)button).setBorderPainted(true);

        } else if (button instanceof JCheckBox) {
            ((JCheckBox)button).setBorderPainted(true);

        } else if (button instanceof JPanel) {
            // ((JPanel)button).setBorderPainted(true);
        }

        mouseExited(null);

    }




    public void setPadding(int p) {
        setPadding(p, p, p, p);
    }


    public void setPadding(int pl, int pr, int pt, int pb) {
        pL = pl;
        pR = pr;
        pT  = pt;
        pB = pb;
        hasPadding = true;
        makeBorders();
        mouseExited(null);
    }


    public void setBg(Color c) {
        bgColor = c;
        makeBorders();
        mouseExited(null);
    }





    public void makeBorders() {
        normalBorder = makeBorder(inormal);
        activeBorder = makeBorder(iactive);
    }



    public void mouseEntered(MouseEvent me) {
        button.setBorder(activeBorder);
    }


    public void mouseExited(MouseEvent me) {
        button.setBorder(normalBorder);
    }


    private Border makeBorder(int type) {
        Color c = bgColor;
        Color cbr = myBrighter(c);
        Color cdk = myDarker(c);


        Border ret = null;
        if (type == ETCHED_DOWN) {
            // ret = BorderFactory.createEtchedBorder(EtchedBorder.LOWERED);
            ret = BorderFactory.createEtchedBorder(cbr, cdk);

        } else if (type == ETCHED_UP) {
            // ret = BorderFactory.createEtchedBorder(EtchedBorder.RAISED);
            ret = BorderFactory.createEtchedBorder(cdk, cbr);
        } else {
            ret = BorderFactory.createEmptyBorder(2, 2, 2, 2);
        }


        if (hasPadding) {
            Border bdr = BorderFactory.createEmptyBorder(pT, pL, pB, pR);
            ret = BorderFactory.createCompoundBorder(ret, bdr);
        }
        return ret;
    }


    public static Color myBrighter(Color c) {
        return linMod(c, 35);
    }


    public static Color myDarker(Color c) {
        return linMod(c, -35);
    }


    public static Color linMod(Color c, int d) {
        int r = c.getRed();
        int g = c.getGreen();
        int b = c.getBlue();

        r += d;
        g += d;
        b += d;
        r = (r &gt; 0 ? (r &lt; 255 ? r : 255) : 0);
        g = (g &gt; 0 ? (g &lt; 255 ? g : 255) : 0);
        b = (b &gt; 0 ? (b &lt; 255 ? b : 255) : 0);
        return new Color(r, g, b);
    }





}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/interlish/reflect/Narrower.java</td><td><a href="./xref/org/catacomb/interlish/reflect/Narrower.html#223">223</a></td></tr><tr class="a"><td>org/textensor/xml/Narrower.java</td><td><a href="./xref/org/textensor/xml/Narrower.html#221">221</a></td></tr><tr class="b"><td colspan='2'><div><pre>        int iret = 0;
        if (s.startsWith(&quot;0x&quot;)) {
            s = s.substring(2, s.length());
            iret = Integer.parseInt(s, 16);
        } else {
            iret = Integer.parseInt(s, 10);
        }
        return iret;
    }



    public static double makeDouble(Object arg) {
        double dret = 0;
        if (arg instanceof Double) {
            dret = ((Double)arg).doubleValue();

        } else if (arg instanceof String) {
            dret = parseDouble((String)arg);

        } else {
            err(&quot; cant make a double from &quot; + arg + &quot; &quot; + arg.getClass());
            (new Exception()).printStackTrace();
        }
        return dret;
    }


    public static boolean makeBoolean(Object arg) {
        boolean bret = false;
        if (arg instanceof Double) {
            bret = ((((Double)arg).doubleValue()) &gt; 0.5);

        } else if (arg instanceof String) {
            String sob = ((String)arg).trim();
            bret = (sob.equals(&quot;1&quot;) || sob.equals(&quot;true&quot;));
        } else {
            err(&quot; instantiator cant make a boolean from &quot; + arg);
        }
        return bret;
    }



    public static double[][] makeDDArray(Object ob) {
        double[][] dret = null;
        if (ob == null) {
            dret = new double[0][0];

        } else if (ob instanceof Double || ob instanceof String) {
            dret = new double[1][1];
            dret[0][0] = makeDouble(ob);

        } else if (ob instanceof ArrayList) {
            ArrayList v = (ArrayList)ob;
            dret = new double[v.size()][];
            int iout = 0;
            for (Object sub : v) {
                dret[iout++] = makeDoubleArray(sub);
            }
        } else {
            err(&quot;cant make DD array from &quot; + ob);
        }
        return dret;
    }


    public static int[][] makeIIArray(Object ob) {
        int[][] iret = null;
        if (ob == null) {
            iret = new int[0][0];

        } else if (ob instanceof Double || ob instanceof String) {
            iret = new int[1][1];
            iret[0][0] = makeInt(ob);

        } else if (ob instanceof ArrayList) {
            ArrayList v = (ArrayList)ob;
            iret = new int[v.size()][];
            int iout = 0;
            for (Object sub : v) {
                iret[iout++] = makeIntArray(sub);
            }
        } else {
            err(&quot;cant make II array from &quot; + ob);
        }
        return iret;
    }


    public static ArrayList&lt;Object&gt; makeArrayList(Object arg) {
        ArrayList&lt;Object&gt; vret = new ArrayList&lt;Object&gt;();

        if (arg instanceof ArrayList&lt;?&gt;) {
            vret.addAll((ArrayList&lt;?&gt;)arg);

        } else {
            vret.add(arg);
        }
        return vret;
    }




    public static double[] readDoubleArray(String sin) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/serial/xml/XMLWriter.java</td><td><a href="./xref/org/catacomb/serial/xml/XMLWriter.html#103">103</a></td></tr><tr class="a"><td>org/textensor/xml/XMLWriter.java</td><td><a href="./xref/org/textensor/xml/XMLWriter.html#76">76</a></td></tr><tr class="b"><td colspan='2'><div><pre>        }

        String tag = &quot;error&quot;;
        if (knownAs != null) {
            tag = knownAs;
        } else {
            tag = ob.getClass().getName();

            if (conciseTags) {
                int ilast = tag.lastIndexOf(&quot;.&quot;);
                if (ilast &gt;= 0) {
                    tag = tag.substring(ilast + 1, tag.length());
                }
            }
        }

        sbv.append(psk);
        sbv.append(&quot;&lt;&quot; + tag + &quot;&gt;\n&quot;);

        /*
         * if (writeClass) { sbv.append(&quot;&lt;&quot;+tag + &quot; class=\&quot;&quot; +
         * ob.getClass().getName() + &quot;\&quot;&gt;\n&quot;); } else { sbv.append(&quot;&lt;&quot;+tag +
         * &quot;&gt;\n&quot;); }
         */


        String sk = psk + &quot;   &quot;;

        Field[] flds = ob.getClass().getFields();

        for (int i = 0; i &lt; flds.length; i++) {
            String fieldName = flds[i].getName();
            Object ret = null;
            try {
                ret = flds[i].get(ob);
            } catch (Exception e) {
                err(&quot;WARNING - failed to get field &quot; + fieldName + &quot; in  &quot; + ob);
            }
            if (Modifier.isFinal(flds[i].getModifiers()))
                ret = null;

            if (ret instanceof Double) {
                appendNV(sbv, sk, fieldName, ((Double)ret).doubleValue());

            } else if (ret instanceof Integer) {
                appendNV(sbv, sk, fieldName, ((Integer)ret).intValue());

            } else if (ret instanceof Boolean) {
                appendNV(sbv, sk, fieldName, ((Boolean)ret).booleanValue());

            } else if (ret instanceof String) {
                appendNV(sbv, sk, fieldName, (String)ret);

            } else if (ret instanceof double[]) {
                appendNV(sbv, sk, fieldName, (double[])ret);

            } else if (ret instanceof int[]) {
                appendNV(sbv, sk, fieldName, (int[])ret);

            } else if (ret instanceof boolean[]) {
                appendNV(sbv, sk, fieldName, (boolean[])ret);

            } else if (ret instanceof String[]) {
                appendNV(sbv, sk, fieldName, (String[])ret);

            } else if (ret instanceof double[][]) {
                appendNV(sbv, sk, fieldName, (double[][])ret);

            } else if (ret instanceof int[][]) {
                appendNV(sbv, sk, fieldName, (int[][])ret);

            } else if (ret != null) {
                appendObject(sbv, sk, fieldName, ret);</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/numeric/math/Matrix.java</td><td><a href="./xref/org/catacomb/numeric/math/Matrix.html#486">486</a></td></tr><tr class="a"><td>org/textensor/stochdiff/numeric/math/Matrix.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/math/Matrix.html#593">593</a></td></tr><tr class="b"><td colspan='2'><div><pre>            for (int j = 0; j &lt; n; j++) {
                sa[i] += (&quot; &quot; + a[i][j]);
            }
        }
        Sp(&quot; n1: &quot; + n1 + &quot; n2: &quot; + n2);
        for (int i = 0; i &lt; sa.length; i++) {
            Sp(&quot;&quot; + i + &quot; &quot; + sa[i]);
        }
    }



    public double maxAbsElt() {
        double d = 0.0;
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (Math.abs(a[i][j]) &gt; d) {
                    d = Math.abs(a[i][j]);
                }
            }
        }
        return d;
    }



    public Matrix power(int p) {
        Matrix mr = identity();
        int pg = 0;
        int pl = 1;
        Matrix mp = copy();
        while (pg &lt; p) {
            if ((p &amp; pl) &gt; 0) {
                pg += pl;
                mr = mr.prod(mp);
            }
            pl *= 2;
            mp = mp.prod(mp);
        }
        if (pg != p) {
            Sp(&quot;got Matrix power wrong: &quot; + p + &quot; &quot; + pg + &quot; &quot; + pl);
        }
        return mr;
    }


    public Matrix crudeExpOf(double t) {
        Matrix m = copy();
        m.mpyBy(t);
        double eps = 1.0e-8;

        double d = m.maxAbsElt();
        int p = 0;
        double f = 1;
        for (p = 0; d * f &gt; eps; f *= 0.5, p++) {
            ;
        }

        m.mpyBy(f);
        m.add(m.identity());

        for (; p &gt; 0; p--) {
            m.mpyBy(m);
        }
        return m;
    }



    public Matrix expOf(double t) {
        Matrix m = copy();
        m.mpyBy(t);
        double eps = 1.0e-12;

        double d = m.maxAbsElt();
        int p = 0;
        double f = 1;
        for (p = 0; d * f &gt; eps; f *= 0.5, p++) {
            ;
        }

        m.mpyBy(f);
        // now we want to calculate (I + m)^p
        // without doing the obvious

        for (; p &gt; 0; p--) {
            Matrix u = m.copy();
            u.mpyBy(u);
            m.add(m);
            m.add(u);
        }
        m.add(m.identity());
        return m;
    }



    public int randomIndexFromColumn(int c) {
        return randomIndexFromColumn(c, Math.random());
    }


    public final int randomIndexFromColumn(int c, double rin) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/serial/xml/XMLToken.java</td><td><a href="./xref/org/catacomb/serial/xml/XMLToken.html#8">8</a></td></tr><tr class="a"><td>org/textensor/xml/XMLToken.java</td><td><a href="./xref/org/textensor/xml/XMLToken.html#5">5</a></td></tr><tr class="b"><td colspan='2'><div><pre>public class XMLToken {

    final static int NONE = 0;
    final static int OPEN = 1;
    final static int CLOSE = 2;

    final static int NUMBER = 3;
    final static int STRING = 4;

    final static int OPENCLOSE = 5;

    final static int INTRO = 6;
    final static int COMMENT = 7;


    String[] types = {&quot;NONE&quot;, &quot;OPEN&quot;, &quot;CLOSE&quot;, &quot;NUMBER&quot;, &quot;STRING&quot;,
                      &quot;OPENCLOSE&quot;, &quot;INTRO&quot;, &quot;COMMENT&quot;
                     };


    int type;

    String svalue;
    double dvalue;

    int natt;
    String[] attNV;



    public XMLToken() {
        type = NONE;
    }

    /*
    public String toString() {
       String sr = (&quot;XMLToken type=&quot; + type + &quot; sv=&quot; + svalue + &quot; dv=&quot; + dvalue +
    	   &quot; natt=&quot; + natt);
       for (int i = 0; i &lt; natt; i++) {
     sr += &quot;   att[&quot; + i + &quot;]:&quot; + attNV[i] + &quot;\n&quot;;
       }
       return sr;
    }
    */


    public boolean isOpen() {
        return (type == OPEN || type == OPENCLOSE);
    }

    public boolean isClose() {
        return (type == OPENCLOSE || type == CLOSE);
    }

    public boolean isNumber() {
        return (type == NUMBER);
    }

    public boolean isString() {
        return (type == STRING);
    }

    public boolean isNone() {
        return (type == NONE);
    }

    public boolean isIntro() {
        return (type == INTRO);
    }

    public boolean isComment() {
        return (type == COMMENT);
    }



    public String toString() {
        String s = types[type] + &quot; &quot; ;
        if (type == OPEN ||
                type == STRING ||
                type == INTRO ||
                type == COMMENT ||
                type == CLOSE ||
                type == OPENCLOSE) {
            s += svalue;

            if (type == OPEN || type==OPENCLOSE) {
                if (natt &gt; 0) {
                    for (int i = 0; i &lt; natt; i++) {
                        s += &quot;\n    &quot; + attNV[2*i] + &quot;=&quot; + attNV[2*i+1];
                    }
                }
            }
        } else if (type == NUMBER) {
            s += &quot; &quot; + dvalue;
        }
        return s;
    }

    public void setType(int itype) {
        type = itype;
    }


    public void setStringValue(String s) {
        svalue = s;
    }


    public void setDValue(double d) {
        dvalue = d;
    }


    public void setAttributes(String[] sa) {
        attNV = sa;
        natt = sa.length / 2;
    }



    public boolean hasAttribute(String sat) {
        boolean bret = false;
        for (int i = 0; i &lt; natt; i++) {
            if (attNV[2*i].equals(sat)) bret = true;
        }
        return bret;
    }

    public Attribute[] getAttributes() {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/numeric/math/Matrix.java</td><td><a href="./xref/org/catacomb/numeric/math/Matrix.html#230">230</a></td></tr><tr class="a"><td>org/textensor/stochdiff/numeric/math/Matrix.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/math/Matrix.html#325">325</a></td></tr><tr class="b"><td colspan='2'><div><pre>    }


    public double[] rvprod(double[] v) {
        double[] r = new double[n];
        if (v.length != n) {
            Sp(&quot;incompatible dimensions in lvprod&quot;);
        } else {
            for (int i = 0; i &lt; n; i++) {
                for (int j = 0; j &lt; n; j++) {
                    r[i] += a[i][j] * v[j];
                }
            }
        }
        return r;
    }



    public void multiplyInto(double[] v) {
        for (int i = 0; i &lt; n; i++) {
            ws[i] = 0.;
            for (int j = 0; j &lt; n; j++) {
                ws[i] += a[i][j] * v[j];
            }
        }
        for (int i = 0; i &lt; n; i++) {
            v[i] = ws[i];
        }
    }


    public void rect2rvprod(double[] v, double[] r1, double[] r2) {
        for (int i = 0; i &lt; n1; i++) {
            ws[i] = 0.0;
            for (int j = 0; j &lt; n1; j++) {
                ws[i] += a[i][j] * v[j];
            }
        }

        for (int i = 0; i &lt; n2 - n1; i++) {
            r2[i] = 0.0;
            for (int j = 0; j &lt; n1; j++) {
                r2[i] += a[i + n1][j] * v[j];
            }
        }
        for (int i = 0; i &lt; n1; i++) {
            r1[i] = ws[i];
        }


    }



    public double rvprodOneElt(double[] v, int elt) {
        double r = 0.0;
        for (int j = 0; j &lt; n; j++) {
            r += a[elt][j] * v[j];
        }
        return r;
    }


    public Matrix transpose() {
        Matrix m = copy();</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/interlish/reflect/ReflectionConstructor.java</td><td><a href="./xref/org/catacomb/interlish/reflect/ReflectionConstructor.html#142">142</a></td></tr><tr class="a"><td>org/textensor/xml/ReflectionInstantiator.java</td><td><a href="./xref/org/textensor/xml/ReflectionInstantiator.html#114">114</a></td></tr><tr class="b"><td colspan='2'><div><pre>            for (int i = 0; i &lt; npkg; i++) {
                E.info(&quot;tried package &quot; + pkgs[i]);
            }

            if (scl.endsWith(&quot;ing&quot;)) {
                (new Exception()).printStackTrace();
            }


        } else {
            int imod = c.getModifiers();
            if (Modifier.isAbstract(imod)) {
                E.error(&quot;cant instantiatie &quot; + c + &quot;:  it is an abstract class&quot;);
            } else {

                try {
                    oret = c.newInstance();
                } catch (Exception e) {
                    E.error(&quot; &quot; + e + &quot; instantiating &quot; + c);
                    e.printStackTrace();
                }
            }
        }

        if (oret != null) {
            checkAddPackage(oret);
        }

        return oret;
    }



    public Object getField(Object ob, String fnm) {
        Object ret = null;

        boolean hasField = false;

        // EFF improve
        Field[] flds = ob.getClass().getFields();
        for (int i = 0; i &lt; flds.length; i++) {
            if (flds[i].getName().equals(fnm)) {
                hasField = true;
                break;
            }
        }

        if (hasField) {
            try {
                Field f = ob.getClass().getField(fnm);

                Class fcl = f.getType();

                if (fcl.equals(String[].class)) {
                    ret = new String[0];

                } else if (fcl.isArray()) {
                    ret = new ArrayList(); // ADHOC - wrap ArrayList?
                } else {
                    ret = f.get(ob);
                }

                if (ret == null) {
                    Class&lt;?&gt; cl = f.getType();
                    ret = cl.newInstance();
                }

            } catch (Exception e) {
                E.error(&quot;cant get field &quot; + fnm + &quot; on &quot; + ob + &quot; &quot; + &quot;excception= &quot; + e);
            }
        }


        /*
         * if (!hasField &amp;&amp; ob instanceof FieldValueProvider) { ret =
         * ((FieldValueProvider)ob).getFieldValue(fnm); if (ret != null) {
         * hasField = true; } }
         */


        if (!hasField) {
            if (ob instanceof ArrayList) {
                // we're OK - the object will just be added;

            } else {

                // System.out.println(&quot;error - cant get field &quot; + fnm + &quot; on &quot; +
                // ob);
                /*
                 * Field[] af = ob.getClass().getFields(); for (int i = 0; i &lt;
                 * af.length; i++) { System.out.println(&quot;fld &quot; + i + &quot; &quot; + af[i]); }
                 */
            }
        }
        return ret;
    }



    public Object getChildObject(Object parent, String name, Attribute[] attain) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/util/FileUtil.java</td><td><a href="./xref/org/catacomb/util/FileUtil.html#12">12</a></td></tr><tr class="a"><td>org/textensor/util/FileUtil.java</td><td><a href="./xref/org/textensor/util/FileUtil.html#13">13</a></td></tr><tr class="b"><td colspan='2'><div><pre>public abstract class FileUtil {



    public static byte[] readHeader(File f, int n) {
        byte[] ret = null;
        try {
            FileInputStream ins = new FileInputStream(f);
            ret = new byte[n];
            int nread = ins.read(ret);
            if (nread != n) {
                E.error(&quot;readNBytes wanted &quot; + n + &quot; but got &quot; + nread);
            }
            ins.close();
        } catch (Exception ex) {
            E.error(&quot;readNBytes problem &quot; + ex);
        }
        return ret;
    }



    public static byte[] readBytes(File f) {
        byte[] ret = null;
        try {
            FileInputStream fis = new FileInputStream(f);
            BufferedInputStream bis = new BufferedInputStream(fis);
            ByteArrayOutputStream baos = new ByteArrayOutputStream();

            byte[] bb = new byte[4096];
            int nread = bis.read(bb);
            while (nread &gt; 0) {
                baos.write(bb, 0, nread);
                nread = bis.read(bb);
            }
            ret = baos.toByteArray();

        } catch (Exception ex) {
            E.error(&quot;readNBytes problem &quot; + ex);
        }
        return ret;
    }



    public static String readStringFromFile(File f) {
        String sdat = &quot;null&quot;;
        if (f != null) {
            try {
                boolean dogz = (f.getName().endsWith(&quot;.gz&quot;));
                InputStream ins = new FileInputStream(f);
                if (dogz) {
                    ins = new GZIPInputStream(ins);
                }
                InputStreamReader insr = new InputStreamReader(ins);
                BufferedReader fr = new BufferedReader(insr);

                StringBuffer sb = new StringBuffer();
                while (fr.ready()) {
                    sb.append(fr.readLine());
                    sb.append(&quot;\n&quot;);
                }
                fr.close();
                sdat = sb.toString();

            } catch (IOException ex) {
                E.error(&quot;Cant read file &quot; + f);</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/textensor/stochdiff/numeric/morph/CuboidVolumeElement.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/morph/CuboidVolumeElement.html#13">13</a></td></tr><tr class="a"><td>org/textensor/stochdiff/numeric/morph/CurvedVolumeElement.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/morph/CurvedVolumeElement.html#26">26</a></td></tr><tr class="b"><td colspan='2'><div><pre>    public void setAlongArea(double d) {
        alongArea = d;

    }

    public double getAlongArea() {
        return alongArea;
    }

    public void setSideArea(double d) {
        sideArea = d;
    }
    public double getSideArea() {
        return sideArea;
    }


    public void setTopArea(double d) {
        topArea = d;
    }

    public double getTopArea() {
        return topArea;
    }



    public String getAsText() {
        StringBuffer sb = new StringBuffer();
        // export boundary if have it, ow just the center point;
        if (boundary != null) {
            for (Position p : boundary) {
                sb.append(String.format(&quot; (%.5g %.5g %.5g) &quot;, p.getX(), p.getY(), p.getZ()));
            }
        } else {
            sb.append(String.format(&quot; (%.5g %.5g %.5g) &quot;, cx, cy, cz));

        }
        return sb.toString();
    }

    @SuppressWarnings(&quot;boxing&quot;)
    public String getAsPlainText() {
        StringBuffer sb = new StringBuffer();
        // export boundary if have it, ow just the center point;
        if (boundary != null) {
            for (Position p : boundary) {
                sb.append(String.format(&quot; %.5g %.5g %.5g&quot;, p.getX(), p.getY(), p.getZ()));
            }
        } else {
            sb.append(String.format(&quot; %.5g %.5g %.5g&quot;, cx, cy, cz));
        }
        sb.append(String.format(&quot; %.5g %.5g&quot;, volume, deltaZ));
        return sb.toString();
    }


    @SuppressWarnings(&quot;boxing&quot;)
    public String getHeadings() {
        StringBuffer sb = new StringBuffer();
        // export boundary if have it, ow just the center point;
        if (boundary != null) {
            for (int i = 0; i &lt; boundary.length; i++) {
                sb.append(&quot; x&quot; + i + &quot; y&quot; + i + &quot; z&quot; + i);

            }
        } else {
            sb.append(&quot; cx cy cz&quot;);

        }
        sb.append(&quot; volume deltaZ&quot;);
        return sb.toString();
    }</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/serial/xml/XMLTokenizer.java</td><td><a href="./xref/org/catacomb/serial/xml/XMLTokenizer.html#25">25</a></td></tr><tr class="a"><td>org/textensor/xml/XMLTokenizer.java</td><td><a href="./xref/org/textensor/xml/XMLTokenizer.html#27">27</a></td></tr><tr class="b"><td colspan='2'><div><pre>    static {
        String sord = &quot;\&quot;=&lt;&gt;?!-&quot;;
        iq = sord.charAt(0);
        ieq = sord.charAt(1);
        iabo = sord.charAt(2);
        iabc = sord.charAt(3);
        iqm = sord.charAt(4);
        iexc = sord.charAt(5);
        ims = sord.charAt(6);
    }



    HashMap&lt;String, String&gt; cdataHM;

    String srcString;

    public XMLTokenizer(String s) {
        // EFF remove this - just for debugging;
        srcString = extractCDATAs(s);


        streamTokenizer = new StreamTokenizer(new StringReader(srcString));
        initializeStreamTokenizer(streamTokenizer);
    }


    private String extractCDATAs(String src) {
        StringBuffer sret = new StringBuffer();
        int icur = 0;
        int iscd = src.indexOf(&quot;&lt;![CDATA[&quot;);

        while (iscd &gt;= icur) {
            sret.append(src.substring(icur, iscd));
            int iecd = src.indexOf(&quot;]]&gt;&quot;, iscd + 9);
            if (iecd &gt;= 0) {
                String cdata = src.substring(iscd + 9, iecd);
                if (cdataHM == null) {
                    cdataHM = new HashMap&lt;String, String&gt;();
                }
                String rpl = &quot;xyz&quot; + cdataHM.size();
                cdataHM.put(rpl, cdata);
                sret.append(rpl);

            } else {
                iecd = iscd + 6;
                E.error(&quot;no closure of cdata beginning character &quot; + iscd + &quot;? &quot;);
            }
            icur = iecd + 3;
            iscd = src.indexOf(&quot;&lt;![CDATA[&quot;, icur);
        }
        if (icur &lt; src.length()) {
            sret.append(src.substring(icur, src.length()));
        }
        return sret.toString();
    }


    private void setStringValue(XMLToken xmlt, String svin) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/serial/xml/XMLReader.java</td><td><a href="./xref/org/catacomb/serial/xml/XMLReader.html#112">112</a></td></tr><tr class="a"><td>org/textensor/xml/XMLReader.java</td><td><a href="./xref/org/textensor/xml/XMLReader.html#105">105</a></td></tr><tr class="b"><td colspan='2'><div><pre>        }
        return xmlt;
    }



    public void readFieldIntoParent(XMLTokenizer tkz, Object parent, XMLToken start) {



        // read the child object that is known to the parent as item.name
        // if the parent is a vector, the object is added as a new element;
        // if the parent is a string, the xml is just apended;
        // otherwise the field is set.


        if (!start.isOpen()) {
            nerror++;
            err(&quot;ERROR - read object start item was not an open tag &quot; + start);
            return;
        }


        Object child = null;

        if (parent instanceof String || parent instanceof StringBuffer) {
            child = new StringBuffer();
            ((StringBuffer)child).append(start.getOpenTagString());

        } else {

            // attributes may contain the class - the instantiator processes
            // all the attributes here
            Attribute[] atts = start.getAttributes();
            child = instantiator.getChildObject(parent, start.getName(), atts);
            if (child != null) {
                instantiator.applyAttributes(child, atts);
            }


            if (child == null) {
                child = new ArrayList();

            } else if (child instanceof String) {
                // in this case, set its length to 0. Subseqnet parts of the
                // string will get appended to the current value, so want to
                // keep track of the fact that it is a string, without keeping
                // the default that may have come from above;
                child = new StringBuffer();


            } else if (child.getClass().isArray()) {
                // make it an array list for the time being, then
                // give the lsit to teh instantiator to make into theright sort of
                // array;
                child = new ArrayList();
            }


            if (start.isClose()) {
                // the tag was both an open and a close tag, so now that we've
                // processed the attributes, we're done;


            } else {
                // read on and fill in fields until we get a closing tag which
                // matches the start tag
                // the fields will be inserted in target;

                XMLToken next = readToken(tkz);

                while (true) {
                    if (next.isNone()) {
                        // should mean EOF, but could also be an error
                        // return whatever;
                        break;


                    } else if (next.isOpen()) {
                        // open tags could mean anything - elementary field, array,
                        // or object, but in any case, pass them back to this method;
                        readFieldIntoParent(tkz, child, next);


                    } else if (next.isClose()) {
                        if (next.closes(start)) {
                            // fine - close item

                            if (parent instanceof String || parent instanceof StringBuffer) {
                                ((StringBuffer)child).append(next.getCloseTagString());
                            }


                        } else {
                            nerror++;
                            E.shortError(&quot; non-matching close item \n&quot; + &quot;start Item was: \n&quot;
                                         + start.toString() + &quot;\n&quot; + &quot;but close was: \n&quot; + next.toString() + &quot;\n&quot; +</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/druid/gui/edit/DruCheckboxListPanel.java</td><td><a href="./xref/org/catacomb/druid/gui/edit/DruCheckboxListPanel.html#32">32</a></td></tr><tr class="a"><td>org/catacomb/druid/gui/edit/DruToggleListPanel.java</td><td><a href="./xref/org/catacomb/druid/gui/edit/DruToggleListPanel.html#27">27</a></td></tr><tr class="b"><td colspan='2'><div><pre>    public DruCheckboxListPanel(int nr) {
        super();
        nrow = nr;

        dList = new DCheckboxList();

        addSingleDComponent(dList);


        dList.setItems(new Object[0]);

        dList.setLabelActor(this);
    }



    public void setItems(String[] sa) {
        dList.setItems(sa);
        if (listWatcher != null) {
            listWatcher.listChanged(this);
        }
    }


    public void setItems(ArrayList&lt;? extends Object&gt; obal) {
        Object[] obar = obal.toArray(new Object[obal.size()]);
        dList.setItems(obar);

        if (listWatcher != null) {
            listWatcher.listChanged(this);
        }
    }


    public void setSelected(String[] sa) {
        dList.setSelected(sa);
    }

    public void setSelected(int[] ia) {
        dList.setSelected(ia);
    }

    public void selectAll() {
        dList.selectAll();
    }


    public ArrayList&lt;Object&gt; getAllItems() {
        return dList.getAllItems();
    }

    public ArrayList&lt;Object&gt; getSelectedItems() {
        return dList.getCheckedItems();
    }


    public void setBg(Color c) {
        dList.setBackground(c);
        super.setBg(c);
    }



    public void updateDisplay() {
        // EFF
        dList.repaint();
    }


    public Object getSelectedItem() {
        return dList.getSelectedValue();
    }


    public String getSelectedName() {
        return &quot;&quot; + getSelectedItem();
    }


    public void labelAction(String s, boolean b) {
        if (s.equals(&quot;selected&quot;)) {
            valueChange(getSelectedName());

        } else if (s.equals(&quot;toggle&quot;)) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.html#850">850</a></td></tr><tr class="a"><td>org/textensor/stochdiff/numeric/tmp/Tmp1A.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/tmp/Tmp1A.html#770">770</a></td></tr><tr class="b"><td colspan='2'><div><pre>                System.out.println(&quot;in parallelAndSharedDiffusionStep 1st else: ngo is NEGATIVE. Exiting...&quot;);
                System.exit(0);
            }

        } else {
            if (useBinomial()) {
                // WK 7 2 2008: if n*p &lt; 10, then use poission to get ngo;
                // otherwise, use gaussian.
                // RO 7 3 2008: changed from 10 to 20 because observed negative
                // ngo
                if (np0 * pSharedOut[iel][k] &lt; NP) {
                    // RO
                    ngo = StepGenerator.gaussianStep(np0, pSharedOut[iel][k], random.gaussian(), random.random(),
                                                     random.poisson(np0 * pSharedOut[iel][k]), NP);

                    if (ngo &lt; 0) {
                        ngo = 0;

                        System.out.println(&quot;in parallelAndSharedDiffusionStep, if (np0*pSharedOut[iel][k] &lt; &quot; + NP
                                           + &quot;): ngo is NEGATIVE.&quot;);
                        System.out.println(&quot;ngo: &quot; + ngo + &quot; np0: &quot; + np0 + &quot; pSharedOut[iel][k]: &quot;
                                           + pSharedOut[iel][k]);
                    }

                } else {
                    ngo = StepGenerator.gaussianStep(np0, pSharedOut[iel][k], random.gaussian(), random.random());
                    if (ngo &lt; 0) {
                        ngo = 0;

                        System.out.println(&quot;in parallelAndSharedDiffusionStep, if (np0*pSharedOut[iel][k] &gt;= &quot; + NP
                                           + &quot;): ngo is NEGATIVE.&quot;);
                        System.out.println(&quot;ngo: &quot; + ngo + &quot; np0: &quot; + np0 + &quot; pSharedOut[iel][k]: &quot;
                                           + pSharedOut[iel][k]);
                    }
                    // WK
                }
            } else {
                ngo = StepGenerator.poissonStep(np0, pSharedOut[iel][k], random.gaussian(), random.random());
                if (ngo &lt; 0) {
                    ngo = 0;

                    System.out.println(&quot;in parallelAndSharedDiffusionStep, if not using Binomial: ngo is NEGATIVE.&quot;);
                    System.out.println(&quot;ngo: &quot; + ngo + &quot; np0: &quot; + np0 + &quot; pSharedOut[iel][k]: &quot; + pSharedOut[iel][k]);
                }
            }
        }

        // WK 7 2 2008: if ngo is negative, exit.
        if (ngo &lt; 0) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/numeric/math/Matrix.java</td><td><a href="./xref/org/catacomb/numeric/math/Matrix.html#429">429</a></td></tr><tr class="a"><td>org/textensor/stochdiff/numeric/math/Matrix.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/math/Matrix.html#539">539</a></td></tr><tr class="b"><td colspan='2'><div><pre>    }



    public double[] lubksb(double[] b) {
        int ip;
        int ii = -1;
        double sum;

        for (int i = 0; i &lt; n; i++) {
            ip = perm[i];
            sum = b[ip];
            b[ip] = b[i];
            if (ii &gt;= 0) {
                for (int j = ii; j &lt; i; j++) {
                    sum -= a[i][j] * b[j];
                }
            } else if (sum != 0.0) {
                ii = i;
            }
            b[i] = sum;
        }

        for (int i = n - 1; i &gt;= 0; i--) {
            sum = b[i];
            for (int j = i + 1; j &lt; n; j++) {
                sum -= a[i][j] * b[j];
            }
            b[i] = sum / a[i][i];
        }
        return b;
    }


    public void round(double d) {
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (Math.abs(a[i][j]) &lt; d) {
                    a[i][j] = 0.0;
                }
            }
        }
    }



    public void round() {
        round(1.0e-15);
    }



    public void print() {

        String[] sa = new String[n];</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/numeric/math/Random.java</td><td><a href="./xref/org/catacomb/numeric/math/Random.html#22">22</a></td></tr><tr class="a"><td>org/textensor/stochdiff/numeric/math/NRRandom.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/math/NRRandom.html#24">24</a></td></tr><tr class="b"><td colspan='2'><div><pre>    public static double random() {
        jran = (jran * ia + ic) % im;
        double ran = (1. * jran) / im;
        return ran;
    }

    public static int getSeed() {
        return jran;
    }


    public static void setSeed(int jr) {
        jran = jr;
    }



    public static double nextRandom() {
        return random();
    }


    public static double uniformRV() {
        return random();
    }




    public static int weightedSample(double[] rw) {
        int n = rw.length;
        double a = random();
        int inew = 0;
        while ((a -= rw[inew]) &gt; 0 &amp;&amp; inew &lt; n-1) {
            inew++;
        }
        return inew;
    }



    public  static double gaussianRV() {
        return grv();
    }


    public static double  grv() {
        double r, ran1, ran2, fac, g1;
        r = -1;
        ran1 = 0.0;
        ran2 = 0.0;
        while (r &lt;= 0.0 || r &gt;= 1.0) {
            jran = (jran * ia + ic) % im;
            ran1 = (2. * jran) / im - 1;

            jran = (jran * ia + ic) % im;
            ran2 = (2. * jran) / im - 1;

            r = ran1 * ran1 + ran2 * ran2;
        }
        fac = Math.sqrt(-2. * Math.log(r) / r);
        g1 = ran1 * fac;
        //      g2 = ran2 * fac;
        return g1;
    }</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/druid/swing/DFloatSlider.java</td><td><a href="./xref/org/catacomb/druid/swing/DFloatSlider.html#288">288</a></td></tr><tr class="a"><td>org/catacomb/druid/swing/DSlider.java</td><td><a href="./xref/org/catacomb/druid/swing/DSlider.html#241">241</a></td></tr><tr class="b"><td colspan='2'><div><pre>    }


    private void drawUpButton(Graphics g, int icx, int icy, int hw, int hh) {
        Color c = getBackground();

        g.setColor(c.darker());
        g.drawLine(icx - hw - 1, icy + hh + 1, icx + hw + 1, icy + hh + 1);
        g.drawLine(icx - hw, icy + hh, icx + hw, icy + hh);

        g.drawLine(icx + hw + 1, icy - hh - 1, icx + hw + 1, icy + hh + 1);
        g.drawLine(icx + hw, icy - hh, icx + hw, icy + hh);


        g.setColor(c.brighter());
        g.drawLine(icx - hw - 1, icy - hh - 1, icx + hw + 1, icy - hh - 1);
        g.drawLine(icx - hw, icy - hh, icx + hw, icy - hh);

        g.drawLine(icx - hw - 1, icy - hh - 1, icx - hw - 1, icy + hh + 1);
        g.drawLine(icx - hw, icy - hh, icx - hw, icy + hh);



    }


    public void nudgeLeft() {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/interlish/reflect/Narrower.java</td><td><a href="./xref/org/catacomb/interlish/reflect/Narrower.html#58">58</a></td></tr><tr class="a"><td>org/textensor/xml/Narrower.java</td><td><a href="./xref/org/textensor/xml/Narrower.html#53">53</a></td></tr><tr class="b"><td colspan='2'><div><pre>            ret = new SColor((String)arg);

        }

        return ret;

    }



    public static void err(String s) {
        E.error(s);
    }



    public static double parseDouble(String s) {
        double dret = 0.;
        int ii = s.indexOf(&quot;e&quot;);
        if (ii &lt; 0)
            ii = s.indexOf(&quot;E&quot;);
        if (ii &lt; 0) {
            dret = (new Double(s)).doubleValue();

        } else {
            String sa = s.substring(0, ii - 1);
            String sp = s.substring(ii + 1, s.length());
            int ppp = Integer.parseInt(sp);
            dret = (new Double(sa)).doubleValue();
            dret *= Math.pow(10., ppp);

        }
        return dret;
    }


    public static String[] makeStringArray(Object ob) {
        String[] sret = null;
        if (ob instanceof String[]) {
            sret = (String[])ob;

        } else if (ob instanceof String) {
            sret = new String[1];
            sret[0] = (String)ob;

        } else if (ob instanceof ArrayList&lt;?&gt;) {
            ArrayList&lt;? extends Object&gt; v = (ArrayList&lt;? extends Object&gt;)ob;</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/numeric/math/Matrix.java</td><td><a href="./xref/org/catacomb/numeric/math/Matrix.html#601">601</a></td></tr><tr class="a"><td>org/textensor/stochdiff/numeric/math/Matrix.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/math/Matrix.html#715">715</a></td></tr><tr class="b"><td colspan='2'><div><pre>        for (int i = 0; i &lt; n2; i++) {
            c[i] = a[i][ic];
        }
        return c;
    }



    public int randomIndexFromOffsetColumn(int c, int off) {
        double r = Math.random();
        int ir;
        for (ir = off; (r -= a[ir][c]) &gt; 0; ir++) {
            ;
        }
        return ir;
    }



    public double[] ev1vec(int np) {
        // find the vector with eigenvalue 1., assuming it exists... or
        // equivalently the null space of M-I, which is assumed to have
        // dimension 1;
        // actually just take a large power of the Matrix ***

        Matrix q = copy();
        for (int i = 0; i &lt; np; i++) {
            q = q.prod(q);
        }

        double[] s = new double[n];
        for (int i = 0; i &lt; n; i++) {
            s[i] = 1. / n;
        }
        s = q.rvprod(s);

        double t = 0.0;
        for (int i = 0; i &lt; n; i++) {
            t += s[i];
        }
        for (int i = 0; i &lt; n; i++) {
            s[i] /= t;
        }
        if (Math.abs(t - 1.) &gt; 0.01) {
            Sp(&quot;WARNING - ev1vec in class Matrix chnaged size &quot; + t);
        }
        return s;
    }</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/druid/swing/DFloatSlider.java</td><td><a href="./xref/org/catacomb/druid/swing/DFloatSlider.html#384">384</a></td></tr><tr class="a"><td>org/catacomb/druid/swing/DSlider.java</td><td><a href="./xref/org/catacomb/druid/swing/DSlider.html#326">326</a></td></tr><tr class="b"><td colspan='2'><div><pre>            export();
            repaint();
        }
    }



    // map listeners to rfsXXX methods;

    public void mouseDragged(MouseEvent e) {
        int x = e.getX();
        int y = e.getY();
        rsfMouseDrag(x, y);
    }


    public void mouseMoved(MouseEvent e) {
    }


    public void mousePressed(MouseEvent e) {
        int x = e.getX();
        int y = e.getY();
        long when = e.getWhen();
        int modif = e.getModifiers();
        int button = 0;
        if (modif == InputEvent.BUTTON1_MASK) {
            button = 1;
        } else if (modif == InputEvent.BUTTON2_MASK) {
            button = 2;
        } else if (modif == InputEvent.BUTTON3_MASK) {
            button = 3;
        }
        rsfMouseDown(x, y, when, button);
    }



    public void mouseReleased(MouseEvent e) {
        int x = e.getX();
        int y = e.getY();
        rsfMouseUp(x, y);
    }



    public void mouseEntered(MouseEvent e) {
        requestFocus();
    }


    public void mouseExited(MouseEvent e) {
    }


    public void mouseClicked(MouseEvent e) {
        requestFocus();
    }


    public double getTotalRange() {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/interlish/reflect/Narrower.java</td><td><a href="./xref/org/catacomb/interlish/reflect/Narrower.html#24">24</a></td></tr><tr class="a"><td>org/textensor/xml/Narrower.java</td><td><a href="./xref/org/textensor/xml/Narrower.html#22">22</a></td></tr><tr class="b"><td colspan='2'><div><pre>        if (fcln.endsWith(&quot;int&quot;)) {
            ret = new Integer(makeInt(arg));

        } else if (fcln.endsWith(&quot;boolean&quot;)) {
            ret = new Boolean(makeBoolean(arg));

        } else if (fcln.endsWith(&quot;double&quot;)) {
            ret = new Double(makeDouble(arg));

        } else if (fcln.startsWith(&quot;java.lang.String&quot;)) {
            ret = arg;

        } else if (fcln.startsWith(&quot;[D&quot;)) {
            ret = makeDoubleArray(arg);

        } else if (fcln.startsWith(&quot;[I&quot;)) {
            ret = makeIntArray(arg);

        } else if (fcln.startsWith(&quot;[Ljava.lang.String&quot;)) {
            ret = makeStringArray(arg);

        } else if (fcln.startsWith(&quot;[Z&quot;)) {
            ret = makeBooleanArray(arg);

        } else if (fcln.startsWith(&quot;[[D&quot;)) {
            ret = makeDDArray(arg);

        } else if (fcln.startsWith(&quot;[[I&quot;)) {
            ret = makeIIArray(arg);

        } else if (fcln.endsWith(&quot;ArrayList&quot;)) {
            ret = makeArrayList(arg);

        } else if (fcln.endsWith(&quot;SColor&quot;)) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/druid/blocks/ScrollingCheckboxList.java</td><td><a href="./xref/org/catacomb/druid/blocks/ScrollingCheckboxList.html#61">61</a></td></tr><tr class="a"><td>org/catacomb/druid/blocks/ScrollingList.java</td><td><a href="./xref/org/catacomb/druid/blocks/ScrollingList.html#59">59</a></td></tr><tr class="b"><td colspan='2'><div><pre>        if (renderer != null) {

            // TODO move renderer defs to XML;

            if (renderer.equals(&quot;quantity&quot;)) {
                drup.setCellRenderer(new DruListQuantityRenderer());

            } else if (renderer.equals(&quot;progress&quot;)) {
                drup.setCellRenderer(new DruListProgressRenderer());

            } else if (renderer.equals(&quot;color&quot;)) {
                drup.setCellRenderer(new DruListColorRenderer());

            } else {
                E.error(&quot;unrecognized renderer &quot; + renderer);
            }
        }

        if (multiple) {
            drup.setMultiple();
        }

        if (clickAction != null) {
            if (clickAction.equals(&quot;toggle&quot;)) {
                drup.setToggleAction();
            } else {
                E.warning(&quot;unrecognized action &quot; + clickAction);
            }
        }


        if (order != null) {
            if (order.equals(&quot;reverse&quot;)) {
                drup.setOrder(DruListPanel.REVERSE_ORDER);

            } else {
                E.warning(&quot;unknown list order &quot; + order + &quot; (only know reverse)&quot;);
            }
        }


        if (clickAreas != null) {
            for (ListClickArea lca : clickAreas) {
                drup.addClickAction(lca.makeActor());
            }
        }

    }

}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/druid/swing/DChoice.java</td><td><a href="./xref/org/catacomb/druid/swing/DChoice.html#306">306</a></td></tr><tr class="a"><td>org/catacomb/druid/swing/DValueHistory.java</td><td><a href="./xref/org/catacomb/druid/swing/DValueHistory.html#138">138</a></td></tr><tr class="b"><td colspan='2'><div><pre>    }



    public void setLabelActor(LabelActor bl) {
        lact = bl;
    }



    public void deliverAction(String s, boolean b) {
        if (lact != null) {
            lact.labelAction(s, b);
        }
    }



    // icon methods to draw the button;
    public void paintIcon(Component c, Graphics g, int x, int y) {
        JComponent component = (JComponent)c;
        int iconWidth = getIconWidth();

        g.translate(x, y);

        g.setColor(component.isEnabled() ? Color.gray : Color.blue);

        g.drawLine(2, 0, iconWidth - 1, 0);
        g.drawLine(3, 1, 1 + (iconWidth - 3), 1);
        g.drawLine(5, 3, 3 + (iconWidth - 7), 3);
        g.drawLine(6, 4, 4 + (iconWidth - 9), 4);

        g.translate(-x, -y);
    }


    public int getIconWidth() {
        return 12;
    }


    public int getIconHeight() {
        return 5;
    }


    public void setUpdatable(Updatable u) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/textensor/vis/SceneGraphBuilder.java</td><td><a href="./xref/org/textensor/vis/SceneGraphBuilder.html#257">257</a></td></tr><tr class="a"><td>org/textensor/vis/SceneGraphBuilder.java</td><td><a href="./xref/org/textensor/vis/SceneGraphBuilder.html#341">341</a></td></tr><tr class="b"><td colspan='2'><div><pre>        int nvert = 2 * nside * nstrip;

        int[] svc = new int[nstrip];
        for (int i = 0; i &lt; nstrip; i++) {
            svc[i] = 2 * nside;
        }

        float[] datv = new float[3 * nvert];
        float[] datn = new float[3 * nvert];


        double dtheta = 2. * Math.PI / (nside-1);
        double[][] csas = new double[nside][2];
        double[][] csbs = new double[nside][2];
        for (int i = 0; i &lt;  nside; i++) {
            double tha = i * dtheta;
            double thb = (i + 0.5) * dtheta;
            csas[i][0] = Math.cos(tha);
            csas[i][1] = Math.sin(tha);

            csbs[i][0] = Math.cos(thb);
            csbs[i][1] = Math.sin(thb);
        }</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/dataview/FrameController.java</td><td><a href="./xref/org/catacomb/dataview/FrameController.html#191">191</a></td></tr><tr class="a"><td>org/catacomb/dataview/gui/FramePlayerController.java</td><td><a href="./xref/org/catacomb/dataview/gui/FramePlayerController.html#147">147</a></td></tr><tr class="b"><td colspan='2'><div><pre>            framePlayer.start();
        }
    }


    public void stop() {
        if (framePlayer != null) {
            framePlayer.stop();
        }
    }




    public void faster() {
        speed *= 1.3;
    }

    public void slower() {
        speed /= 1.3;
    }


    public boolean canAdvance() {
        return (indexes != null &amp;&amp; shownFrame &lt; indexes.length-1);
    }


    public void advance() {
        showFrame(shownFrame + 1);
    }


    public double getSpeed() {
        return speed;
    }



    public void record() {
        E.missing();
        /*
        File f = FileChooser.getWriteFile();
        if (f != null) {
        makeAnimatedGif(f);
            }
            */

    }


    public void miniRecord() {
        E.missing();
        /*
        File f = FileChooser.getWriteFile();
        if (f != null) {
        makeMiniAnimatedGif(f, 160, 100);
            }
            */
    }



    public void makeMovie(File f) {
        makeAnimatedGif(f);
    }

    public void makeThumbnailMovie(File f) {
        makeMiniAnimatedGif(f, 160, 160);
    }



    public void makeAnimatedGif(File f) {
        stop();
        rewind();


        AnimatedGifEncoder enc = new AnimatedGifEncoder();

        enc.start(f);
        enc.setDelay(160);   // ms

        int ifr = 0;
        E.info(&quot;animated gif - frame &quot; + ifr);</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/serial/xml/XMLToken.java</td><td><a href="./xref/org/catacomb/serial/xml/XMLToken.html#140">140</a></td></tr><tr class="a"><td>org/textensor/xml/XMLToken.java</td><td><a href="./xref/org/textensor/xml/XMLToken.html#137">137</a></td></tr><tr class="b"><td colspan='2'><div><pre>            nvpa[i] = new NamedString(attNV[2*i], attNV[2*i+1]);
        }
        return nvpa;
    }



    public String getAttribute(String sat) {
        String sret = null;
        for (int i = 0; i &lt; natt; i++) {
            if (attNV[2*i].equals(sat)) sret = attNV[2*i+1];
        }
        return sret;
    }


    public String getName() {
        return svalue;
    }

    public String getOpenTagString() {
        return (&quot;&lt;&quot; + svalue + &quot;&gt;&quot;);
    }

    public String getCloseTagString() {
        return (&quot;&lt;/&quot; + svalue + &quot;&gt;&quot;);
    }



    public boolean closes(XMLToken start) {
        return (svalue.equals(start.getName()) &amp;&amp; isClose());
    }


    public int getNumAttributes() {
        return natt;
    }


    public String getAttributeName(int i) {
        return attNV[2*i];
    }

    public String getAttributeValue(int i) {
        return attNV[2*i+1];
    }

}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/druid/swing/DFloatSlider.java</td><td><a href="./xref/org/catacomb/druid/swing/DFloatSlider.html#236">236</a></td></tr><tr class="a"><td>org/catacomb/druid/swing/DSlider.java</td><td><a href="./xref/org/catacomb/druid/swing/DSlider.html#172">172</a></td></tr><tr class="b"><td colspan='2'><div><pre>            g.drawString(label, 40, 20);
        }
    }



    private void paintArrows(Graphics g) {
        int w = getWidth();
        int h = getHeight();

        Color cbg = bgColor;
        Color cbr = cbg.brighter();
        Color cdk = cbg.darker();

        int hh = h / 2;
        g.setColor(cbr);
        g.drawLine(4, hh, 15, 4);

        g.drawLine(w - 15, h - 4, w - 15, 4);

        // g.drawLine(w-15, 4, w-10, hh);


        g.setColor(cdk);
        g.drawLine(15, 4, 15, h - 4);
        // g.drawLine(15, h-4, 10, hh);


        g.drawLine(4, hh, 15, h - 4);

        g.drawLine(w - 15, h - 4, w - 4, hh);
        g.drawLine(w - 15, 4, w - 4, hh);

    }


    private void paintKnob(Graphics g) {
        int width = getWidth();
        int height = getHeight();
        int hh = height / 2;</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/interlish/reflect/ReflectionConstructor.java</td><td><a href="./xref/org/catacomb/interlish/reflect/ReflectionConstructor.html#321">321</a></td></tr><tr class="a"><td>org/textensor/xml/ReflectionInstantiator.java</td><td><a href="./xref/org/textensor/xml/ReflectionInstantiator.html#274">274</a></td></tr><tr class="b"><td colspan='2'><div><pre>        }


        if (child == null) {
            E.warning(&quot;ReflectionInstantiator failed to get field &quot; + name + &quot; on &quot; + parent + &quot; &quot;
                      + (parent != null ? parent.getClass().toString() : &quot;&quot;));
        }


        /*
         * POSERR did this do anything useful? if (child instanceof IDd &amp;&amp;
         * ((IDd)child).getID() == null) { // setAttributeField(child, &quot;id&quot;,
         * name); // System.out.println(&quot;autoset id to &quot; + name); }
         */
        return child;
    }



    public void applyAttributes(Object target, Attribute[] atta) {

        for (int i = 0; i &lt; atta.length; i++) {
            Attribute att = atta[i];
            setAttributeField(target, att.getName(), att.getValue());
        }
    }



    public boolean setAttributeField(Object target, String name, String arg) {
        boolean bret = false;
        if (name.equals(&quot;class&quot;) || name.equals(&quot;package&quot;) || name.equals(&quot;provides&quot;)
                || name.equals(&quot;archive-hash&quot;)) {
            // already done; ADHOC

        } else {
            bret = setField(target, name, arg);
        }

        return bret;
    }


    // ADHOC suppressing warnings
    @SuppressWarnings( { &quot;unchecked&quot; })
    public boolean setField(Object ob, String sfin, Object argin) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/interlish/reflect/ReflectionConstructor.java</td><td><a href="./xref/org/catacomb/interlish/reflect/ReflectionConstructor.html#462">462</a></td></tr><tr class="a"><td>org/textensor/xml/ReflectionInstantiator.java</td><td><a href="./xref/org/textensor/xml/ReflectionInstantiator.html#394">394</a></td></tr><tr class="b"><td colspan='2'><div><pre>                    f.set(ob, d);

                } else if (ftyp == Double.TYPE &amp;&amp; arg instanceof Double) {
                    f.set(ob, arg);

                } else if (ftyp == Boolean.TYPE &amp;&amp; arg instanceof Boolean) {
                    f.set(ob, arg);

                } else if (ftyp == Integer.TYPE &amp;&amp; arg instanceof Integer) {
                    f.set(ob, arg);

                } else if (f.getType().isArray() &amp;&amp; arg instanceof ArrayList) {
                    setArrayField(ob, f, (ArrayList)arg);

                } else {
                    Object onarg = Narrower.narrow(ftyp.getName(), arg);

                    if (onarg != null) {
                        f.set(ob, onarg);
                    } else {
                        f.set(ob, arg);
                    }
                }
                ok = true;
            } catch (Exception e) {
                ok = false;
                E.error(&quot; cant set field &quot; + sf + &quot; in &quot; + ob + &quot; from typed &quot; +</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/interlish/reflect/Narrower.java</td><td><a href="./xref/org/catacomb/interlish/reflect/Narrower.html#328">328</a></td></tr><tr class="a"><td>org/catacomb/serial/DataIO.java</td><td><a href="./xref/org/catacomb/serial/DataIO.html#12">12</a></td></tr><tr class="b"><td colspan='2'><div><pre>    public static double[] readDoubleArray(String sin) {
        String s = sin;
        if (s.startsWith(&quot;{&quot;)) {
            s = s.substring(1, s.indexOf(&quot;}&quot;));
        }
        s = s.trim();

        String[] sa = s.split(&quot;[ ,\t\n\r]+&quot;);

        /*
        E.info(&quot;after splitting &quot; + s);
        for (int i = 0; i &lt; sa.length; i++) {
        E.info(&quot;item &quot; + i + &quot; &quot; + sa[i]);
        }
        */

        int nt = sa.length;
        double[] value = new double[nt];

        try {
            for (int i = 0; i &lt; nt; i++) {
                value[i] = (new Double(sa[i])).doubleValue();
            }
        } catch (Exception ex) {
            E.error(&quot;float reading cant extract &quot; + nt + &quot; doubles from &quot; + s);
            for (int i = 0; i &lt; nt; i++) {
                E.info(&quot;string &quot; + i + &quot;=xxx&quot; + sa[i] + &quot;xxx&quot;);
            }
        }

        return value;
    }

}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.html#84">84</a></td></tr><tr class="a"><td>org/textensor/stochdiff/numeric/tmp/Tmp1A.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/tmp/Tmp1A.html#42">42</a></td></tr><tr class="b"><td colspan='2'><div><pre>    Column mconc;

    ReactionTable rtab;
    public VolumeGrid vgrid;

    StimulationTable stimTab;

    double dt;

    public int nel;
    int nspec;
    public String[] specieIDs;

    double[] volumes;
    double[] lnvolumes;
    double[] fdiff;
    double[] lnfdiff;

    double[] surfaceAreas;

    // WK 6 18 2007
    public boolean[] submembranes;
    public String[] regionLabels;
    public int[] eltregions;
    // WK

    int[][] neighbors;
    double[][] couplingConstants;
    double[][] lnCC;

    int[][] wkA;
    int[][] wkB;
    int[] wkReac;

    int[][] nparticle;

    int nreaction;
    public int nspecie;
    String[] speciesIDs;
    double[] diffusionConstants;

    int[][] reactantIndices;
    int[][] productIndices;

    int[][] reactantStochiometry;
    int[][] productStochiometry;

    double[] rates;
    double[] lnrates;

    int[][] stimtargets;

    double[] intlogs;
    double lndt;

    int ninjected = 0;

    InterpolatingStepGenerator interpSG;
    MersenneTwister random;
    int nwarn;
    int nngowarn = 0;         //added in v2.1.1 by BHK to keep track of a different type of warning</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/textensor/stochdiff/disc/DiscSplitter.java</td><td><a href="./xref/org/textensor/stochdiff/disc/DiscSplitter.html#96">96</a></td></tr><tr class="a"><td>org/textensor/stochdiff/disc/LineBoxer.java</td><td><a href="./xref/org/textensor/stochdiff/disc/LineBoxer.html#103">103</a></td></tr><tr class="b"><td colspan='2'><div><pre>                CurvedVolumeSlice vg = null;
                if (tpn.subAreaPeer == tp) {
                    // nothing to do for now - put line in when we
                    // do the first child of tpn
                    // E.info(&quot;skipping pt with peer &quot; + tpn);

                } else if (tp.subAreaPeer != null &amp;&amp; tp.subAreaPeer == tp.parent) {
                    // E.info(&quot;first pt after branch &quot; + tpn);
                    TreePoint par = tp.parent;
                    E.info(&quot;starting a sub-branch at &quot; + tp + &quot; - &quot; + tpn + &quot; &quot; + pGrid);

                    vg = baseGrid(tp, tpn, lbl);
                    pGrid.subPlaneConnect(tp, tpn, vg, par.partBranchOffset);
                    par.partBranchOffset += 2 * tpn.r;

                } else {
                    // normal case: make a new one or add a slice and connect
                    // it up with the centres aligned
                    if (pGrid == null) {
                        vg = baseGrid(tp, tpn, lbl);

                    } else {
                        // TODO - probably not what we want
                        // too much mumerical diffusion if boxes can have gradually changing
                        // sizes? restrict to a few dicrete multiples?
                        vg = baseGrid(tp, tpn, lbl);
                        pGrid.planeConnect(vg);
                    }
                }

                lbl = null; // only use it once
                if (vg != null) {
                    gridAL.add(vg);
                    recAdd(vg, tpn);
                } else {
                    // skipped the point that is the start of a new segment
                    // of different radius
                    recAdd(pGrid, tpn);
                }
            }
        }
    }




    public CurvedVolumeSlice baseGrid(TreePoint tpa, TreePoint tpb, String lbl) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/graph/gui/Geom.java</td><td><a href="./xref/org/catacomb/graph/gui/Geom.html#16">16</a></td></tr><tr class="a"><td>org/catacomb/graph/gui/Iconizer.java</td><td><a href="./xref/org/catacomb/graph/gui/Iconizer.html#226">226</a></td></tr><tr class="b"><td colspan='2'><div><pre>    public final static boolean pointIsInside(double[] xb, double[] yb, double x, double y) {
        int n = xb.length;
        int iwn = 0;
        for (int i = 0; i &lt; n; i++) {
            int idir = 0;
            int p = (i + 1) % n;
            if (yb[i] &lt;= y &amp;&amp; yb[p] &gt; y) {
                idir = 1;
            }

            if (yb[i] &gt; y &amp;&amp; yb[p] &lt;= y) {
                idir = -1;
            }

            if (idir != 0) {
                double f = (y - yb[i]) / (yb[p] - yb[i]);
                double xc = f * xb[p] + (1. - f) * xb[i];
                int isid = (xc &gt; x ? 1 : -1);
                iwn += isid * idir;
            }

        }
        return (iwn != 0);
    }</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/textensor/stochdiff/numeric/grid/DeterministicGridCalc.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/grid/DeterministicGridCalc.html#338">338</a></td></tr><tr class="a"><td>org/textensor/stochdiff/numeric/tmp/Tmp1A.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/tmp/Tmp1A.html#441">441</a></td></tr><tr class="b"><td colspan='2'><div><pre>        while (time &lt; endtime) {

            // RO 5 13 2010: follows template in SteppedStochaticGridCalc
            if (time &gt;= writeTime) {
                if (resultWriter != null) {
                    resultWriter.writeString(getGridConcsText(time));
                }
                writeTime += sdRun.outputInterval;
            }
            for (int i = 0; i &lt; fnmsOut.length; i++) {
                if (time &gt;= writeTimeArray[i]) {
                    resultWriter.writeToSiblingFile(getGridConcsPlainText_dumb(i, time), &quot;-&quot; +fnmsOut[i] + &quot;-conc.txt&quot;);
                    writeTimeArray[i] += Double.valueOf(dtsOut[i]);
                }
            }

            time += advance(time);

            if (time &gt; tlog) {
                E.info(&quot;time &quot; + time + &quot; dt=&quot; + dt);
                tlog += Math.max(50 * sdRun.outputInterval, 5);
            }


            if (time &gt;= stateSaveTime) {
                resultWriter.writeToSiblingFile(getStateText(), sdRun.stateSavePrefix +  &quot;-&quot; + Math.round(time) + &quot;.nrds&quot;);</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/interlish/reflect/Narrower.java</td><td><a href="./xref/org/catacomb/interlish/reflect/Narrower.html#330">330</a></td></tr><tr class="a"><td>org/catacomb/serial/DataIO.java</td><td><a href="./xref/org/catacomb/serial/DataIO.html#14">14</a></td></tr><tr class="b"><td>org/textensor/xml/Narrower.java</td><td><a href="./xref/org/textensor/xml/Narrower.html#326">326</a></td></tr><tr class="a"><td colspan='2'><div><pre>        if (s.startsWith(&quot;{&quot;)) {
            s = s.substring(1, s.indexOf(&quot;}&quot;));
        }
        s = s.trim();

        String[] sa = s.split(&quot;[ ,\t\n\r]+&quot;);

        /*
        E.info(&quot;after splitting &quot; + s);
        for (int i = 0; i &lt; sa.length; i++) {
        E.info(&quot;item &quot; + i + &quot; &quot; + sa[i]);
        }
        */

        int nt = sa.length;
        double[] value = new double[nt];

        try {
            for (int i = 0; i &lt; nt; i++) {
                value[i] = (new Double(sa[i])).doubleValue();
            }
        } catch (Exception ex) {
            E.error(&quot;float reading cant extract &quot; + nt + &quot; doubles from &quot; + s);
            for (int i = 0; i &lt; nt; i++) {
                E.info(&quot;string &quot; + i + &quot;=xxx&quot; + sa[i] + &quot;xxx&quot;);
            }
        }

        return value;
    }

}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/textensor/stochdiff/numeric/grid/DeterministicGridCalc.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/grid/DeterministicGridCalc.html#338">338</a></td></tr><tr class="b"><td>org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.html#520">520</a></td></tr><tr class="a"><td colspan='2'><div><pre>        while (time &lt; endtime) {

            // RO 5 13 2010: follows template in SteppedStochaticGridCalc
            if (time &gt;= writeTime) {
                if (resultWriter != null) {
                    resultWriter.writeString(getGridConcsText(time));
                }
                writeTime += sdRun.outputInterval;
            }
            for (int i = 0; i &lt; fnmsOut.length; i++) {
                if (time &gt;= writeTimeArray[i]) {
                    resultWriter.writeToSiblingFile(getGridConcsPlainText_dumb(i, time), &quot;-&quot; +fnmsOut[i] + &quot;-conc.txt&quot;);
                    writeTimeArray[i] += Double.valueOf(dtsOut[i]);
                }
            }

            time += advance(time);

            if (time &gt; tlog) {
                E.info(&quot;time &quot; + time + &quot; dt=&quot; + dt);
                tlog += Math.max(50 * sdRun.outputInterval, 5);
            }


            if (time &gt;= stateSaveTime) {
                resultWriter.writeToSiblingFile(getStateText(), sdRun.stateSavePrefix +  &quot;-&quot; + Math.round(time) + &quot;.nrds&quot;);</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/catacomb/graph/gui/Painter.java</td><td><a href="./xref/org/catacomb/graph/gui/Painter.html#1340">1340</a></td></tr><tr class="b"><td>org/catacomb/graph/gui/Painter.java</td><td><a href="./xref/org/catacomb/graph/gui/Painter.html#1354">1354</a></td></tr><tr class="a"><td colspan='2'><div><pre>    public void drawUpper3DIntMarks(float[][] ca, int n, int w, int h, double zp, double zd) {
        for (int i = 0; i &lt; n; i++) {
            double z = zProj(ca[i][0], ca[i][1], ca[i][2]);
            double f = ca[i][4];
            if (z &lt; (f * zd + (1.-f) * zp)) {

                int x = powx(xProj(ca[i][0], ca[i][1], ca[i][2]));
                int y =  powy(yProj(ca[i][0], ca[i][1], ca[i][2]));
                g.fillRect(x, y, w, h);</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.html#520">520</a></td></tr><tr class="b"><td>org/textensor/stochdiff/numeric/tmp/Tmp1A.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/tmp/Tmp1A.html#441">441</a></td></tr><tr class="a"><td colspan='2'><div><pre>        while (time &lt; endtime) {

            if (time &gt;= writeTime) {
                if (resultWriter != null) {
                    resultWriter.writeString(getGridConcsText(time));
                }
                writeTime += sdRun.outputInterval;
            }
            for (int i = 0; i &lt; fnmsOut.length; i++) {
                if (time &gt;= writeTimeArray[i]) {
                    resultWriter.writeToSiblingFile(getGridConcsPlainText_dumb(i, time), &quot;-&quot; + fnmsOut[i] + &quot;-conc.txt&quot;);
                    writeTimeArray[i] += Double.valueOf(dtsOut[i]);
                }
            }


            time += advance(time);

            if (time &gt; tlog) {
                E.info(&quot;time &quot; + time + &quot; dt=&quot; + dt);
                tlog += Math.max(50 * sdRun.outputInterval, 5);
            }

            if (time &gt;= stateSaveTime) {
                resultWriter.writeToFinalSiblingFile(getStateText(), sdRun.stateSavePrefix + Math.round(time) + &quot;.nrds&quot;);</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/catacomb/interlish/reflect/ReflectionConstructor.java</td><td><a href="./xref/org/catacomb/interlish/reflect/ReflectionConstructor.html#87">87</a></td></tr><tr class="b"><td>org/textensor/xml/ReflectionInstantiator.java</td><td><a href="./xref/org/textensor/xml/ReflectionInstantiator.html#52">52</a></td></tr><tr class="a"><td colspan='2'><div><pre>    }


    public void checkAddPackage(Object oret) {
        String scl = oret.getClass().getName();
        if (scl.startsWith(&quot;java&quot;)) {
            return;
        }

        int ild = scl.lastIndexOf(&quot;.&quot;);
        String pkg = scl.substring(0, ild);
        if (pkg.equals(wkpkg)) {
            // just same as before;

        } else {
            boolean got = false;
            for (int i = 0; i &lt; npkg; i++) {
                if (pkgs[i].equals(pkg)) {
                    got = true;
                    break;
                }
            }
            if (!got) {
                pkgs[npkg++] = pkg;

                // System.out.println(&quot;Reflection instantiator added search package
                // &quot; + pkg);
            }
        }
    }



    public Object newInstance(String scl) {
        Object oret = null;
        Class&lt;?&gt; c = null;</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/catacomb/numeric/mesh/Discretizer.java</td><td><a href="./xref/org/catacomb/numeric/mesh/Discretizer.html#337">337</a></td></tr><tr class="b"><td>org/textensor/stochdiff/disc/SegmentSlicer.java</td><td><a href="./xref/org/textensor/stochdiff/disc/SegmentSlicer.html#315">315</a></td></tr><tr class="a"><td colspan='2'><div><pre>            } else {
                // chop up the carrot;
                double delf = fdist / (nadd+1);
                double ffa = (rb - ra) / dab;      // dr/dx
                double xa = ra / ffa;
                double xb = rb / ffa;
                // xa and xb are the end positions measured from where
                // the carrot comes to a point.
                double x = xa;

                // the integral of sqrt(r) dx is
                // 2/3 * dx / (rb-ra) * (rb^3/2 - ra^3/2)
                // so need dx such that this is delf (= total_int / nseg)

                for (int i = 0; i &lt; nadd+1; i++) {
                    double ttt = (delf * ffa * 3./2. +
                                  Math.pow(ffa * x, 3./2.));
                    double dx = Math.pow(ttt, (2./3.)) / ffa - x;
                    x += dx;
                    if (i &lt; nadd) {
                        dpos[i] = (x - xa) / dab;
                    }
                }
                if (Math.abs(xb - x) &gt; 1.e-5) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/catacomb/interlish/reflect/ReflectionConstructor.java</td><td><a href="./xref/org/catacomb/interlish/reflect/ReflectionConstructor.html#393">393</a></td></tr><tr class="b"><td>org/textensor/xml/ReflectionInstantiator.java</td><td><a href="./xref/org/textensor/xml/ReflectionInstantiator.html#330">330</a></td></tr><tr class="a"><td colspan='2'><div><pre>            return true;
        }

        if (arg.equals(ob)) {
            E.error(&quot;ReflectionInstantiator setField: &quot; + &quot;the child is the same as the parent &quot; + ob);
            return true;
        }

        int icolon = sf.indexOf(&quot;:&quot;);
        if (icolon &gt;= 0) {
            sf = sf.substring(0, icolon) + &quot;_&quot; + sf.substring(icolon + 1, sf.length());
        }

        boolean ok = false;

        Class c = ob.getClass();
        Field f = null;
        try {
            f = c.getField(sf);
        } catch (NoSuchFieldException e) {
        }



        if (f == null) {
            if (ob instanceof ArrayList) {
                ((ArrayList)ob).add(arg);
                ok = true;

            } else if (arg instanceof String &amp;&amp; ob instanceof AttributeAddableTo) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/catacomb/report/E.java</td><td><a href="./xref/org/catacomb/report/E.html#255">255</a></td></tr><tr class="b"><td>org/textensor/report/E.java</td><td><a href="./xref/org/textensor/report/E.html#170">170</a></td></tr><tr class="a"><td colspan='2'><div><pre>    }


    public static String getShortSource() {
        StackTraceElement[] stea = (new Exception()).getStackTrace();
        String ss = (&quot; at &quot; + stea[2].toString());
        if (ss.equals(lastShortSource)) {
            ss = &quot;&quot;;
        } else {
            lastShortSource = ss;
        }
        return ss;
    }



    public static void delay() {
        pause(200);
    }


    public static void pause(int n) {
        try {

            Thread.sleep(n);
        } catch (Exception ex) {
        }
    }


    public static void newLine() {
        System.out.println(&quot;...&quot;);
    }


    public static void cacheAction(String s) {
        cachedAction = s;
    }

    public static void reportCached() {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/textensor/vis/SceneGraphBuilder.java</td><td><a href="./xref/org/textensor/vis/SceneGraphBuilder.html#367">367</a></td></tr><tr class="b"><td>org/textensor/vis/SceneGraphBuilder.java</td><td><a href="./xref/org/textensor/vis/SceneGraphBuilder.html#382">382</a></td></tr><tr class="a"><td colspan='2'><div><pre>        for (int ic = 0; ic &lt; ncap; ic++) {
            double[][] incs = (ic % 2 == 0 ? csbs : csas);
            double[][] outcs = (ic % 2 == 0 ? csas : csbs);

            double t0 = ic * (0.5 * Math.PI / (ncap + 0.1));
            double t1 = (ic + 1) * (0.5 * Math.PI / (ncap + 0.1));
            double s0 = Math.sin(t0);
            double c0 = Math.cos(t0);
            double s1 = Math.sin(t1);
            double c1 = Math.cos(t1);
            vnStrip(datv, datn, koff, nside, c1 * ra, c0 * ra, -1 * s1 * ra, -1 * s0 * ra, -s1, c1, -s0, c0, incs, outcs);</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/catacomb/serial/xml/XMLWriter.java</td><td><a href="./xref/org/catacomb/serial/xml/XMLWriter.html#14">14</a></td></tr><tr class="b"><td>org/textensor/xml/XMLWriter.java</td><td><a href="./xref/org/textensor/xml/XMLWriter.html#10">10</a></td></tr><tr class="a"><td colspan='2'><div><pre>public class XMLWriter {

    boolean conciseTags;
    boolean quoteStrings;


    public XMLWriter() {
        conciseTags = false;
        quoteStrings = true;
    }


    public void setConciseTags(boolean b) {
        conciseTags = b;
    }


    public void setQuoteStrings(boolean b) {
        quoteStrings = b;
    }


    public static void err(String s) {
        System.out.println(s);
    }


    public static XMLWriter newInstance() {
        return new XMLWriter();
    }


    public static String serialize(Object ob) {
        return getSerialization(ob);
    }


    public static String getSerialization(Object ob) {
        return newInstance().writeObject(ob);
    }



    public String writeObject(Object obj) {
        StringBuffer sb = new StringBuffer();
        appendObject(sb, &quot;&quot;, null, obj);</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/catacomb/graph/gui/Painter.java</td><td><a href="./xref/org/catacomb/graph/gui/Painter.html#1329">1329</a></td></tr><tr class="b"><td>org/catacomb/graph/gui/Painter.java</td><td><a href="./xref/org/catacomb/graph/gui/Painter.html#1342">1342</a></td></tr><tr class="a"><td colspan='2'><div><pre>            double z = zProj(ca[i][0], ca[i][1], ca[i][2]);
            double f = ca[i][4];
            if (z &lt; (f * zd + (1.-f) * zp)) {
                int x = powx(xProj(ca[i][0], ca[i][1], ca[i][2]));
                int y =  powy(yProj(ca[i][0], ca[i][1], ca[i][2]));
                g.fillRect(x, y, 1, 1);</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/textensor/stochdiff/numeric/grid/DeterministicGridCalc.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/grid/DeterministicGridCalc.html#195">195</a></td></tr><tr class="b"><td>org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.html#379">379</a></td></tr><tr class="a"><td>org/textensor/stochdiff/numeric/tmp/Tmp1A.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/tmp/Tmp1A.html#335">335</a></td></tr><tr class="b"><td colspan='2'><div><pre>                    }
                }
            }
        }

    }

    @SuppressWarnings(&quot;boxing&quot;)
    // RO 5 13 2010: Commented out in favor of new version above.
    // private String getGridConcsText(double time) {
    // StringBuffer sb = new StringBuffer();
    // sb.append(&quot;gridConcentrations &quot; + nel + &quot; &quot; + nspec + &quot; &quot; + time + &quot; &quot;);
    // for (int i = 0; i &lt; nspec; i++) {
    // sb.append(specieIDs[i] + &quot; &quot;);
    // }
    // sb.append(&quot;\n&quot;);
    //
    // for (int i = 0; i &lt; nel; i++) {
    // // sb.append(&quot;&quot;);
    // for (int j = 0; j &lt; nspec; j++) {
    // sb.append(String.format(&quot; %g5 &quot;, wkB[i][j]));
    // }
    // sb.append(&quot;\n&quot;);
    // }
    // return sb.toString();
    // }
    // RO
    private String getGridConcsText(double time) {
        StringBuffer sb = new StringBuffer();
        // TODO tag specific to integer quantities;
        int nspecout = ispecout.length;
        if (nspecout == 0) {
            return &quot;&quot;;
        }

        sb.append(&quot;gridConcentrations &quot; + nel + &quot; &quot; + nspecout + &quot; &quot; + time + &quot; &quot;);
        for (int i = 0; i &lt; nspecout; i++) {
            sb.append(specieIDs[ispecout[i]] + &quot; &quot;);
        }
        sb.append(&quot;\n&quot;);
        for (int i = 0; i &lt; nel; i++) {
            for (int j = 0; j &lt; nspecout; j++) {
                // rcc May 2010: this was wrong, was it just saving species j,
                // not species ispecout[j]
                // sb.append(stringd(wkA[i][j]));
                if (writeConcentration) {
                    sb.append(stringd(wkA[i][ispecout[j]]));</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/serial/om/OmFileReader.java</td><td><a href="./xref/org/catacomb/serial/om/OmFileReader.html#16">16</a></td></tr><tr class="a"><td>org/catacomb/serial/om/OmFileWriter.java</td><td><a href="./xref/org/catacomb/serial/om/OmFileWriter.html#16">16</a></td></tr><tr class="b"><td colspan='2'><div><pre>    public OmFileReader(File f) {
        file = f;
    }


    public File getFile() {
        return file;
    }

    public File getResourceDir() {
        /*
        String fnm = FileUtil.getRootName(file);
        String resnm = fnm + &quot;_resources&quot;;
        File fparent = file.getParentFile();
        File fres = new File(fparent, resnm);
        if (fres.exists()) {
           // OK;
        } else {
           fres.mkdir();
        }
        return fres;
        */
        return file.getParentFile();
    }



    public void writeResource(Object oext, String resnm) {
        File fres = new File(getResourceDir(), resnm);
        Archivist.storeXMLOnly(oext, fres);
    }



    public Object readResource(String resnm) {
        Object ret = null;

        File f = new File(getResourceDir(), resnm);
        if (f.exists()) {

            String ftxt = FileUtil.readStringFromFile(f);
            ret = Deserializer.deserialize(ftxt);

        } else {
            E.error(&quot;no such resource file &quot; + f);
        }
        return ret;
    }

}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/serial/xml/XMLChecker.java</td><td><a href="./xref/org/catacomb/serial/xml/XMLChecker.html#9">9</a></td></tr><tr class="a"><td>org/textensor/xml/XMLChecker.java</td><td><a href="./xref/org/textensor/xml/XMLChecker.html#8">8</a></td></tr><tr class="b"><td colspan='2'><div><pre>public class XMLChecker {



    public static void checkXML(String s, boolean bshow) {
        long starttime = System.currentTimeMillis();
        XMLTokenizer tkz = new XMLTokenizer(s);
        int nerror = 0;
        int nread = 0;

        while (true) {
            XMLToken xmlt = tkz.nextToken();
            if (bshow) {
                System.out.println(&quot;item &quot; + nread + &quot;  &quot; + xmlt);
            }
            nread++;
            if (xmlt.isNone()) {
                break;
            }
        }
        long endtime = System.currentTimeMillis();

        System.out.println(&quot;  Total tags: &quot; + nread + &quot;\n  total errors: &quot; + nerror +
                           &quot;\n  tokenizing took &quot; + (int)(endtime - starttime) + &quot; ms&quot;);
    }








    public static String deGarbage(String sin) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/dataview/FrameController.java</td><td><a href="./xref/org/catacomb/dataview/FrameController.html#138">138</a></td></tr><tr class="a"><td>org/catacomb/dataview/gui/FramePlayerController.java</td><td><a href="./xref/org/catacomb/dataview/gui/FramePlayerController.html#95">95</a></td></tr><tr class="b"><td colspan='2'><div><pre>    }



    public void sliderMoved() {
        int ival = frameSlider.getValue();
        showFrame(ival);
    }


    public void rewind() {
        stop();
        showFrame(0);
    }





    public void pause() {
        if (isPaused) {
            dePause();
            start();

        } else {
            rePause();
            stop();
        }
    }


    public void dePause() {
        isPaused = false;
        pauseButton.setLabelText(&quot; pause &quot;);
    }

    private void rePause() {
        isPaused = true;
        pauseButton.setLabelText(&quot;resume&quot;);
    }


    public void play() {
        stop();
        rewind();
        start();
        dePause();
    }


    private void start() {
        if (indexes != null) {
            framePlayer = null; // new FramePlayer(this);</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/graph/gui/Painter.java</td><td><a href="./xref/org/catacomb/graph/gui/Painter.html#1329">1329</a></td></tr><tr class="a"><td>org/catacomb/graph/gui/Painter.java</td><td><a href="./xref/org/catacomb/graph/gui/Painter.html#1356">1356</a></td></tr><tr class="b"><td colspan='2'><div><pre>            double z = zProj(ca[i][0], ca[i][1], ca[i][2]);
            double f = ca[i][4];
            if (z &lt; (f * zd + (1.-f) * zp)) {
                int x = powx(xProj(ca[i][0], ca[i][1], ca[i][2]));
                int y =  powy(yProj(ca[i][0], ca[i][1], ca[i][2]));
                g.fillRect(x, y, 1, 1);</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/interlish/reflect/ReflectionConstructor.java</td><td><a href="./xref/org/catacomb/interlish/reflect/ReflectionConstructor.html#243">243</a></td></tr><tr class="a"><td>org/textensor/xml/ReflectionInstantiator.java</td><td><a href="./xref/org/textensor/xml/ReflectionInstantiator.html#214">214</a></td></tr><tr class="b"><td colspan='2'><div><pre>        Object child = null;

        if (parent != null) {
            checkAddPackage(parent); // EFF inefficient
        }

        // Three possibilities:
        // 1 there is an attribute called class;
        // 2 the parent has a field called name;
        // 3 the name is a class name;


        if (atta == null) {
            atta = new Attribute[0];
        }


        // process special attributes and instantiate child if class is known
        // (case 1);
        String classname = null;
        for (int i = 0; i &lt; atta.length; i++) {
            Attribute att = atta[i];
            String attName = att.getName();
            String attValue = att.getValue();

            if (attName.equals(&quot;package&quot;)) {
                StringTokenizer stok = new StringTokenizer(attValue, &quot;, &quot;);
                while (stok.hasMoreTokens()) {
                    addSearchPackage(stok.nextToken());
                }

            } else if (attName.equals(&quot;archive-hash&quot;)) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/druid/swing/dnd/RegionDropTarget.java</td><td><a href="./xref/org/catacomb/druid/swing/dnd/RegionDropTarget.html#62">62</a></td></tr><tr class="a"><td>org/catacomb/druid/swing/dnd/TextFieldDropTarget.java</td><td><a href="./xref/org/catacomb/druid/swing/dnd/TextFieldDropTarget.html#48">48</a></td></tr><tr class="b"><td colspan='2'><div><pre>                textCanvas.paintImmediately(dragBounds);
            } else {
                dragBounds = new Rectangle();
            }

            Point p = dtde.getLocation();

            Object obj = DragAndDrop.getDnD();

            if (obj instanceof ImageDragSource) {
                ImageDragSource ids = (ImageDragSource)obj;

                BufferedImage bim = ids.getDragImage();
                Point poff = ids.getDragImageOffset();

                int bw = bim.getWidth();
                int bh = bim.getHeight();

                if (bim == null) {
                    E.warning(&quot;no drag image?&quot;);
                } else {

                    // And remember where we are about to draw the new ghost image
                    dragBounds.setRect(p.x - poff.x, p.y - poff.y, bw, bh);

                    Graphics g = textCanvas.getGraphics();</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/textensor/stochdiff/numeric/grid/DeterministicGridCalc.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/grid/DeterministicGridCalc.html#267">267</a></td></tr><tr class="a"><td>org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.html#426">426</a></td></tr><tr class="b"><td>org/textensor/stochdiff/numeric/tmp/Tmp1A.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/tmp/Tmp1A.html#382">382</a></td></tr><tr class="a"><td colspan='2'><div><pre>                        sb.append(stringd((PARTICLES_PUVC * wkv * volumes[i])));
                    }

                }
            }
        }
        sb.append(&quot;\n&quot;);
        return sb.toString();
    }


    @SuppressWarnings(&quot;boxing&quot;)
    private String getStateText() {
        StringBuffer sb = new StringBuffer();
        sb.append(&quot;nrds &quot; + nel + &quot; &quot; + specieIDs.length + &quot;\n&quot;);
        for (int i = 0; i &lt; specieIDs.length; i++) {
            sb.append(specieIDs[i] + &quot; &quot;);
        }
        sb.append(&quot;\n&quot;);
        for (int i = 0; i &lt; nel; i++) {
            for (int j = 0; j &lt; specieIDs.length; j++) {
                sb.append(stringd(wkA[i][j]));</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/catacomb/dataview/AxisPainter.java</td><td><a href="./xref/org/catacomb/dataview/AxisPainter.html#159">159</a></td></tr><tr class="b"><td>org/catacomb/graph/gui/YAxisCanvas.java</td><td><a href="./xref/org/catacomb/graph/gui/YAxisCanvas.html#79">79</a></td></tr><tr class="a"><td colspan='2'><div><pre>        int ii = intervals[iiind];
        dy = Math.pow(10.0, powten) * ii;

        int i0 = (int)(ylow / dy);
        int i1 = (int)(yhigh / dy);

        for (int i = i0; i &lt;= i1; i++) {
            double yy = i * dy;
            String lab = &quot;0&quot;;
            if (i == 0) {
                // OK;

            } else if (dy &gt;= 0.999 &amp;&amp; dy &lt; 1.e4) {
                lab = String.valueOf((int)(yy));
            } else {
                lab = String.valueOf((float)(yy));
            }

            int iy = height - bm - (int)((height - bm) * (yy - ylow) / (yhigh - ylow));</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/catacomb/graph/gui/Painter.java</td><td><a href="./xref/org/catacomb/graph/gui/Painter.html#1173">1173</a></td></tr><tr class="b"><td>org/catacomb/graph/gui/Painter.java</td><td><a href="./xref/org/catacomb/graph/gui/Painter.html#1192">1192</a></td></tr><tr class="a"><td>org/catacomb/graph/gui/Painter.java</td><td><a href="./xref/org/catacomb/graph/gui/Painter.html#1209">1209</a></td></tr><tr class="b"><td colspan='2'><div><pre>    final void drawOutline(double xa, double ya, double ra,
                           double xb, double yb, double rb) {

        double vy = xb - xa;
        double vx = -(yb - ya);
        double vl = Math.sqrt(vx * vx + vy * vy);
        if (vl &lt;= 0.0) vl = 1.e-6; // ***
        vx /= vl;
        vy /= vl;

        drawLine(xa - ra * vx, ya - ra * vy,  xb - rb * vx, yb - rb * vy);
        drawLine(xa + ra * vx, ya + ra * vy,  xb + rb * vx, yb + rb * vy);</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/dataview/gui/CCVizController.java</td><td><a href="./xref/org/catacomb/dataview/gui/CCVizController.html#78">78</a></td></tr><tr class="a"><td>org/catacomb/dataview/gui/DViewController.java</td><td><a href="./xref/org/catacomb/dataview/gui/DViewController.html#140">140</a></td></tr><tr class="b"><td colspan='2'><div><pre>    }

    public void requestClose() {
        exit();
    }


    public void reload() {
        E.info(&quot;time to reload...&quot;);
    }


    public void requestExit() {
        exit();
    }


    public void exit() {
        System.exit(0);
    }


    public void syncOptions() {
        String[] sa = new String[0];
        if (dataHandler != null) {
            sa = dataHandler.getViewOptions();
        }
        viewMenu.setOptions(sa);
    }


    public void setViewStyle(String s) {

        if (dataHandler != null) {
            dataHandler.setViewStyle(s);
        }

        basicController.repaint();</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/druid/swing/RolloverEffect.java</td><td><a href="./xref/org/catacomb/druid/swing/RolloverEffect.html#155">155</a></td></tr><tr class="a"><td>org/catacomb/graph/gui/RolloverEffect.java</td><td><a href="./xref/org/catacomb/graph/gui/RolloverEffect.html#155">155</a></td></tr><tr class="b"><td>org/catacomb/util/ColorUtil.java</td><td><a href="./xref/org/catacomb/util/ColorUtil.html#71">71</a></td></tr><tr class="a"><td colspan='2'><div><pre>    public static Color linMod(Color c, int d) {
        int r = c.getRed();
        int g = c.getGreen();
        int b = c.getBlue();

        r += d;
        g += d;
        b += d;
        r = (r &gt; 0 ? (r &lt; 255 ? r : 255) : 0);
        g = (g &gt; 0 ? (g &lt; 255 ? g : 255) : 0);
        b = (b &gt; 0 ? (b &lt; 255 ? b : 255) : 0);
        return new Color(r, g, b);
    }</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/catacomb/dataview/AxisPainter.java</td><td><a href="./xref/org/catacomb/dataview/AxisPainter.html#105">105</a></td></tr><tr class="b"><td>org/catacomb/graph/gui/XAxisCanvas.java</td><td><a href="./xref/org/catacomb/graph/gui/XAxisCanvas.html#74">74</a></td></tr><tr class="a"><td colspan='2'><div><pre>        int i1 = (int)(xr[1] / dx);

        for (int i = i0; i &lt;= i1; i++) {
            double xx = i * dx;
            String lab = &quot;0&quot;;
            if (i == 0) {
                // OK;

            } else if (dx &gt;= 0.999 &amp;&amp; dx &lt; 1.e4) {
                lab = String.valueOf((int)(xx));
            } else {
                lab = String.valueOf((float)(xx));
            }
            int off = lab.length();
            off = 1 - 4 * off;
            if (i * dx &lt; 0.0) {
                off -= 4;
            }

            int ix = (int)(lm + (width - lm) * (xx - xr[0]) / (xr[1] - xr[0]));</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/textensor/stochdiff/disc/DiscBoxer.java</td><td><a href="./xref/org/textensor/stochdiff/disc/DiscBoxer.html#104">104</a></td></tr><tr class="b"><td>org/textensor/stochdiff/disc/DiscSplitter.java</td><td><a href="./xref/org/textensor/stochdiff/disc/DiscSplitter.html#107">107</a></td></tr><tr class="a"><td>org/textensor/stochdiff/disc/LineBoxer.java</td><td><a href="./xref/org/textensor/stochdiff/disc/LineBoxer.html#114">114</a></td></tr><tr class="b"><td colspan='2'><div><pre>                    vg = baseGrid(tp, tpn, lbl);
                    pGrid.subPlaneConnect(tp, tpn, vg, par.partBranchOffset);
                    par.partBranchOffset += 2 * tpn.r;

                } else {
                    // normal case: make a new one or add a slice and connect
                    // it up with the centres aligned
                    if (pGrid == null) {
                        vg = baseGrid(tp, tpn, lbl);

                    } else {
                        // TODO - probably not what we want
                        // too much mumerical diffusion if boxes can have gradually changing
                        // sizes? restrict to a few dicrete multiples?
                        vg = baseGrid(tp, tpn, lbl);
                        pGrid.planeConnect(vg);
                    }

                }

                lbl = null; // only use it once
                if (vg != null) {
                    gridAL.add(vg);
                    recAdd(vg, tpn);
                } else {
                    // skipped the point that is the start of a new segment
                    // of different radius
                    recAdd(pGrid, tpn);
                }
            }
        }
    }




    public VolumeSlice baseGrid(TreePoint tpa, TreePoint tpb, String lbl) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/numeric/math/Matrix.java</td><td><a href="./xref/org/catacomb/numeric/math/Matrix.html#29">29</a></td></tr><tr class="a"><td>org/textensor/stochdiff/numeric/math/Matrix.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/math/Matrix.html#75">75</a></td></tr><tr class="b"><td colspan='2'><div><pre>    }


    public double[] flatten() {
        double[] d = new double[n1 * n2];
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                d[n * i + j] = a[i][j];
            }
        }
        return d;
    }


    public void Sp(String s) {
        System.out.println(s);
    }


    public final int dim() {
        return n;
    }


    public Matrix copy() {
        Matrix m = new Matrix(n);</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/druid/swing/DFloatSlider.java</td><td><a href="./xref/org/catacomb/druid/swing/DFloatSlider.html#188">188</a></td></tr><tr class="a"><td>org/catacomb/druid/swing/DSlider.java</td><td><a href="./xref/org/catacomb/druid/swing/DSlider.html#136">136</a></td></tr><tr class="b"><td colspan='2'><div><pre>        }
    }


    /*
    private void ensureRangeCovers() {
       if (linmin &gt; linvalue) {
          linmin = linvalue;
       }
       if (linmax &lt; linvalue) {
          linmax = linvalue;
       }
    }
    */


    public Dimension getMinimumSize() {
        return new Dimension(80, 20);
    }


    public Dimension getPreferredSize() {
        return new Dimension(140, 22);
    }



    public void paintComponent(Graphics g) {
        realPaint(g);
    }



    public void realPaint(Graphics g) {
        int w = getWidth();
        int h = getHeight();
        if (bgColor == null) {
            bgColor = getBackground();
        }
        g.setColor(bgColor);
        g.fillRect(0, 0, w, h);

        paintArrows(g);

        paintKnob(g);

        if (label != null) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/serial/xml/XMLChecker.java</td><td><a href="./xref/org/catacomb/serial/xml/XMLChecker.html#44">44</a></td></tr><tr class="a"><td>org/textensor/xml/XMLChecker.java</td><td><a href="./xref/org/textensor/xml/XMLChecker.html#42">42</a></td></tr><tr class="b"><td colspan='2'><div><pre>        if (s.startsWith(&quot;&lt;&quot;)) {
            // fine;

        } else {
            int iob = s.indexOf(&quot;&lt;&quot;);

            if (iob &gt; 0) {
                String junk = s.substring(0, iob);
                if (junk.trim().length() &gt; 0) {

                    System.out.println(&quot;WARNING - garbage at start of xml file - first &lt; is at &quot; +
                                       iob + &quot; preceded by ---&quot; + junk + &quot;---&quot;);
                }
                s = s.substring(iob, s.length());

            } else {
                E.error(&quot; - xml file contains no xml &quot; + s);
                s = null;
            }
        }

        return s;
    }




}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/druid/gui/edit/DruCheckboxMenuItem.java</td><td><a href="./xref/org/catacomb/druid/gui/edit/DruCheckboxMenuItem.html#76">76</a></td></tr><tr class="a"><td>org/catacomb/druid/gui/edit/DruMenuItem.java</td><td><a href="./xref/org/catacomb/druid/gui/edit/DruMenuItem.html#65">65</a></td></tr><tr class="b"><td colspan='2'><div><pre>    }


    public void setEnableOnSelection(String depends) {
        enableOn = depends;
    }


    public void setSelectionSource(SelectionSource source) {
        selectionSource = source;
    }


    public void sync() {
//      E.info(&quot;dmi syncing  enable=&quot; + enableOn);
        if (selectionSource != null &amp;&amp; enableOn != null) {
            String s = selectionSource.getSelectionType();
            if (enableOn.indexOf(s) &gt;= 0) {
                dItem.setEnabled(true);
            } else {
                dItem.setEnabled(false);
            }

        }
    }


    public void setInfo(String s) {
        info = s;
    }


    public void setInfoReceiver(InfoReceiver irec) {
        infoReceiver = irec;
    }


}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/catacomb/druid/swing/DTreeDragSource.java</td><td><a href="./xref/org/catacomb/druid/swing/DTreeDragSource.html#86">86</a></td></tr><tr class="a"><td>org/catacomb/druid/swing/dnd/RegionDragSource.java</td><td><a href="./xref/org/catacomb/druid/swing/dnd/RegionDragSource.html#77">77</a></td></tr><tr class="b"><td colspan='2'><div><pre>        source.startDrag(dge, Cursor.getPredefinedCursor(Cursor.HAND_CURSOR), dragImg, imgOffset, transferable, this);

    }





    /*
     * Drag Event Handlers
     */
    public void dragEnter(DragSourceDragEvent dsde) {
    }

    public void dragExit(DragSourceEvent dse) {
    }

    public void dragOver(DragSourceDragEvent dsde) {
    }

    public void dropActionChanged(DragSourceDragEvent dsde) {
        System.out.println(&quot;Action: &quot; + dsde.getDropAction());
        System.out.println(&quot;Target Action: &quot; + dsde.getTargetActions());
        System.out.println(&quot;User Action: &quot; + dsde.getUserAction());
    }



    public void dragDropEnd(DragSourceDropEvent dsde) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/textensor/stochdiff/numeric/grid/DeterministicGridCalc.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/grid/DeterministicGridCalc.html#244">244</a></td></tr><tr class="a"><td>org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.html#406">406</a></td></tr><tr class="b"><td>org/textensor/stochdiff/numeric/tmp/Tmp1A.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/tmp/Tmp1A.html#362">362</a></td></tr><tr class="a"><td colspan='2'><div><pre>                    sb.append(stringd(wkA[i][ispecout[j]] * volumes[i] * PARTICLES_PUVC));

                }
            }
            sb.append(&quot;\n&quot;);
        }
        return sb.toString();
    }

    private String getGridConcsPlainText_dumb(int filenum, double time) {
        StringBuffer sb = new StringBuffer();
        // TODO tag specific to integer quantities;
        sb.append(stringd(time));

        for (int j = 0; j &lt; specIndexesOut[filenum].length; j++) {
            for (int i = 0; i &lt; nel; i++) {
                // WK 6 17 2007
                if (regionsOut[filenum].equals(&quot;default&quot;) || regionsOut[filenum].equals(regionLabels[eltregions[i]])) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/catacomb/druid/blocks/Choice.java</td><td><a href="./xref/org/catacomb/druid/blocks/Choice.html#91">91</a></td></tr><tr class="b"><td>org/catacomb/druid/blocks/RadioButtons.java</td><td><a href="./xref/org/catacomb/druid/blocks/RadioButtons.html#51">51</a></td></tr><tr class="a"><td colspan='2'><div><pre>            sopts = new String[sa.length];
            slabs = new String[sa.length];

            for (int i = 0; i &lt; sa.length; i++) {
                String s = sa[i].trim();
                sopts[i] = s;
                slabs[i] = s;
            }

            if (labels != null) {
                String[] sb = labels.split(&quot;,&quot;);
                for (int i = 0; i &lt; sa.length &amp;&amp; i &lt; sopts.length; i++) {
                    slabs[i] = sb[i].trim();
                }
            }</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/catacomb/druid/blocks/List.java</td><td><a href="./xref/org/catacomb/druid/blocks/List.html#52">52</a></td></tr><tr class="b"><td>org/catacomb/druid/blocks/ScrollingList.java</td><td><a href="./xref/org/catacomb/druid/blocks/ScrollingList.html#55">55</a></td></tr><tr class="a"><td colspan='2'><div><pre>        DruListPanel drup = (DruListPanel)dp;
        drup.setAction(action);


        if (renderer != null) {

            // TODO move renderer defs to XML;

            if (renderer.equals(&quot;quantity&quot;)) {
                drup.setCellRenderer(new DruListQuantityRenderer());

            } else if (renderer.equals(&quot;progress&quot;)) {
                drup.setCellRenderer(new DruListProgressRenderer());

            } else if (renderer.equals(&quot;color&quot;)) {
                drup.setCellRenderer(new DruListColorRenderer());

            } else {
                E.error(&quot;unrecognized renderer &quot; + renderer);
            }
        }

        if (multiple) {
            drup.setMultiple();
        }


        if (order != null) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.html#901">901</a></td></tr><tr class="b"><td>org/textensor/stochdiff/numeric/tmp/Tmp1A.java</td><td><a href="./xref/org/textensor/stochdiff/numeric/tmp/Tmp1A.html#824">824</a></td></tr><tr class="a"><td colspan='2'><div><pre>        }
        // WK
        // if (ngo &lt; (# of neighbors)*SHARED_DIFF_PARTICLES) then do
        // shared_diffusion
        // else then do independent_diffusion
        if (ngo &lt;= (inbr.length) * SHARED_DIFF_PARTICLES) // SHARED diffusion
        {
            wkB[iel][k] -= ngo;
            for (int i = 0; i &lt; ngo; i++) {
                double r = random.random();
                int io = 0;
                while (r &gt; fshare[io]) {
                    io++;
                }

                wkB[inbr[io]][k] += 1;
            }
        } else // MULTINOMIAL diffusion
        {
            ngo_remaining = ngo;         //**KTB  ngo_remaining is number of particles not yet diffused.  initially this is ngo
            //KTB 09-23-2011, use multi-nomial instead of separate binomials to calculate lnpgo, from ngo_remaining
            // WK 9 11 2007
            double prev = 0;
            for (int j = 0; j &lt; inbr.length - 1; j++) {
                //double lnpgo = Math.log(fSharedExit[iel][k][j] - prev);  (KTB) old method - INDEPENDENT
                //BHK and KTB implemented the multinomial using tables instead of gaussianStep for small N, and use symmetry of binomial 09/23/11
                double pgoTmp = (fSharedExit[iel][k][j] - prev)/(fSharedExit[iel][k][inbr.length-1]-prev);</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/catacomb/act/FunctionSignature.java</td><td><a href="./xref/org/catacomb/act/FunctionSignature.html#34">34</a></td></tr><tr class="b"><td>org/catacomb/act/MethodSignature.java</td><td><a href="./xref/org/catacomb/act/MethodSignature.html#90">90</a></td></tr><tr class="a"><td colspan='2'><div><pre>    }


    public int getTypeCode() {
        return type;
    }


    public static String getTypeInfo(int itc) {
        String ret = &quot;&quot;;
        if (itc == RECEIVE) {
            ret = &quot;Handlers: functions that are called when an event occurs in a connected component.&quot;;

        } else if (itc == SEND) {
            ret = &quot;Senders: these send an event to any connected components. The handler \n&quot; +
                  &quot;on the receiving component will be called.&quot;;


        } else if (itc == SETTER) {
            ret = &quot;Setters: these set a value for use later, but have no other effect: \n&quot; +
                  &quot;the value is available to connected components if they ask for it&quot;;

        } else if (itc == GETTER) {
            ret = &quot;Getters: give access to quantities in connected components.&quot;;
        }
        return ret;
    }


    public void setInfo(String s) {
        info = s;
    }


    public String getName() {
        return functionName;
    }


    public String toJavaScriptStub() {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/catacomb/graph/gui/DataDisplay.java</td><td><a href="./xref/org/catacomb/graph/gui/DataDisplay.html#216">216</a></td></tr><tr class="b"><td>org/catacomb/graph/gui/MovieDisplay.java</td><td><a href="./xref/org/catacomb/graph/gui/MovieDisplay.html#119">119</a></td></tr><tr class="a"><td colspan='2'><div><pre>        pwCanvas.requestRepaint();
    }


    public void setXRange(double low, double high) {
        pwCanvas.setXRange(low, high);
    }


    public double[] getXRange() {
        return pwCanvas.getXRange();
    }


    public double[] getYRange() {
        return pwCanvas.getYRange();
    }


    public void setFixedAspectRatio(double ar) {
        pwCanvas.setFixedAspectRatio(ar);
    }


    public void viewChanged() {
        if (pwCanvas != null) {
            pwCanvas.repaint();
        }
    }


    public void reframe() {
        pwCanvas.reframe();
    }


    public static void main(String[] argv) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/catacomb/graph/gui/Painter.java</td><td><a href="./xref/org/catacomb/graph/gui/Painter.html#993">993</a></td></tr><tr class="b"><td>org/catacomb/graph/gui/Painter.java</td><td><a href="./xref/org/catacomb/graph/gui/Painter.html#1027">1027</a></td></tr><tr class="a"><td colspan='2'><div><pre>        for (int i = 0; i &lt; nel; i++) {
            double[] xb = mesh[i][0];
            double[] yb = mesh[i][1];


            double fc = (dat[i] - ctMin) / dc;
            if (fc &lt; 0.) {
                fc = 0.;
            }
            int ic = (int)(255 * fc);
            if (ic &gt; 255) {
                ic = 255;
            }
            if (ic &lt; 0) {
                ic = 0;
            }
            fillPolygon(xb, yb, xb.length, colorTable[ic]);
        }
    }</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/catacomb/serial/xml/XMLReader.java</td><td><a href="./xref/org/catacomb/serial/xml/XMLReader.html#233">233</a></td></tr><tr class="b"><td>org/textensor/xml/XMLReader.java</td><td><a href="./xref/org/textensor/xml/XMLReader.html#226">226</a></td></tr><tr class="a"><td colspan='2'><div><pre>                            StringBuffer sbo = (StringBuffer)child;
                            String ssf = sbo.toString();
                            if (ssf.endsWith(&quot;&gt;&quot;) || next.svalue.startsWith(&quot;&lt;&quot;) || ssf.length() == 0) {
                                sbo.append(next.svalue);

                            } else {
                                sbo.append(&quot; &quot;);
                                sbo.append(next.svalue);
                            }


                        } else {
                            if (child instanceof String &amp;&amp; ((String)child).length() &gt; 0) {
                                child = child + &quot; &quot; + next.svalue;</pre></div></td></tr></table></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
              Copyright &#169;                   2013.
          All Rights Reserved.      
        
                  </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
