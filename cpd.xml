<?xml version="1.0" encoding="UTF-8"?>
<pmd-cpd>
<duplication lines="293" tokens="1554">
<file line="166" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.java"/>
<file line="122" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/tmp/Tmp1A.java"/>
<codefragment>
<![CDATA[
        random = new MersenneTwister(getCalculationSeed());

        rtab = getReactionTable();
        speciesIDs = rtab.getSpeciesIDs();

        nreaction = rtab.getNReaction();
        rates = rtab.getRates();

        // Debug.dump("rates", rates);

        lnrates = ArrayUtil.log(rates, -999.);

        reactantIndices = rtab.getReactantIndices();
        productIndices = rtab.getProductIndices();

        reactantStochiometry = rtab.getReactantStochiometry();
        productStochiometry = rtab.getProductStochiometry();

        vgrid = getVolumeGrid();

        nel = vgrid.getNElements();

        nspec = rtab.getNSpecies();
        specieIDs = rtab.getSpecieIDs();
        volumes = vgrid.getElementVolumes();
        lnvolumes = ArrayUtil.log(volumes, -999.);

        // RO
        // ----------------------
        // System.out.println("Number of files        : " + NspeciesFilef);
        // System.out.println("Total numer of species : " + NspeciesIDsOutf);

        // ----------------------
        // RO
        extractOutputScheme(rtab); // see BaseCalc.java

        surfaceAreas = vgrid.getExposedAreas();

        // WK 6 18 2007
        submembranes = vgrid.getSubmembranes();
        regionLabels = vgrid.getRegionLabels();
        // WK

        fdiff = rtab.getDiffusionConstants();
        lnfdiff = ArrayUtil.log(fdiff, -999.);

        neighbors = vgrid.getPerElementNeighbors();
        couplingConstants = vgrid.getPerElementCouplingConstants();
        lnCC = ArrayUtil.log(couplingConstants, -999.);

        stimTab = getStimulationTable();
        stimtargets = vgrid.getAreaIndexes(stimTab.getTargetIDs());

        // workspace for the calculation
        wkA = new int[nel][nspec];
        wkB = new int[nel][nspec];
        wkReac = new int[nreaction];

        eltregions = vgrid.getRegionIndexes();
        double[][] regcon = getRegionConcentrations();
        double[][] regsd = getRegionSurfaceDensities();

        // apply initial conditions over the grid
        for (int i = 0; i < nel; i++) {
            double v = volumes[i];
            double[] rcs = regcon[eltregions[i]];

            for (int j = 0; j < nspec; j++) {
                double rnp = v * rcs[j] * PARTICLES_PUVC;
                int irnp = (int) rnp;
                double drnp = rnp - irnp;

                // random allocation to implement the remainder of the
                // density (some cells get an extra particle, some dont)
                if (random.random() < drnp) {
                    irnp += 1;
                }
                wkA[i][j] = irnp;
                wkB[i][j] = irnp;
            }

            double a = surfaceAreas[i];
            double[] scs = regsd[eltregions[i]];
            if (a > 0 && scs != null) {
                for (int j = 0; j < nspec; j++) {
                    if (Double.isNaN(scs[j])) {
                        // means not specified by the user;

                    } else {
                        wkA[i][j] = 0;
                        wkB[i][j] = 0;

                        double rnp = a * scs[j] * PARTICLES_PUASD;
                        int irnp = (int) rnp;
                        double drnp = rnp - irnp;

                        // random allocation to implement the remainder of the
                        // density (some cells get an extra particle, some dont)
                        if (random.random() < drnp) {
                            irnp += 1;
                        }
                        wkA[i][j] += irnp;
                        wkB[i][j] += irnp;
                    }
                }

            }

            /*
             * if (i % 20 == 0) { E.info("elt " + i + " region " + eltregions[i]
             * + " n0 " + wkA[i][0]); }
             */
        }

        if (sdRun.initialStateFile != null) {
            double[][] cc = readInitialState(sdRun.initialStateFile, nel, nspec, speciesIDs);
            if (cc != null) {
                for (int i = 0; i < nel; i++) {
                    for (int j = 0; j < nspec; j++) {
                        int np = (int) Math.round(cc[i][j] * volumes[i] / CONC_OF_N);
                        wkA[i][j] = np;
                        wkB[i][j] = np;
                    }
                }
            }
        }

        dt = sdRun.fixedStepDt;
        lndt = Math.log(dt);

        // take logs of integers once only and store;
        intlogs = new double[10000];
        intlogs[0] = -99;
        for (int i = 1; i < intlogs.length; i++) {
            intlogs[i] = Math.log(i);
        }

        // final things we need is something to generate particle numbers
        // for steps of given n, p
        if (useBinomial())
            interpSG = InterpolatingStepGenerator.getBinomialGenerator();
        else if (usePoisson()) {
            interpSG = InterpolatingStepGenerator.getPoissonGenerator();
        } else {
            E.error("unknown probability distribution");
        }

        if (doShared() || doParticle() || doIndependent()) {
            if (doShared()) {
                E.info("Using SHARED destination allocation");
            } else {
                E.info("Using PER PARTICLE destination allocation");
            }
            lnpSharedOut = new double[nel][nspec];
            pSharedOut = new double[nel][nspec];
            fSharedExit = new double[nel][nspec][];

            int maxnn = 0;
            for (int iel = 0; iel < nel; iel++) {
                for (int k = 0; k < nspec; k++) {
                    int nn = neighbors[iel].length;
                    fSharedExit[iel][k] = new double[nn];
                    if (nn > maxnn) {
                        maxnn = nn;
                    }
                }
            }
            E.info("max no of neighbors for a single element is " + maxnn);

            for (int iel = 0; iel < nel; iel++) {
                for (int k = 0; k < nspec; k++) {
                    int inbr[] = neighbors[iel];
                    double lngnbr[] = lnCC[iel];
                    int nnbr = inbr.length;
                    // int np0 = wkA[iel][k];

                    double ptot = 0.;
                    double[] pcnbr = new double[nnbr];

                    for (int j = 0; j < nnbr; j++) {
                        double lnpgo = lnfdiff[k] + lngnbr[j] + lndt - lnvolumes[iel];
                        // probability is dt * K_diff * contact_area /
                        // (center_to_center_distance * source_volume)
                        // gnbr contains the gometry: contact_area / distance

                        double p = Math.exp(lnpgo);
                        ptot += p;
                        pcnbr[j] = ptot;
                    }

                    double lnptot = Math.log(ptot);
                    if (lnptot > -1.) {
                        // WK 9 11 2007
                        System.out.println("WK===================================");
                        System.out.println("In DIFFUSION: probability TOO HIGH!");
                        System.out.println("Reduce your timestep, and try again...");
                        System.out.println("WK====================================");
                        System.exit(0);

                        /*
                         * if (nwarn < 4) {
                         * E.shortWarning("p too large at element " + iel +
                         * " species " + k + " - capping from " +
                         * Math.exp(lnptot) + " to " + Math.exp(-1.)); nwarn++;
                         * } lnptot= -1.;
                         */
                        // WK
                    }

                    pSharedOut[iel][k] = ptot;
                    lnpSharedOut[iel][k] = lnptot;
                    for (int j = 0; j < nnbr; j++) {
                        fSharedExit[iel][k][j] = pcnbr[j] / ptot;
                    }
                }
            }
        }
    }

    @SuppressWarnings("boxing")
    private String getGridConcsText(double time) {
        StringBuffer sb = new StringBuffer();
        // TODO tag specific to integer quantities;
        int nspecout = ispecout.length;
        if (nspecout == 0) {
            return "";
        }

        sb.append("gridConcentrations " + nel + " " + nspecout + " " + time + " ");
        for (int i = 0; i < nspecout; i++) {
            sb.append(specieIDs[ispecout[i]] + " ");
        }
        sb.append("\n");

        for (int i = 0; i < nel; i++) {
            for (int j = 0; j < nspecout; j++) {
                if (writeConcentration) {
                    sb.append(stringd((CONC_OF_N * wkA[i][ispecout[j]] / volumes[i])));

                } else {
                    sb.append(stringi(wkA[i][ispecout[j]]));
                }
            }
            sb.append("\n");
        }
        return sb.toString();
    }

    private String getGridConcsPlainText_dumb(int filenum, double time) {
        StringBuffer sb = new StringBuffer();
        sb.append(stringd(time));

        for (int j = 0; j < specIndexesOut[filenum].length; j++) {
            for (int i = 0; i < nel; i++) {
                if (regionsOut[filenum].equals("default") || regionsOut[filenum].equals(regionLabels[eltregions[i]])) {

                    int npart = wkA[i][specIndexesOut[filenum][j]];
                    if (writeConcentration) {
                        sb.append(stringd((CONC_OF_N * npart / volumes[i])));
                    } else {
                        sb.append(stringi(npart));
                    }
                }
            }
        }
        sb.append("\n");

        return sb.toString();
    }

    @SuppressWarnings("boxing")
    private String getStateText() {
        StringBuffer sb = new StringBuffer();
        sb.append("nrds " + nel + " " + specieIDs.length + "\n");
        for (int i = 0; i < specieIDs.length; i++) {
            sb.append(specieIDs[i] + " ");
        }
        sb.append("\n");
        for (int i = 0; i < nel; i++) {
            for (int j = 0; j < specieIDs.length; j++) {
                sb.append(stringd((CONC_OF_N * wkA[i][j] / volumes[i])));
            }
            sb.append("\n");
        }
        return sb.toString();
    }



    public final int run() {
        init();

        if (resultWriter != null) {
]]>
</codefragment>
</duplication>
<duplication lines="307" tokens="1386">
<file line="544" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.java"/>
<file line="465" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/tmp/Tmp1A.java"/>
<codefragment>
<![CDATA[
                resultWriter.writeToFinalSiblingFile(getStateText(), sdRun.stateSavePrefix + Math.round(time) + ".nrds");
                stateSaveTime += sdRun.getStateSaveInterval();
            }
        }

        long endTime = System.currentTimeMillis();
        E.info("total time " + (endTime - startTime) + "ms");
        return 0;

    }

    // NB the following method is one of the only two that need optimizing
    // (the other is nGo in the interpolating step generator)
    // things to do (in the c version)
    // - use BLAS calls for array operations,
    // - remove the two remaining exps
    // - unwrap inner conditionals for different reaction types
    // - make nGo inlinable

    public double advance(double tnow) {

        // add in any injections
        double[][] stims = stimTab.getStimsForInterval(tnow, dt);
        for (int i = 0; i < stims.length; i++) {
            double[] astim = stims[i];
            for (int j = 0; j < astim.length; j++) {
                if (astim[j] > 0.) {
                    // the stimulus could be spread over a number of elements
                    // as yet, assume equal probability of entering any of these
                    // elements (TODO)
                    // the random < asr ensures we get the right number of
                    // particles even the average entry per volume is less than
                    // one
                    // TODO - allow stim type (deterministic or poisson etc) in
                    // config;

                    int nk = stimtargets[i].length;
                    if (nk > 0) {
                        double as = astim[j] / nk;
                        int ias = (int) as;
                        double asr = as - ((int) as);

                        for (int k = 0; k < nk; k++) {
                            int nin = (ias + (random.random() < asr ? 1 : 0));
                            ninjected += nin;

                            wkA[stimtargets[i][k]][j] += nin;
                        }
                    }
                }
            }
        }

        // initialize wkB to the current values.
        // It will hold the midstep values for the leapfrog, after diffusion
        // but before reactions.
        for (int i = 0; i < nel; i++) {
            for (int j = 0; j < nspec; j++) {
                wkB[i][j] = wkA[i][j];
                // if (wkB[i][j] < 0)
                // System.out.println("ERROR - NEGATIVE POPULATION at volume_element "
                // + i + ", specie " + j);
                // E.error("ERROR - NEGATIVE POPULATION at volume_element " + i
                // + ", specie " + j);
            }
        }

        // diffusion step;
        for (int iel = 0; iel < nel; iel++) {

            for (int k = 0; k < nspec; k++) {
                if (lnfdiff[k] > -90) {

                    int np0 = wkA[iel][k];

                    if (np0 > 0) {

                        switch(algoID) {
                        case INDEPENDENT:
                            // WK 8 28 2007
                            // parallelDiffusionStep(iel, k);
                            parallelAndSharedDiffusionStep(iel, k);
                            // WK
                            break;
                        case SHARED:
                            // WK 9 11 2007
                            // sharedDiffusionStep(iel, k);
                            parallelAndSharedDiffusionStep(iel, k);
                            // WK
                            break;
                        case PARTICLE:
                            particleDiffusionStep(iel, k);
                            break;

                        default:
                            assert false;
                        }
                    }
                }
            }
        }

        // for the reaction step, the source array is wkB and the
        // destination is wkA
        for (int i = 0; i < nel; i++) {
            for (int j = 0; j < nspec; j++) {
                wkA[i][j] = wkB[i][j];
            }
        }

        // reaction step;
        for (int iel = 0; iel < nel; iel++) {
            double lnvol = lnvolumes[iel];

            // start and end quantities for each species in a single
            // volume
            int[] nstart = wkB[iel];
            int[] nend = wkA[iel];
            for (int isp = 0; isp < nspecie; isp++) {
                nend[isp] = nstart[isp];
            }

            for (int ireac = 0; ireac < nreaction; ireac++) {
                // total number of possible reactions is the number of
                // particles in the smallest reactant population

                int[] ri = reactantIndices[ireac];
                int[] pi = productIndices[ireac];

                int[] rs = reactantStochiometry[ireac];
                int[] ps = productStochiometry[ireac];

                double lnp = lnrates[ireac] + lndt;

                int n = nstart[ri[0]];

                if (ri[1] >= 0) {
                    int nk = nstart[ri[1]];

                    if (nk < n) {
                        lnp += intlog(n);
                        n = nk;
                    } else {
                        lnp += intlog(nk);
                    }
                    lnp -= lnvol;
                    lnp -= LN_PARTICLES_PUVC;
                }

                if (lnp > -1.) {
                    if (nwarn < 5) {
                        E.shortWarning("p too large at element " + iel + " reaction " + ireac + " capping from "
                                       + Math.exp(lnp) + " to " + " exp(-1.)");
                        nwarn++;
                    }
                    lnp = -1.;
                }

                if (n <= 0) {

                } else {
                    int ngo = 0;
                    if (n == 1) {
                        // TODO use table to get rid of exp
                        ngo = (random.random() < Math.exp(lnp) ? 1 : 0);
                    } else if (n < StepGenerator.NMAX_STOCHASTIC) {
                        ngo = interpSG.nGo(n, lnp, random.random());

                    } else {
                        if (useBinomial()) {
                            if (n * (Math.exp(lnp)) < NP) {
                                ngo = StepGenerator.gaussianStep(n, Math.exp(lnp), random.gaussian(), random.random(),
                                                                 random.poisson(n * (Math.exp(lnp))), NP);
                                if (ngo < 0) {
                                    ngo = 0;

                                    System.out.println("in advance (reaction), if (n*Math.exp(lnp)) < " + NP
                                                       + "): ngo is NEGATIVE.");
                                    System.out.println("ngo: " + ngo + " n: " + n + " Math.exp(lnp): " + Math.exp(lnp));
                                }
                            } else {
                                ngo = StepGenerator.gaussianStep(n, Math.exp(lnp), random.gaussian(), random.random());
                                if (ngo < 0) {
                                    ngo = 0;

                                    System.out.println("in advance (reaction), if (n*Math.exp(lnp)) >= " + NP
                                                       + "): ngo is NEGATIVE.");
                                    System.out.println("ngo: " + ngo + " n: " + n + " Math.exp(lnp): " + Math.exp(lnp));
                                }
                            }

                        } else {
                            ngo = StepGenerator.poissonStep(n, Math.exp(lnp), random.gaussian(), random.random());
                            if (ngo < 0) {
                                ngo = 0;

                                System.out.println("in advance (reaction), if not using binomial: ngo is NEGATIVE.");
                                System.out.println("ngo: " + ngo + " n: " + n + " Math.exp(lnp): " + Math.exp(lnp));
                            }
                        }
                    }
                    // WK 7 2 2008: if ngo is negative, exit.
                    // if (ngo < 0)
                    // {
                    // System.out.println("in advance: ngo is NEGATIVE. Exiting...");
                    // System.exit(0);
                    // }
                    // WK

                    // update the new quantities in npn;
                    int ri0 = ri[0];
                    int ri1 = ri[1];
                    int rs0 = rs[0];
                    int rs1 = rs[1];

                    int navail = nend[ri0] / rs[0];
                    // AB changed navail > nend[ri1] / rs1 to navail < nend[ri1]
                    // / rs1
                    if (ri1 >= 0 && navail > nend[ri1] / rs1) {

                        navail = nend[ri1] / rs1;
                    }
                    if (ngo > navail) {
                        // TODO as for diffusion, we've got more particles going
                        // than there actually are. Should regenerate all
                        // reactions on theis element
                        // or use a binomial to share them out
                        // or use a smaller timestep;

                        if (nwarn < 10) {
                            E.shortWarning("reaction " + ireac + " ran out of particles - need " + ngo + " but have "
                                           + navail);
                            nwarn++;
                        }

                        ngo = navail;

                    }

                    // WK 9 25 2007: setting inc/decrements (i.e., ngo*xxx) to
                    // zero explicitly
                    // to avoid floating point error
                    if (ngo == 0) {
                        int pi0 = pi[0];
                        int pi1 = pi[1];
                        nend[ri0] -= 0;
                        if (ri1 >= 0)
                            nend[ri1] -= 0;
                        nend[pi0] += 0;
                        if (pi1 >= 0)
                            nend[pi1] += 0;
                    } else {
                        // WK
                        nend[ri0] -= ngo * rs0;

                        if (ri1 >= 0) {
                            nend[ri1] -= ngo * rs1;
                        }
                        // WK 3/16/2010
                        if (nend[ri0] < 0) {
                            System.out.println("nend[ri0] is NEGATIVE!");
                        }
                        if (ri1 >= 0 && nend[ri1] < 0) {
                            System.out.println("nend[ri1] is NEGATIVE!");
                        }
                        // WK

                        int pi0 = pi[0];
                        int pi1 = pi[1];

                        nend[pi0] += ngo * ps[0];
                        if (pi1 >= 0) {
                            nend[pi1] += ngo * ps[1];
                        }
                    }

                    // TODO this "if (ri[1] >= 0)" business is not great
                    // it applies for the A+B->C case, where there is a
                    // second reactant. We could probably do better by
                    // unrolling the four cases into separate blocks according
                    // to the reaction type
                    // - a good case for code generation.
                }
            }
        }

        // now wkA contains the actual numbers again;
        return dt;
    }

    // WK 8 28 2007
    private final void parallelAndSharedDiffusionStep(int iel, int k) {
        int np0 = wkA[iel][k];
        int inbr[] = neighbors[iel];
        double[] fshare = fSharedExit[iel][k];

        int ngo = 0;
        int ngo_remaining = 0; // for independent diffusion step      ***KTB edit - this is number of molecules not yet diffused
        int num_molecules_diffused_so_far = 0;

        if (np0 == 1) {
            ngo = (random.random() < pSharedOut[iel][k] ? 1 : 0);
        } else if (np0 < StepGenerator.NMAX_STOCHASTIC) {
            ngo = interpSG.nGo(np0, Math.log(pSharedOut[iel][k]), random.random());

            if (ngo < 0) {
                System.out.println("in parallelAndSharedDiffusionStep 1st else: ngo is NEGATIVE. Exiting...");
]]>
</codefragment>
</duplication>
<duplication lines="218" tokens="1307">
<file line="972" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.java"/>
<file line="893" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/tmp/Tmp1A.java"/>
<codefragment>
<![CDATA[
                }
                // WK

                wkB[iel][k] -= ngo;
                wkB[inbr[j]][k] += ngo;
                ngo_remaining-=ngo;
            } //end of loop through all but last neighbor

            ngo = ngo_remaining;

            wkB[iel][k] -= ngo;
            wkB[inbr[inbr.length - 1]][k] += ngo;
            // WK 3/16/2010
            if (wkB[iel][k] < 0) {
                System.out.println("In INDEPENDENT DIFFUSION, wkB[iel][k] NEGATIVE!!!");
            }
            //

        }
    }

    // WK

    private final void parallelDiffusionStep(int iel, int k) {
        int inbr[] = neighbors[iel];
        double lngnbr[] = lnCC[iel];
        int nnbr = inbr.length;
        int np0 = wkA[iel][k];

        for (int j = 0; j < nnbr; j++) {
            // use logs here so the operations are all additions
            // and the compiler should be able to be clever

            double lnpgo = lnfdiff[k] + lngnbr[j] + lndt - lnvolumes[iel];
            // probability is dt * K_diff * contact_area /
            // (center_to_center_distance * source_volume)
            // gnbr contains the gometry: contact_area / distance

            if (lnpgo > -1.) {
                if (nwarn < 4) {
                    E.shortWarning("p too large at element " + iel + " transition " + j + " to  " + inbr[j]
                                   + " - capping " + Math.exp(lnpgo) + " coupling is " + lngnbr[j]);
                    nwarn++;
                }
                lnpgo = -1.;
            }

            int ngo = 0;
            if (np0 == 1) {
                // TODO - use table anyway - avoid exp!
                ngo = (random.random() < Math.exp(lnpgo) ? 1 : 0);
            } else if (np0 < StepGenerator.NMAX_STOCHASTIC) {
                ngo = interpSG.nGo(np0, lnpgo, random.random());
            } else {
                if (useBinomial()) {
                    if (np0 * (Math.exp(lnpgo)) >= 10) {
                        ngo = StepGenerator.gaussianStep(np0, Math.exp(lnpgo), random.gaussian(), random.random());
                    } else {
                        ngo = StepGenerator.gaussianStep(np0, Math.exp(lnpgo), random.gaussian(), random.random(),
                                                         random.poisson(np0 * (Math.exp(lnpgo))), NP);
                    }
                } else {
                    ngo = StepGenerator.poissonStep(np0, Math.exp(lnpgo), random.gaussian(), random.random());
                }
            }

            // System.out.println("iel j ngo " + iel + " " + j + " " + ngo + " "
            // + np0);

            if (ngo > wkB[iel][k]) {
                if (nwarn < 10) {
                    E.shortWarning("ran out of particles - curtailing last transition from " + ngo + " to "
                                   + wkB[iel][k] + " leaving point " + iel + " species " + k);
                } else if (nwarn == 10) {
                    E.info("Suppressing future warnings");
                }
                nwarn++;

                ngo = wkB[iel][k];
                // TODO probably worth flagging if this ever happens
                // it means your steps could be too large
                // MATH if it does happen, there is a consistent
                // bias in that the last exit is the one that
                // is curtailed. We should actually restart
                // this set of jumps and get new fluxes to all
                // neighbours
            }

            wkB[iel][k] -= ngo;
            wkB[inbr[j]][k] += ngo;
        }
    }

    private final void sharedDiffusionStep(int iel, int k) {

        int np0 = wkA[iel][k];
        int inbr[] = neighbors[iel];
        // int nnbr = inbr.length;
        double[] fshare = fSharedExit[iel][k];
        double lnptot = lnpSharedOut[iel][k];

        int ngo = 0;
        if (np0 == 1) {
            // TODO - use table anyway - avoid exp!
            ngo = (random.random() < Math.exp(lnptot) ? 1 : 0);

        } else if (np0 < StepGenerator.NMAX_STOCHASTIC) {
            ngo = interpSG.nGo(np0, lnptot, random.random());

        } else {
            if (useBinomial()) {
                ngo = StepGenerator.gaussianStep(np0, Math.exp(lnptot), random.gaussian(), random.random());
            } else {
                ngo = StepGenerator.poissonStep(np0, Math.exp(lnptot), random.gaussian(), random.random());
            }
        }

        wkB[iel][k] -= ngo;
        for (int i = 0; i < ngo; i++) {
            double r = random.random();
            int io = 0;
            while (r > fshare[io]) {
                io++;
            }
            wkB[inbr[io]][k] += 1;
        }
    }

    private final void particleDiffusionStep(int iel, int k) {
        int np0 = wkA[iel][k];
        int inbr[] = neighbors[iel];
        // int nnbr = inbr.length;
        double[] fshare = fSharedExit[iel][k];
        double ptot = pSharedOut[iel][k];

        for (int i = 0; i < np0; i++) {
            double r = random.random();

            if (r < ptot) {
                wkB[iel][k] -= 1;
                double fr = r / ptot;
                int io = 0;
                while (fr > fshare[io]) {
                    io++;
                }
                wkB[inbr[io]][k] += 1;
            }
        }
    }

    public final double intlog(int i) {
        double ret = 0.;
        if (i <= 0) {
            ret = -99.;
        } else {
            ret = (i < intlogs.length ? intlogs[i] : Math.log(i));
        }
        return ret;
    }

    public long getParticleCount() {
        long ret = 0;
        for (int i = 0; i < nel; i++) {
            for (int j = 0; j < nspec; j++) {
                ret += wkA[i][j];
            }
        }

        E.info("number injected = " + ninjected);
        return ret;
    }

    protected String getGridConcsHeadings_dumb(int filenum, VolumeGrid vgrid) {
        StringBuffer sb = new StringBuffer();

        sb.append("time");
        for (int j = 0; j < specIndexesOut[filenum].length; j++) {

            for (int i = 0; i < nel; i++) {

                // WK 6 17 2007
                if (regionsOut[filenum].equals("default") || regionsOut[filenum].equals(regionLabels[eltregions[i]])) {
                    sb.append(" Vol_" + i);
                    sb.append("_" + regionLabels[eltregions[i]]);

                    if (vgrid.getGroupID(i) != null) {
                        sb.append("." + vgrid.getGroupID(i));

                    } else if (vgrid.getLabel(i) != null) {
                        String tempLabel = vgrid.getLabel(i);
                        if (tempLabel.indexOf(".") > 0) {
                            sb.append("." + tempLabel.substring(0, tempLabel.indexOf(".")));
                        }
                    }
                    if (submembranes[i] == true) {
                        sb.append("_submembrane");
                    } else {
                        sb.append("_cytosol");
                    }
                    if (vgrid.getLabel(i) != null) {
                        String tempLabel = vgrid.getLabel(i);
                        if (tempLabel.indexOf(".") > 0) {
                            sb.append("_" + tempLabel.substring(tempLabel.indexOf(".") + 1, tempLabel.length()));
                        } else {
                            sb.append("_" + vgrid.getLabel(i));
                        }
                    }
                    // WK
                    sb.append("_Spc_" + specieIDs[specIndexesOut[filenum][j]]);

                }
            }
        }
        sb.append("\n");
        return sb.toString();
    }

}
]]>
</codefragment>
</duplication>
<duplication lines="133" tokens="909">
<file line="183" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/serial/xml/XMLWriter.java"/>
<file line="158" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/xml/XMLWriter.java"/>
<codefragment>
<![CDATA[
                appendObject(sbv, psk + "   ", null, listobj);
            }
        }


        sbv.append(psk);
        sbv.append("</" + tag + ">\n");
    }



    private void appendNV(StringBuffer sbv, String sk, String name, String value) {
        sbv.append(sk + "<" + name + ">");
        appendString(sbv, value);
        sbv.append("</" + name + ">\n");
    }


    private void appendNV(StringBuffer sbv, String sk, String name, boolean value) {
        sbv.append(sk + "<" + name + ">");
        sbv.append(value ? "1" : "0");
        sbv.append("</" + name + ">\n");
    }



    private void appendNV(StringBuffer sbv, String sk, String name, int value) {
        sbv.append(sk + "<" + name + ">");
        sbv.append("" + value);
        sbv.append("</" + name + ">\n");
    }


    private void appendNV(StringBuffer sbv, String sk, String name, double value) {
        sbv.append(sk + "<" + name + ">");
        sbv.append("" + value);
        sbv.append("</" + name + ">\n");
    }



    private void appendNV(StringBuffer sbv, String sk, String name, String[] value) {
        sbv.append(sk + "<" + name + ">\n");

        for (int i = 0; i < value.length; i++) {
            sbv.append(sk);
            sbv.append("   ");
            appendString(sbv, (value[i] != null ? value[i] : ""));
            sbv.append("\n");
        }
        sbv.append(sk + "</" + name + ">\n");
    }


    private void appendNV(StringBuffer sbv, String sk, String name, int[] value) {
        sbv.append(sk + "<" + name + ">");
        for (int i = 0; i < value.length; i++) {
            if (i % 16 == 0)
                sbv.append("\n" + sk + "   ");
            sbv.append(" " + value[i] + " ");
        }
        sbv.append("\n");
        sbv.append(sk + "</" + name + ">\n");
    }


    private void appendNV(StringBuffer sbv, String sk, String name, boolean[] value) {
        sbv.append(sk + "<" + name + ">\n" + sk + "  ");
        for (int i = 0; i < value.length; i++) {
            sbv.append(" " + (value[i] ? 1 : 0) + " ");
        }
        sbv.append("\n");
        sbv.append(sk + "</" + name + ">\n");
    }


    private void appendNV(StringBuffer sbv, String sk, String name, double[] value) {
        sbv.append(sk + "<" + name + ">");
        for (int i = 0; i < value.length; i++) {
            if (i % 4 == 0)
                sbv.append("\n" + sk + "   ");
            sbv.append(" " + value[i] + " ");
        }
        sbv.append("\n");
        sbv.append(sk + "</" + name + ">\n");
    }



    private void appendNV(StringBuffer sbv, String sk, String name, int[][] value) {
        sbv.append(sk + "<" + name + ">\n");
        for (int i = 0; i < value.length; i++) {
            sbv.append(sk);
            sbv.append("   <row>");
            int[] ii = value[i];
            for (int k = 0; k < ii.length; k++) {
                if (k % 16 == 0)
                    sbv.append("\n " + sk + "      ");
                sbv.append(" " + ii[k] + " ");
            }
            sbv.append("\n");
            sbv.append(sk);
            sbv.append("   ");
            sbv.append("</row>\n");
        }
        sbv.append(sk + "</" + name + ">\n");
    }



    private void appendNV(StringBuffer sbv, String sk, String name, double[][] value) {
        sbv.append(sk + "<" + name + ">\n");
        for (int i = 0; i < value.length; i++) {
            sbv.append(sk);
            sbv.append("   <row>");
            double[] ii = value[i];
            for (int k = 0; k < ii.length; k++) {
                if (k % 4 == 0)
                    sbv.append("\n " + sk + "      ");
                sbv.append(" " + ii[k] + " ");
            }
            sbv.append("\n");
            sbv.append(sk);
            sbv.append("   ");
            sbv.append("</row>\n");
        }
        sbv.append(sk + "</" + name + ">\n");

    }



    private void appendString(StringBuffer sbv, String sssin) {
]]>
</codefragment>
</duplication>
<duplication lines="189" tokens="868">
<file line="78" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/util/FileUtil.java"/>
<file line="80" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/util/FileUtil.java"/>
<codefragment>
<![CDATA[
                E.error("Cant read file " + f);
            }
        }
        return sdat;
    }



    public static boolean writeStringToFile(String sdat, File f) {
        String fnm = f.getName();
        boolean ok = false;
        if (f != null) {
            boolean dogz = (fnm.endsWith(".gz"));
            try {
                OutputStream fos = new FileOutputStream(f);
                if (dogz) {
                    fos = new GZIPOutputStream(fos);
                }
                OutputStreamWriter osw = new OutputStreamWriter(fos);

                osw.write(sdat, 0, sdat.length());
                osw.close();
                ok = true;

            } catch (IOException ex) {
                E.error("file writing error, trying to write file " + fnm);
                ex.printStackTrace();
            }
        }
        return ok;
    }



    public static String getRootName(File f) {
        String fnm = f.getName();
        String root = fnm.substring(0, fnm.lastIndexOf("."));
        return root;
    }



    public static void writeBytes(byte[] ba, File f) {
        writeByteArrayToFile(ba, f);
    }


    public static void writeByteArrayToFile(byte[] ba, File f) {
        if (f == null) {
            return;
        }
        try {
            OutputStream os = new BufferedOutputStream(new FileOutputStream(f));
            os.write(ba);
            os.flush();
        } catch (Exception e) {
            E.error("cant write byte array " + ba + " to " + f);
        }
    }



    public static void copyFile(File fsrc, File fdest) {
        if (fsrc.exists()) {
            try {
                InputStream in = new FileInputStream(fsrc);
                OutputStream out = new FileOutputStream(fdest);

                // Transfer bytes from in to out
                byte[] buf = new byte[1024];
                int len;
                while ((len = in.read(buf)) > 0) {
                    out.write(buf, 0, len);
                }
                in.close();
                out.close();
            } catch (Exception ex) {
                E.error("file copy exception");
            }

        } else {
            E.warning("copy - missing file " + fsrc);
        }
    }



    public static String findPath(File f, String name) {
        String ret = null;

        for (File fs : f.listFiles()) {
            if (fs.getName().equals(name)) {
                ret = "";
                break;
            }
        }

        if (ret == null) {
            for (File fd : f.listFiles()) {
                if (fd.isDirectory()) {
                    String s = findPath(fd, name);
                    if (s != null) {
                        if (s.equals("")) {
                            ret = fd.getName();
                        } else {
                            ret = fd.getName() + "/" + s;
                        }
                        break;
                    }
                }
            }
        }
        return ret;
    }



    public static String readFirstLine(File f) {

        String ret = null;
        if (f != null) {
            try {
                InputStream ins = new FileInputStream(f);
                InputStreamReader insr = new InputStreamReader(ins);
                BufferedReader fr = new BufferedReader(insr);
                ret = fr.readLine();
                fr.close();

            } catch (IOException ex) {
                E.error("file read error ");
                ex.printStackTrace();
            }
        }
        return ret;
    }



    public static String getRelativeDirectory(File ftgt, File rtFolder) {
        File fpar = ftgt.getParentFile();
        int ns = 0;

        String sret = null;

        while (fpar != null && !(fpar.equals(rtFolder))) {
            if (sret == null) {
                sret = fpar.getName();
            } else {
                sret = fpar.getName() + "/" + sret;
            }
            fpar = fpar.getParentFile();

            ns += 1;
            if (ns > 8) {
                E.error("too many steps trying to get relative files ? " + ftgt.getAbsolutePath() + " "
                        + rtFolder.getAbsolutePath());
                break;
            }
        }

        return sret;
    }


    // TODO make this smarter (or use GlobFileFilter from jakarta ORO ?)
    public static ArrayList<File> matchingFiles(String srcPattern) {
        ArrayList<File> ret = new ArrayList<File>();
        if (srcPattern.indexOf("*") < 0) {
            File fd = new File(srcPattern);
            if (fd.exists() && fd.isDirectory()) {
                for (File f : fd.listFiles()) {
                    ret.add(f);
                }
            }

        } else {
            int istar = srcPattern.indexOf("*");
            String sa = srcPattern.substring(0, istar);
            String sb = srcPattern.substring(istar + 1, srcPattern.length());
            File ftop = new File(sa);
            for (File fg : ftop.listFiles()) {
                File fp = new File(fg, sb);
                if (fp.exists()) {
                    ret.add(fp);
                }
            }
        }
        return ret;
    }
]]>
</codefragment>
</duplication>
<duplication lines="136" tokens="694">
<file line="220" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/serial/xml/XMLTokenizer.java"/>
<file line="224" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/xml/XMLTokenizer.java"/>
<codefragment>
<![CDATA[
                        int[] ipr = new int[3];
                        while (ipr[0] != ims || ipr[1] != ims || ipr[2] != iabc) {
                            itok = ntok(streamTokenizer);

                            if (streamTokenizer.ttype == StreamTokenizer.TT_WORD) {
                                svalue += streamTokenizer.sval + " ";
                            } else if (streamTokenizer.ttype == StreamTokenizer.TT_NUMBER) {
                                svalue += " " + streamTokenizer.nval;
                            }
                            if (streamTokenizer.sval != null && streamTokenizer.sval.endsWith("--")) {
                                ipr[1] = ims;
                                ipr[2] = ims;
                            } else {
                                ipr[0] = ipr[1];
                                ipr[1] = ipr[2];
                                ipr[2] = itok;
                            }
                        }
                        streamTokenizer.pushBack();
                    } else {
                        E.error("found <!- but not followed by -  at " + streamTokenizer.lineno());
                    }
                } else {
                    E.error("found <! but not followed by -  at " + streamTokenizer.lineno());
                }
                setStringValue(xmlt, svalue);


            } else if (sv.startsWith("/")) {
                xmlt.setType(XMLToken.CLOSE);
                setStringValue(xmlt, sv.substring(1, sv.length()));

            } else {
                if (sv.endsWith("/")) {
                    xmlt.setType(XMLToken.OPENCLOSE);
                    setStringValue(xmlt, sv.substring(0, sv.length() - 1));
                } else {
                    xmlt.setType(XMLToken.OPEN);
                    setStringValue(xmlt, sv);
                }
            }

            itok = ntok(streamTokenizer);
            if (itok == iabc) {
                // fine - end of tag;

            } else if (streamTokenizer.ttype == StreamTokenizer.TT_WORD) {
                String[] attNV = new String[160]; // EFF check eff
                int natt = 0;

                while (itok != iabc) {

                    if (streamTokenizer.ttype == StreamTokenizer.TT_WORD) {
                        if (streamTokenizer.sval.equals("/")) {
                            xmlt.setType(XMLToken.OPENCLOSE);

                        } else {
                            attNV[2 * natt] = streamTokenizer.sval;
                            itok = ntok(streamTokenizer);
                            if (itok == ieq) {
                                itok = ntok(streamTokenizer);

                                if (itok == iq) {
                                    attNV[2 * natt + 1] = streamTokenizer.sval;
                                    natt++;
                                } else {
                                    E.shortError("expecting quoted string " + " while reading atributes "
                                                 + "but got " + stok(itok) + " sval=" + streamTokenizer.sval
                                                 + " nval=" + streamTokenizer.nval);
                                    E.info("original string was " + srcString);
                                }
                            } else {
                                E.shortError("at " + streamTokenizer.lineno()
                                             + " expecting = while reading attributes " + "but got " + stok(itok)
                                             + " sval=" + streamTokenizer.sval + " nval=" + streamTokenizer.nval);
                                E.info("original string was " + srcString);
                            }
                        }
                    } else {
                        E.shortError("at line " + streamTokenizer.lineno()
                                     + " found non-word while reading attributes " + stok(itok)
                                     + "  item so far = " + this);
                        E.info("original string was " + srcString);
                    }
                    itok = ntok(streamTokenizer);
                }
                String[] sat = new String[2 * natt];
                for (int i = 0; i < 2 * natt; i++) {
                    sat[i] = attNV[i];
                }
                xmlt.setAttributes(sat);

            } else {
                E.error("expecting word " + stok(itok));

            }

        } else {
            // just return the token as a string;
            xmlt.setType(XMLToken.STRING);
            setStringValue(xmlt, stok(itok));

        }
        return xmlt;
    }



    private int ntok(StreamTokenizer st) {
        int itok = -1;
        try {
            itok = st.nextToken();
        } catch (IOException e) {
            err(" " + e);
            itok = -999;
        }

        /*
         * if (count < 20) { E.info("token " + count + " " + itok + " " + st.sval + " " +
         * st.nval); count += 1; }
         */

        return itok;
    }


    private String stok(int itok) {
        return "" + (char)itok;
    }


    private void err(String s) {
        System.out.println(s);
    }

}
]]>
</codefragment>
</duplication>
<duplication lines="134" tokens="672">
<file line="65" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/numeric/math/Matrix.java"/>
<file line="111" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/math/Matrix.java"/>
<codefragment>
<![CDATA[
        return m;
    }


    public void setDims(int d1, int d2) {
        n1 = d1;
        n2 = d2;
    }


    public void identise() {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                a[i][j] = 0.;
            }
            a[i][i] = 1.;
        }
    }


    public void randomise() {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                a[i][j] = Math.random();
            }
        }
    }


    public void zero() {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                a[i][j] = 0.;
            }
        }
    }



    public Matrix identity() {
        Matrix m = copy();
        m.identise();
        return m;
    }


    public Matrix random() {
        Matrix m = copy();
        m.randomise();
        return m;
    }



    public void add(double d) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                a[i][j] += d;
            }
        }
    }



    public static Matrix[] average(Matrix[] ma, Matrix[] mb, double f) {
        int n = ma.length;
        Matrix[] res = new Matrix[n];
        for (int i = 0; i < n; i++) {
            res[i] = average(ma[i], mb[i], f);
        }
        return res;
    }


    public static Matrix average(Matrix ma, Matrix mb, double f) {
        double g = 1. - f;
        int n = ma.n;
        Matrix res = new Matrix(n);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                res.a[i][j] = f * mb.a[i][j] + g * ma.a[i][j];
            }
        }
        return res;
    }



    public void add(Matrix m) {
        if (m.n != n) {
            Sp("incompativle dims in Matrix.mplyBy " + n + " " + m.n);

        } else {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    a[i][j] += m.a[i][j];
                }
            }
        }
    }


    public Matrix sum(Matrix m) {
        Matrix mr = copy();
        mr.zero();
        if (m.n != n) {
            Sp("incompativle dims in Matrix.mplyBy " + n + " " + m.n);

        } else {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    mr.a[i][j] = a[i][j] + m.a[i][j];
                }
            }
        }
        return mr;
    }


    public void mpyBy(double d) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                a[i][j] *= d;
            }
        }
    }


    public void mpyBy(Matrix m) {
        a = (prod(m)).a;
    }


    public Matrix prod(Matrix m) {
]]>
</codefragment>
</duplication>
<duplication lines="116" tokens="668">
<file line="298" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/numeric/math/Matrix.java"/>
<file line="392" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/math/Matrix.java"/>
<codefragment>
<![CDATA[
                m.a[i][j] = a[j][i];
            }
        }
        return m;
    }


    public double det() {
        Matrix t = copy();
        t.LU();
        double d = 1.0 * t.sign;
        for (int i = 0; i < n; i++) {
            d *= t.a[i][i];
        }
        return d;
    }



    public double[][] copyMat() {
        double[][] ar = new double[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                ar[i][j] = a[i][j];
            }
        }
        return ar;
    }



    public void LU() {
        int i, imax, j, k;
        double big, dum, sum, temp;
        double vv[] = new double[n];
        double TINY = 1.0e-20;

        sign = 1;

        imax = -1;
        for (i = 0; i < n; i++) {
            big = 0.0;
            for (j = 0; j < n; j++) {
                if ((temp = Math.abs(a[i][j])) > big) {
                    big = temp;
                }
            }
            if (big == 0.0) {
                Sp("Singular Matrix in routine LUDCMP");
            }
            vv[i] = 1.0 / big;
        }

        for (j = 0; j < n; j++) {
            for (i = 0; i < j; i++) {
                sum = a[i][j];
                for (k = 0; k < i; k++) {
                    sum -= a[i][k] * a[k][j];
                }
                a[i][j] = sum;
            }
            big = 0.0;
            for (i = j; i < n; i++) {
                sum = a[i][j];
                for (k = 0; k < j; k++) {
                    sum -= a[i][k] * a[k][j];
                }
                a[i][j] = sum;
                if ((dum = vv[i] * Math.abs(sum)) >= big) {
                    big = dum;
                    imax = i;
                }
            }
            if (j != imax) {
                for (k = 0; k < n; k++) {
                    dum = a[imax][k];
                    a[imax][k] = a[j][k];
                    a[j][k] = dum;
                }
                sign = -sign;
                vv[imax] = vv[j];
            }
            perm[j] = imax;
            if (a[j][j] == 0.0) {
                a[j][j] = TINY;
            }
            if (j != n) {
                dum = 1.0 / (a[j][j]);
                for (i = j + 1; i < n; i++) {
                    a[i][j] *= dum;
                }
            }
        }
    }



    public Matrix inverse() {
        Matrix t, r;
        t = copy();
        r = copy();
        t.LU();

        double[] c = new double[n];
        for (int j = 0; j < n; j++) {
            for (int i = 0; i < n; i++) {
                c[i] = 0.0;
            }
            c[j] = 1.0;
            t.lubksb(c);
            for (int i = 0; i < n; i++) {
                r.a[i][j] = c[i];
            }
        }
        return r;
    }
]]>
</codefragment>
</duplication>
<duplication lines="118" tokens="619">
<file line="104" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/interlish/reflect/Narrower.java"/>
<file line="103" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/xml/Narrower.java"/>
<codefragment>
<![CDATA[
            ArrayList<? extends Object> v = (ArrayList<? extends Object>)ob;
            int n = v.size();
            sret = new String[n];
            int iout = 0;
            for (Object sub : v) {
                sret[iout++] = (String)sub;
            }

        } else {
            err("ERROR - cant make string array from " + ob);
        }
        return sret;
    }


    public static double[] makeDoubleArray(Object ob) {
        double[] dret = null;
        if (ob instanceof double[]) {
            dret = (double[])ob;

        } else if (ob instanceof ArrayList) {
            ArrayList v = (ArrayList)ob;
            int n = v.size();
            dret = new double[n];
            int iout = 0;
            for (Object sub : v) {
                dret[iout++] = makeDouble(sub);
            }

        } else if (ob instanceof String) {
            dret = readDoubleArray((String)ob);

        } else if (ob != null) {
            dret = new double[1];
            dret[0] = makeDouble(ob);
        }
        return dret;
    }


    public static int[] makeIntArray(Object ob) {
        int[] iret = null;
        if (ob instanceof int[]) {
            iret = (int[])ob;

        } else if (ob instanceof ArrayList) {
            ArrayList v = (ArrayList)ob;
            int n = v.size();
            iret = new int[n];
            int iout = 0;
            for (Object sub : v) {
                iret[iout++] = makeInt(sub);
            }

            // MISSING following needs repeating for other array types
        } else if (ob instanceof String) {
            String sob = (String)ob;
            StringTokenizer st = new StringTokenizer(sob, " ,\n");
            int ntok = st.countTokens();

            iret = new int[ntok];
            for (int i = 0; i < iret.length; i++) {
                iret[i] = Integer.parseInt(st.nextToken());
            }

        } else if (ob != null) {
            iret = new int[1];
            iret[0] = makeInt(ob);
        }
        return iret;
    }



    public static boolean[] makeBooleanArray(Object ob) {
        boolean[] bret = null;
        if (ob instanceof ArrayList) {
            ArrayList v = (ArrayList)ob;
            int n = v.size();
            bret = new boolean[n];
            int iout = 0;
            for (Object sub : v) {
                bret[iout++] = makeBoolean(sub);
            }
        } else if (ob != null) {
            bret = new boolean[1];
            bret[0] = makeBoolean(ob);
        }
        return bret;
    }


    public static int makeInt(Object arg) throws NumberFormatException {
        int iret = 0;
        if (arg instanceof Integer) {
            iret = ((Integer)arg).intValue();

        } else if (arg instanceof Double) {
            iret = (int)(((Double)arg).doubleValue());

        } else if (arg instanceof String) {
            String s = (String)arg;
            if (s.equals("false")) {
                iret = 0;
            } else if (s.equals("true")) {
                iret = 1;
            } else {
                iret = parseInt((String)arg);
            }
        } else {
            err("cant make an int from " + arg + " " + arg.getClass());
        }
        return iret;
    }



    public static int parseInt(String sin) {
]]>
</codefragment>
</duplication>
<duplication lines="118" tokens="611">
<file line="85" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/serial/xml/XMLTokenizer.java"/>
<file line="86" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/xml/XMLTokenizer.java"/>
<codefragment>
<![CDATA[
        if (sv.startsWith("xyz")) {
            if (cdataHM != null && cdataHM.containsKey(sv)) {
                sv = cdataHM.get(sv);
            } else {
                E.warning("looks like a CDATA key, but not present? " + sv);
            }
        }

        xmlt.setStringValue(sv);
    }


    public int lineno() {
        return streamTokenizer.lineno();
    }


    public void initializeStreamTokenizer(StreamTokenizer st) {
        st.resetSyntax();
        st.eolIsSignificant(false);
        st.slashStarComments(false);
        st.slashSlashComments(false);
        st.lowerCaseMode(false);
        String slim = "AZaz09";
        st.wordChars(slim.charAt(0), slim.charAt(1));
        st.wordChars(slim.charAt(2), slim.charAt(3));
        st.wordChars(slim.charAt(4), slim.charAt(5));
        // st.wordChars(0x00A0, 0x00FF);


        String wsc = " \t\n";
        for (int i = 0; i < wsc.length(); i++) {
            int ic = wsc.charAt(i);
            st.whitespaceChars(ic, ic);
        }


        st.quoteChar(iq);

        String swc = "_/.:&;,()\'+-.[]{}$";
        for (int i = 0; i < swc.length(); i++) {
            int ic = swc.charAt(i);
            st.wordChars(ic, ic);
        }
    }


    public XMLToken nextToken() {
        XMLToken xmlt = new XMLToken();
        int itok = ntok(streamTokenizer);


        if (streamTokenizer.ttype == StreamTokenizer.TT_EOF) {
            xmlt.setType(XMLToken.NONE);


        } else if (itok == iq) {
            xmlt.setType(XMLToken.STRING);
            // quoted string;
            String sss = streamTokenizer.sval;
            setStringValue(xmlt, StringEncoder.xmlUnescape(sss));


        } else if (streamTokenizer.ttype == StreamTokenizer.TT_WORD) {
            xmlt.setType(XMLToken.STRING);
            setStringValue(xmlt, StringEncoder.xmlUnescape(streamTokenizer.sval));

        } else if (streamTokenizer.ttype == StreamTokenizer.TT_NUMBER) {
            xmlt.setType(XMLToken.NUMBER);
            // boolean, int or double, all as doubles;
            double d = streamTokenizer.nval;
            ntok(streamTokenizer);
            if (streamTokenizer.ttype == StreamTokenizer.TT_WORD
                    && ((streamTokenizer.sval).startsWith("E-")
                        || (streamTokenizer.sval).startsWith("E+") || (streamTokenizer.sval).startsWith("E"))) { // POSERR
                // -
                // catches
                // wrong
                // things?

                String s = streamTokenizer.sval.substring(1, streamTokenizer.sval.length());
                int ppp = Integer.parseInt(s);
                // err ("st.sval " + st.sval);
                // err ("read exponent: " + ppp);
                d *= Math.pow(10., ppp);
            } else {
                streamTokenizer.pushBack();
            }
            xmlt.setDValue(d);


        } else if (itok == iabo) {
            itok = ntok(streamTokenizer);
            String sv = streamTokenizer.sval;

            if (itok == iqm) {
                // should be the first line of a file - read on until
                // the next question mark, just keeping the text in sinfo
                // for now;
                xmlt.setType(XMLToken.INTRO);
                String svalue = "";
                itok = -1;
                while (itok != iqm) {
                    itok = ntok(streamTokenizer);
                    if (streamTokenizer.sval != null)
                        svalue += streamTokenizer.sval + " ";
                }
                setStringValue(xmlt, svalue);

            } else if (itok == iexc) {
                itok = ntok(streamTokenizer);
                String sval = streamTokenizer.sval;

                String svalue = "";
                if (sval != null && sval.startsWith("[CDATA[")) {
                    E.error("shouldn't get CDATA in xml tokenizer");

                } else if (sval != null && sval.startsWith("--")) {
]]>
</codefragment>
</duplication>
<duplication lines="162" tokens="575">
<file line="12" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/swing/RolloverEffect.java"/>
<file line="12" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/graph/gui/RolloverEffect.java"/>
<codefragment>
<![CDATA[
public class RolloverEffect extends MouseAdapter {

    JComponent button;

    int inormal;
    int iactive;

    Border normalBorder;
    Border activeBorder;

    public final static int NONE = 0;
    public final static int ETCHED_DOWN = 1;
    public final static int ETCHED_UP = 2;
    public final static int RAISED = 2;

    Color bgColor;

    int pL;
    int pR;
    int pT;
    int pB;

    private boolean hasPadding;

    public RolloverEffect(JComponent buttonIn) {
        this(buttonIn, ETCHED_DOWN, ETCHED_UP);
    }



    public RolloverEffect(JComponent buttonIn, int norm, int active) {
        hasPadding = false;
        bgColor = buttonIn.getBackground();

        inormal = norm;
        iactive = active;

        button = buttonIn;


        makeBorders();


        if (button instanceof AbstractButton) {
            ((AbstractButton)button).setBorderPainted(true);

        } else if (button instanceof JMenu) {
            ((JMenu)button).setBorderPainted(true);

        } else if (button instanceof JCheckBox) {
            ((JCheckBox)button).setBorderPainted(true);

        } else if (button instanceof JPanel) {
            // ((JPanel)button).setBorderPainted(true);
        }

        mouseExited(null);

    }




    public void setPadding(int p) {
        setPadding(p, p, p, p);
    }


    public void setPadding(int pl, int pr, int pt, int pb) {
        pL = pl;
        pR = pr;
        pT  = pt;
        pB = pb;
        hasPadding = true;
        makeBorders();
        mouseExited(null);
    }


    public void setBg(Color c) {
        bgColor = c;
        makeBorders();
        mouseExited(null);
    }





    public void makeBorders() {
        normalBorder = makeBorder(inormal);
        activeBorder = makeBorder(iactive);
    }



    public void mouseEntered(MouseEvent me) {
        button.setBorder(activeBorder);
    }


    public void mouseExited(MouseEvent me) {
        button.setBorder(normalBorder);
    }


    private Border makeBorder(int type) {
        Color c = bgColor;
        Color cbr = myBrighter(c);
        Color cdk = myDarker(c);


        Border ret = null;
        if (type == ETCHED_DOWN) {
            // ret = BorderFactory.createEtchedBorder(EtchedBorder.LOWERED);
            ret = BorderFactory.createEtchedBorder(cbr, cdk);

        } else if (type == ETCHED_UP) {
            // ret = BorderFactory.createEtchedBorder(EtchedBorder.RAISED);
            ret = BorderFactory.createEtchedBorder(cdk, cbr);
        } else {
            ret = BorderFactory.createEmptyBorder(2, 2, 2, 2);
        }


        if (hasPadding) {
            Border bdr = BorderFactory.createEmptyBorder(pT, pL, pB, pR);
            ret = BorderFactory.createCompoundBorder(ret, bdr);
        }
        return ret;
    }


    public static Color myBrighter(Color c) {
        return linMod(c, 35);
    }


    public static Color myDarker(Color c) {
        return linMod(c, -35);
    }


    public static Color linMod(Color c, int d) {
        int r = c.getRed();
        int g = c.getGreen();
        int b = c.getBlue();

        r += d;
        g += d;
        b += d;
        r = (r > 0 ? (r < 255 ? r : 255) : 0);
        g = (g > 0 ? (g < 255 ? g : 255) : 0);
        b = (b > 0 ? (b < 255 ? b : 255) : 0);
        return new Color(r, g, b);
    }





}
]]>
</codefragment>
</duplication>
<duplication lines="106" tokens="570">
<file line="223" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/interlish/reflect/Narrower.java"/>
<file line="221" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/xml/Narrower.java"/>
<codefragment>
<![CDATA[
        int iret = 0;
        if (s.startsWith("0x")) {
            s = s.substring(2, s.length());
            iret = Integer.parseInt(s, 16);
        } else {
            iret = Integer.parseInt(s, 10);
        }
        return iret;
    }



    public static double makeDouble(Object arg) {
        double dret = 0;
        if (arg instanceof Double) {
            dret = ((Double)arg).doubleValue();

        } else if (arg instanceof String) {
            dret = parseDouble((String)arg);

        } else {
            err(" cant make a double from " + arg + " " + arg.getClass());
            (new Exception()).printStackTrace();
        }
        return dret;
    }


    public static boolean makeBoolean(Object arg) {
        boolean bret = false;
        if (arg instanceof Double) {
            bret = ((((Double)arg).doubleValue()) > 0.5);

        } else if (arg instanceof String) {
            String sob = ((String)arg).trim();
            bret = (sob.equals("1") || sob.equals("true"));
        } else {
            err(" instantiator cant make a boolean from " + arg);
        }
        return bret;
    }



    public static double[][] makeDDArray(Object ob) {
        double[][] dret = null;
        if (ob == null) {
            dret = new double[0][0];

        } else if (ob instanceof Double || ob instanceof String) {
            dret = new double[1][1];
            dret[0][0] = makeDouble(ob);

        } else if (ob instanceof ArrayList) {
            ArrayList v = (ArrayList)ob;
            dret = new double[v.size()][];
            int iout = 0;
            for (Object sub : v) {
                dret[iout++] = makeDoubleArray(sub);
            }
        } else {
            err("cant make DD array from " + ob);
        }
        return dret;
    }


    public static int[][] makeIIArray(Object ob) {
        int[][] iret = null;
        if (ob == null) {
            iret = new int[0][0];

        } else if (ob instanceof Double || ob instanceof String) {
            iret = new int[1][1];
            iret[0][0] = makeInt(ob);

        } else if (ob instanceof ArrayList) {
            ArrayList v = (ArrayList)ob;
            iret = new int[v.size()][];
            int iout = 0;
            for (Object sub : v) {
                iret[iout++] = makeIntArray(sub);
            }
        } else {
            err("cant make II array from " + ob);
        }
        return iret;
    }


    public static ArrayList<Object> makeArrayList(Object arg) {
        ArrayList<Object> vret = new ArrayList<Object>();

        if (arg instanceof ArrayList<?>) {
            vret.addAll((ArrayList<?>)arg);

        } else {
            vret.add(arg);
        }
        return vret;
    }




    public static double[] readDoubleArray(String sin) {
]]>
</codefragment>
</duplication>
<duplication lines="73" tokens="471">
<file line="103" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/serial/xml/XMLWriter.java"/>
<file line="76" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/xml/XMLWriter.java"/>
<codefragment>
<![CDATA[
        }

        String tag = "error";
        if (knownAs != null) {
            tag = knownAs;
        } else {
            tag = ob.getClass().getName();

            if (conciseTags) {
                int ilast = tag.lastIndexOf(".");
                if (ilast >= 0) {
                    tag = tag.substring(ilast + 1, tag.length());
                }
            }
        }

        sbv.append(psk);
        sbv.append("<" + tag + ">\n");

        /*
         * if (writeClass) { sbv.append("<"+tag + " class=\"" +
         * ob.getClass().getName() + "\">\n"); } else { sbv.append("<"+tag +
         * ">\n"); }
         */


        String sk = psk + "   ";

        Field[] flds = ob.getClass().getFields();

        for (int i = 0; i < flds.length; i++) {
            String fieldName = flds[i].getName();
            Object ret = null;
            try {
                ret = flds[i].get(ob);
            } catch (Exception e) {
                err("WARNING - failed to get field " + fieldName + " in  " + ob);
            }
            if (Modifier.isFinal(flds[i].getModifiers()))
                ret = null;

            if (ret instanceof Double) {
                appendNV(sbv, sk, fieldName, ((Double)ret).doubleValue());

            } else if (ret instanceof Integer) {
                appendNV(sbv, sk, fieldName, ((Integer)ret).intValue());

            } else if (ret instanceof Boolean) {
                appendNV(sbv, sk, fieldName, ((Boolean)ret).booleanValue());

            } else if (ret instanceof String) {
                appendNV(sbv, sk, fieldName, (String)ret);

            } else if (ret instanceof double[]) {
                appendNV(sbv, sk, fieldName, (double[])ret);

            } else if (ret instanceof int[]) {
                appendNV(sbv, sk, fieldName, (int[])ret);

            } else if (ret instanceof boolean[]) {
                appendNV(sbv, sk, fieldName, (boolean[])ret);

            } else if (ret instanceof String[]) {
                appendNV(sbv, sk, fieldName, (String[])ret);

            } else if (ret instanceof double[][]) {
                appendNV(sbv, sk, fieldName, (double[][])ret);

            } else if (ret instanceof int[][]) {
                appendNV(sbv, sk, fieldName, (int[][])ret);

            } else if (ret != null) {
                appendObject(sbv, sk, fieldName, ret);
]]>
</codefragment>
</duplication>
<duplication lines="103" tokens="468">
<file line="486" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/numeric/math/Matrix.java"/>
<file line="593" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/math/Matrix.java"/>
<codefragment>
<![CDATA[
            for (int j = 0; j < n; j++) {
                sa[i] += (" " + a[i][j]);
            }
        }
        Sp(" n1: " + n1 + " n2: " + n2);
        for (int i = 0; i < sa.length; i++) {
            Sp("" + i + " " + sa[i]);
        }
    }



    public double maxAbsElt() {
        double d = 0.0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (Math.abs(a[i][j]) > d) {
                    d = Math.abs(a[i][j]);
                }
            }
        }
        return d;
    }



    public Matrix power(int p) {
        Matrix mr = identity();
        int pg = 0;
        int pl = 1;
        Matrix mp = copy();
        while (pg < p) {
            if ((p & pl) > 0) {
                pg += pl;
                mr = mr.prod(mp);
            }
            pl *= 2;
            mp = mp.prod(mp);
        }
        if (pg != p) {
            Sp("got Matrix power wrong: " + p + " " + pg + " " + pl);
        }
        return mr;
    }


    public Matrix crudeExpOf(double t) {
        Matrix m = copy();
        m.mpyBy(t);
        double eps = 1.0e-8;

        double d = m.maxAbsElt();
        int p = 0;
        double f = 1;
        for (p = 0; d * f > eps; f *= 0.5, p++) {
            ;
        }

        m.mpyBy(f);
        m.add(m.identity());

        for (; p > 0; p--) {
            m.mpyBy(m);
        }
        return m;
    }



    public Matrix expOf(double t) {
        Matrix m = copy();
        m.mpyBy(t);
        double eps = 1.0e-12;

        double d = m.maxAbsElt();
        int p = 0;
        double f = 1;
        for (p = 0; d * f > eps; f *= 0.5, p++) {
            ;
        }

        m.mpyBy(f);
        // now we want to calculate (I + m)^p
        // without doing the obvious

        for (; p > 0; p--) {
            Matrix u = m.copy();
            u.mpyBy(u);
            m.add(m);
            m.add(u);
        }
        m.add(m.identity());
        return m;
    }



    public int randomIndexFromColumn(int c) {
        return randomIndexFromColumn(c, Math.random());
    }


    public final int randomIndexFromColumn(int c, double rin) {
]]>
</codefragment>
</duplication>
<duplication lines="130" tokens="423">
<file line="8" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/serial/xml/XMLToken.java"/>
<file line="5" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/xml/XMLToken.java"/>
<codefragment>
<![CDATA[
public class XMLToken {

    final static int NONE = 0;
    final static int OPEN = 1;
    final static int CLOSE = 2;

    final static int NUMBER = 3;
    final static int STRING = 4;

    final static int OPENCLOSE = 5;

    final static int INTRO = 6;
    final static int COMMENT = 7;


    String[] types = {"NONE", "OPEN", "CLOSE", "NUMBER", "STRING",
                      "OPENCLOSE", "INTRO", "COMMENT"
                     };


    int type;

    String svalue;
    double dvalue;

    int natt;
    String[] attNV;



    public XMLToken() {
        type = NONE;
    }

    /*
    public String toString() {
       String sr = ("XMLToken type=" + type + " sv=" + svalue + " dv=" + dvalue +
    	   " natt=" + natt);
       for (int i = 0; i < natt; i++) {
     sr += "   att[" + i + "]:" + attNV[i] + "\n";
       }
       return sr;
    }
    */


    public boolean isOpen() {
        return (type == OPEN || type == OPENCLOSE);
    }

    public boolean isClose() {
        return (type == OPENCLOSE || type == CLOSE);
    }

    public boolean isNumber() {
        return (type == NUMBER);
    }

    public boolean isString() {
        return (type == STRING);
    }

    public boolean isNone() {
        return (type == NONE);
    }

    public boolean isIntro() {
        return (type == INTRO);
    }

    public boolean isComment() {
        return (type == COMMENT);
    }



    public String toString() {
        String s = types[type] + " " ;
        if (type == OPEN ||
                type == STRING ||
                type == INTRO ||
                type == COMMENT ||
                type == CLOSE ||
                type == OPENCLOSE) {
            s += svalue;

            if (type == OPEN || type==OPENCLOSE) {
                if (natt > 0) {
                    for (int i = 0; i < natt; i++) {
                        s += "\n    " + attNV[2*i] + "=" + attNV[2*i+1];
                    }
                }
            }
        } else if (type == NUMBER) {
            s += " " + dvalue;
        }
        return s;
    }

    public void setType(int itype) {
        type = itype;
    }


    public void setStringValue(String s) {
        svalue = s;
    }


    public void setDValue(double d) {
        dvalue = d;
    }


    public void setAttributes(String[] sa) {
        attNV = sa;
        natt = sa.length / 2;
    }



    public boolean hasAttribute(String sat) {
        boolean bret = false;
        for (int i = 0; i < natt; i++) {
            if (attNV[2*i].equals(sat)) bret = true;
        }
        return bret;
    }

    public Attribute[] getAttributes() {
]]>
</codefragment>
</duplication>
<duplication lines="66" tokens="380">
<file line="230" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/numeric/math/Matrix.java"/>
<file line="325" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/math/Matrix.java"/>
<codefragment>
<![CDATA[
    }


    public double[] rvprod(double[] v) {
        double[] r = new double[n];
        if (v.length != n) {
            Sp("incompatible dimensions in lvprod");
        } else {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    r[i] += a[i][j] * v[j];
                }
            }
        }
        return r;
    }



    public void multiplyInto(double[] v) {
        for (int i = 0; i < n; i++) {
            ws[i] = 0.;
            for (int j = 0; j < n; j++) {
                ws[i] += a[i][j] * v[j];
            }
        }
        for (int i = 0; i < n; i++) {
            v[i] = ws[i];
        }
    }


    public void rect2rvprod(double[] v, double[] r1, double[] r2) {
        for (int i = 0; i < n1; i++) {
            ws[i] = 0.0;
            for (int j = 0; j < n1; j++) {
                ws[i] += a[i][j] * v[j];
            }
        }

        for (int i = 0; i < n2 - n1; i++) {
            r2[i] = 0.0;
            for (int j = 0; j < n1; j++) {
                r2[i] += a[i + n1][j] * v[j];
            }
        }
        for (int i = 0; i < n1; i++) {
            r1[i] = ws[i];
        }


    }



    public double rvprodOneElt(double[] v, int elt) {
        double r = 0.0;
        for (int j = 0; j < n; j++) {
            r += a[elt][j] * v[j];
        }
        return r;
    }


    public Matrix transpose() {
        Matrix m = copy();
]]>
</codefragment>
</duplication>
<duplication lines="100" tokens="367">
<file line="142" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/interlish/reflect/ReflectionConstructor.java"/>
<file line="114" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/xml/ReflectionInstantiator.java"/>
<codefragment>
<![CDATA[
            for (int i = 0; i < npkg; i++) {
                E.info("tried package " + pkgs[i]);
            }

            if (scl.endsWith("ing")) {
                (new Exception()).printStackTrace();
            }


        } else {
            int imod = c.getModifiers();
            if (Modifier.isAbstract(imod)) {
                E.error("cant instantiatie " + c + ":  it is an abstract class");
            } else {

                try {
                    oret = c.newInstance();
                } catch (Exception e) {
                    E.error(" " + e + " instantiating " + c);
                    e.printStackTrace();
                }
            }
        }

        if (oret != null) {
            checkAddPackage(oret);
        }

        return oret;
    }



    public Object getField(Object ob, String fnm) {
        Object ret = null;

        boolean hasField = false;

        // EFF improve
        Field[] flds = ob.getClass().getFields();
        for (int i = 0; i < flds.length; i++) {
            if (flds[i].getName().equals(fnm)) {
                hasField = true;
                break;
            }
        }

        if (hasField) {
            try {
                Field f = ob.getClass().getField(fnm);

                Class fcl = f.getType();

                if (fcl.equals(String[].class)) {
                    ret = new String[0];

                } else if (fcl.isArray()) {
                    ret = new ArrayList(); // ADHOC - wrap ArrayList?
                } else {
                    ret = f.get(ob);
                }

                if (ret == null) {
                    Class<?> cl = f.getType();
                    ret = cl.newInstance();
                }

            } catch (Exception e) {
                E.error("cant get field " + fnm + " on " + ob + " " + "excception= " + e);
            }
        }


        /*
         * if (!hasField && ob instanceof FieldValueProvider) { ret =
         * ((FieldValueProvider)ob).getFieldValue(fnm); if (ret != null) {
         * hasField = true; } }
         */


        if (!hasField) {
            if (ob instanceof ArrayList) {
                // we're OK - the object will just be added;

            } else {

                // System.out.println("error - cant get field " + fnm + " on " +
                // ob);
                /*
                 * Field[] af = ob.getClass().getFields(); for (int i = 0; i <
                 * af.length; i++) { System.out.println("fld " + i + " " + af[i]); }
                 */
            }
        }
        return ret;
    }



    public Object getChildObject(Object parent, String name, Attribute[] attain) {
]]>
</codefragment>
</duplication>
<duplication lines="67" tokens="338">
<file line="12" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/util/FileUtil.java"/>
<file line="13" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/util/FileUtil.java"/>
<codefragment>
<![CDATA[
public abstract class FileUtil {



    public static byte[] readHeader(File f, int n) {
        byte[] ret = null;
        try {
            FileInputStream ins = new FileInputStream(f);
            ret = new byte[n];
            int nread = ins.read(ret);
            if (nread != n) {
                E.error("readNBytes wanted " + n + " but got " + nread);
            }
            ins.close();
        } catch (Exception ex) {
            E.error("readNBytes problem " + ex);
        }
        return ret;
    }



    public static byte[] readBytes(File f) {
        byte[] ret = null;
        try {
            FileInputStream fis = new FileInputStream(f);
            BufferedInputStream bis = new BufferedInputStream(fis);
            ByteArrayOutputStream baos = new ByteArrayOutputStream();

            byte[] bb = new byte[4096];
            int nread = bis.read(bb);
            while (nread > 0) {
                baos.write(bb, 0, nread);
                nread = bis.read(bb);
            }
            ret = baos.toByteArray();

        } catch (Exception ex) {
            E.error("readNBytes problem " + ex);
        }
        return ret;
    }



    public static String readStringFromFile(File f) {
        String sdat = "null";
        if (f != null) {
            try {
                boolean dogz = (f.getName().endsWith(".gz"));
                InputStream ins = new FileInputStream(f);
                if (dogz) {
                    ins = new GZIPInputStream(ins);
                }
                InputStreamReader insr = new InputStreamReader(ins);
                BufferedReader fr = new BufferedReader(insr);

                StringBuffer sb = new StringBuffer();
                while (fr.ready()) {
                    sb.append(fr.readLine());
                    sb.append("\n");
                }
                fr.close();
                sdat = sb.toString();

            } catch (IOException ex) {
                E.error("Cant read file " + f);
]]>
</codefragment>
</duplication>
<duplication lines="73" tokens="335">
<file line="13" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/morph/CuboidVolumeElement.java"/>
<file line="26" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/morph/CurvedVolumeElement.java"/>
<codefragment>
<![CDATA[
    public void setAlongArea(double d) {
        alongArea = d;

    }

    public double getAlongArea() {
        return alongArea;
    }

    public void setSideArea(double d) {
        sideArea = d;
    }
    public double getSideArea() {
        return sideArea;
    }


    public void setTopArea(double d) {
        topArea = d;
    }

    public double getTopArea() {
        return topArea;
    }



    public String getAsText() {
        StringBuffer sb = new StringBuffer();
        // export boundary if have it, ow just the center point;
        if (boundary != null) {
            for (Position p : boundary) {
                sb.append(String.format(" (%.5g %.5g %.5g) ", p.getX(), p.getY(), p.getZ()));
            }
        } else {
            sb.append(String.format(" (%.5g %.5g %.5g) ", cx, cy, cz));

        }
        return sb.toString();
    }

    @SuppressWarnings("boxing")
    public String getAsPlainText() {
        StringBuffer sb = new StringBuffer();
        // export boundary if have it, ow just the center point;
        if (boundary != null) {
            for (Position p : boundary) {
                sb.append(String.format(" %.5g %.5g %.5g", p.getX(), p.getY(), p.getZ()));
            }
        } else {
            sb.append(String.format(" %.5g %.5g %.5g", cx, cy, cz));
        }
        sb.append(String.format(" %.5g %.5g", volume, deltaZ));
        return sb.toString();
    }


    @SuppressWarnings("boxing")
    public String getHeadings() {
        StringBuffer sb = new StringBuffer();
        // export boundary if have it, ow just the center point;
        if (boundary != null) {
            for (int i = 0; i < boundary.length; i++) {
                sb.append(" x" + i + " y" + i + " z" + i);

            }
        } else {
            sb.append(" cx cy cz");

        }
        sb.append(" volume deltaZ");
        return sb.toString();
    }
]]>
</codefragment>
</duplication>
<duplication lines="59" tokens="304">
<file line="25" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/serial/xml/XMLTokenizer.java"/>
<file line="27" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/xml/XMLTokenizer.java"/>
<codefragment>
<![CDATA[
    static {
        String sord = "\"=<>?!-";
        iq = sord.charAt(0);
        ieq = sord.charAt(1);
        iabo = sord.charAt(2);
        iabc = sord.charAt(3);
        iqm = sord.charAt(4);
        iexc = sord.charAt(5);
        ims = sord.charAt(6);
    }



    HashMap<String, String> cdataHM;

    String srcString;

    public XMLTokenizer(String s) {
        // EFF remove this - just for debugging;
        srcString = extractCDATAs(s);


        streamTokenizer = new StreamTokenizer(new StringReader(srcString));
        initializeStreamTokenizer(streamTokenizer);
    }


    private String extractCDATAs(String src) {
        StringBuffer sret = new StringBuffer();
        int icur = 0;
        int iscd = src.indexOf("<![CDATA[");

        while (iscd >= icur) {
            sret.append(src.substring(icur, iscd));
            int iecd = src.indexOf("]]&gt;", iscd + 9);
            if (iecd >= 0) {
                String cdata = src.substring(iscd + 9, iecd);
                if (cdataHM == null) {
                    cdataHM = new HashMap<String, String>();
                }
                String rpl = "xyz" + cdataHM.size();
                cdataHM.put(rpl, cdata);
                sret.append(rpl);

            } else {
                iecd = iscd + 6;
                E.error("no closure of cdata beginning character " + iscd + "? ");
            }
            icur = iecd + 3;
            iscd = src.indexOf("<![CDATA[", icur);
        }
        if (icur < src.length()) {
            sret.append(src.substring(icur, src.length()));
        }
        return sret.toString();
    }


    private void setStringValue(XMLToken xmlt, String svin) {
]]>
</codefragment>
</duplication>
<duplication lines="97" tokens="300">
<file line="112" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/serial/xml/XMLReader.java"/>
<file line="105" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/xml/XMLReader.java"/>
<codefragment>
<![CDATA[
        }
        return xmlt;
    }



    public void readFieldIntoParent(XMLTokenizer tkz, Object parent, XMLToken start) {



        // read the child object that is known to the parent as item.name
        // if the parent is a vector, the object is added as a new element;
        // if the parent is a string, the xml is just apended;
        // otherwise the field is set.


        if (!start.isOpen()) {
            nerror++;
            err("ERROR - read object start item was not an open tag " + start);
            return;
        }


        Object child = null;

        if (parent instanceof String || parent instanceof StringBuffer) {
            child = new StringBuffer();
            ((StringBuffer)child).append(start.getOpenTagString());

        } else {

            // attributes may contain the class - the instantiator processes
            // all the attributes here
            Attribute[] atts = start.getAttributes();
            child = instantiator.getChildObject(parent, start.getName(), atts);
            if (child != null) {
                instantiator.applyAttributes(child, atts);
            }


            if (child == null) {
                child = new ArrayList();

            } else if (child instanceof String) {
                // in this case, set its length to 0. Subseqnet parts of the
                // string will get appended to the current value, so want to
                // keep track of the fact that it is a string, without keeping
                // the default that may have come from above;
                child = new StringBuffer();


            } else if (child.getClass().isArray()) {
                // make it an array list for the time being, then
                // give the lsit to teh instantiator to make into theright sort of
                // array;
                child = new ArrayList();
            }


            if (start.isClose()) {
                // the tag was both an open and a close tag, so now that we've
                // processed the attributes, we're done;


            } else {
                // read on and fill in fields until we get a closing tag which
                // matches the start tag
                // the fields will be inserted in target;

                XMLToken next = readToken(tkz);

                while (true) {
                    if (next.isNone()) {
                        // should mean EOF, but could also be an error
                        // return whatever;
                        break;


                    } else if (next.isOpen()) {
                        // open tags could mean anything - elementary field, array,
                        // or object, but in any case, pass them back to this method;
                        readFieldIntoParent(tkz, child, next);


                    } else if (next.isClose()) {
                        if (next.closes(start)) {
                            // fine - close item

                            if (parent instanceof String || parent instanceof StringBuffer) {
                                ((StringBuffer)child).append(next.getCloseTagString());
                            }


                        } else {
                            nerror++;
                            E.shortError(" non-matching close item \n" + "start Item was: \n"
                                         + start.toString() + "\n" + "but close was: \n" + next.toString() + "\n" +
]]>
</codefragment>
</duplication>
<duplication lines="84" tokens="298">
<file line="32" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/gui/edit/DruCheckboxListPanel.java"/>
<file line="27" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/gui/edit/DruToggleListPanel.java"/>
<codefragment>
<![CDATA[
    public DruCheckboxListPanel(int nr) {
        super();
        nrow = nr;

        dList = new DCheckboxList();

        addSingleDComponent(dList);


        dList.setItems(new Object[0]);

        dList.setLabelActor(this);
    }



    public void setItems(String[] sa) {
        dList.setItems(sa);
        if (listWatcher != null) {
            listWatcher.listChanged(this);
        }
    }


    public void setItems(ArrayList<? extends Object> obal) {
        Object[] obar = obal.toArray(new Object[obal.size()]);
        dList.setItems(obar);

        if (listWatcher != null) {
            listWatcher.listChanged(this);
        }
    }


    public void setSelected(String[] sa) {
        dList.setSelected(sa);
    }

    public void setSelected(int[] ia) {
        dList.setSelected(ia);
    }

    public void selectAll() {
        dList.selectAll();
    }


    public ArrayList<Object> getAllItems() {
        return dList.getAllItems();
    }

    public ArrayList<Object> getSelectedItems() {
        return dList.getCheckedItems();
    }


    public void setBg(Color c) {
        dList.setBackground(c);
        super.setBg(c);
    }



    public void updateDisplay() {
        // EFF
        dList.repaint();
    }


    public Object getSelectedItem() {
        return dList.getSelectedValue();
    }


    public String getSelectedName() {
        return "" + getSelectedItem();
    }


    public void labelAction(String s, boolean b) {
        if (s.equals("selected")) {
            valueChange(getSelectedName());

        } else if (s.equals("toggle")) {
]]>
</codefragment>
</duplication>
<duplication lines="49" tokens="287">
<file line="850" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.java"/>
<file line="770" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/tmp/Tmp1A.java"/>
<codefragment>
<![CDATA[
                System.out.println("in parallelAndSharedDiffusionStep 1st else: ngo is NEGATIVE. Exiting...");
                System.exit(0);
            }

        } else {
            if (useBinomial()) {
                // WK 7 2 2008: if n*p < 10, then use poission to get ngo;
                // otherwise, use gaussian.
                // RO 7 3 2008: changed from 10 to 20 because observed negative
                // ngo
                if (np0 * pSharedOut[iel][k] < NP) {
                    // RO
                    ngo = StepGenerator.gaussianStep(np0, pSharedOut[iel][k], random.gaussian(), random.random(),
                                                     random.poisson(np0 * pSharedOut[iel][k]), NP);

                    if (ngo < 0) {
                        ngo = 0;

                        System.out.println("in parallelAndSharedDiffusionStep, if (np0*pSharedOut[iel][k] < " + NP
                                           + "): ngo is NEGATIVE.");
                        System.out.println("ngo: " + ngo + " np0: " + np0 + " pSharedOut[iel][k]: "
                                           + pSharedOut[iel][k]);
                    }

                } else {
                    ngo = StepGenerator.gaussianStep(np0, pSharedOut[iel][k], random.gaussian(), random.random());
                    if (ngo < 0) {
                        ngo = 0;

                        System.out.println("in parallelAndSharedDiffusionStep, if (np0*pSharedOut[iel][k] >= " + NP
                                           + "): ngo is NEGATIVE.");
                        System.out.println("ngo: " + ngo + " np0: " + np0 + " pSharedOut[iel][k]: "
                                           + pSharedOut[iel][k]);
                    }
                    // WK
                }
            } else {
                ngo = StepGenerator.poissonStep(np0, pSharedOut[iel][k], random.gaussian(), random.random());
                if (ngo < 0) {
                    ngo = 0;

                    System.out.println("in parallelAndSharedDiffusionStep, if not using Binomial: ngo is NEGATIVE.");
                    System.out.println("ngo: " + ngo + " np0: " + np0 + " pSharedOut[iel][k]: " + pSharedOut[iel][k]);
                }
            }
        }

        // WK 7 2 2008: if ngo is negative, exit.
        if (ngo < 0) {
]]>
</codefragment>
</duplication>
<duplication lines="55" tokens="270">
<file line="429" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/numeric/math/Matrix.java"/>
<file line="539" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/math/Matrix.java"/>
<codefragment>
<![CDATA[
    }



    public double[] lubksb(double[] b) {
        int ip;
        int ii = -1;
        double sum;

        for (int i = 0; i < n; i++) {
            ip = perm[i];
            sum = b[ip];
            b[ip] = b[i];
            if (ii >= 0) {
                for (int j = ii; j < i; j++) {
                    sum -= a[i][j] * b[j];
                }
            } else if (sum != 0.0) {
                ii = i;
            }
            b[i] = sum;
        }

        for (int i = n - 1; i >= 0; i--) {
            sum = b[i];
            for (int j = i + 1; j < n; j++) {
                sum -= a[i][j] * b[j];
            }
            b[i] = sum / a[i][i];
        }
        return b;
    }


    public void round(double d) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (Math.abs(a[i][j]) < d) {
                    a[i][j] = 0.0;
                }
            }
        }
    }



    public void round() {
        round(1.0e-15);
    }



    public void print() {

        String[] sa = new String[n];
]]>
</codefragment>
</duplication>
<duplication lines="65" tokens="260">
<file line="22" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/numeric/math/Random.java"/>
<file line="24" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/math/NRRandom.java"/>
<codefragment>
<![CDATA[
    public static double random() {
        jran = (jran * ia + ic) % im;
        double ran = (1. * jran) / im;
        return ran;
    }

    public static int getSeed() {
        return jran;
    }


    public static void setSeed(int jr) {
        jran = jr;
    }



    public static double nextRandom() {
        return random();
    }


    public static double uniformRV() {
        return random();
    }




    public static int weightedSample(double[] rw) {
        int n = rw.length;
        double a = random();
        int inew = 0;
        while ((a -= rw[inew]) > 0 && inew < n-1) {
            inew++;
        }
        return inew;
    }



    public  static double gaussianRV() {
        return grv();
    }


    public static double  grv() {
        double r, ran1, ran2, fac, g1;
        r = -1;
        ran1 = 0.0;
        ran2 = 0.0;
        while (r <= 0.0 || r >= 1.0) {
            jran = (jran * ia + ic) % im;
            ran1 = (2. * jran) / im - 1;

            jran = (jran * ia + ic) % im;
            ran2 = (2. * jran) / im - 1;

            r = ran1 * ran1 + ran2 * ran2;
        }
        fac = Math.sqrt(-2. * Math.log(r) / r);
        g1 = ran1 * fac;
        //      g2 = ran2 * fac;
        return g1;
    }
]]>
</codefragment>
</duplication>
<duplication lines="27" tokens="246">
<file line="288" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/swing/DFloatSlider.java"/>
<file line="241" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/swing/DSlider.java"/>
<codefragment>
<![CDATA[
    }


    private void drawUpButton(Graphics g, int icx, int icy, int hw, int hh) {
        Color c = getBackground();

        g.setColor(c.darker());
        g.drawLine(icx - hw - 1, icy + hh + 1, icx + hw + 1, icy + hh + 1);
        g.drawLine(icx - hw, icy + hh, icx + hw, icy + hh);

        g.drawLine(icx + hw + 1, icy - hh - 1, icx + hw + 1, icy + hh + 1);
        g.drawLine(icx + hw, icy - hh, icx + hw, icy + hh);


        g.setColor(c.brighter());
        g.drawLine(icx - hw - 1, icy - hh - 1, icx + hw + 1, icy - hh - 1);
        g.drawLine(icx - hw, icy - hh, icx + hw, icy - hh);

        g.drawLine(icx - hw - 1, icy - hh - 1, icx - hw - 1, icy + hh + 1);
        g.drawLine(icx - hw, icy - hh, icx - hw, icy + hh);



    }


    public void nudgeLeft() {
]]>
</codefragment>
</duplication>
<duplication lines="47" tokens="219">
<file line="58" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/interlish/reflect/Narrower.java"/>
<file line="53" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/xml/Narrower.java"/>
<codefragment>
<![CDATA[
            ret = new SColor((String)arg);

        }

        return ret;

    }



    public static void err(String s) {
        E.error(s);
    }



    public static double parseDouble(String s) {
        double dret = 0.;
        int ii = s.indexOf("e");
        if (ii < 0)
            ii = s.indexOf("E");
        if (ii < 0) {
            dret = (new Double(s)).doubleValue();

        } else {
            String sa = s.substring(0, ii - 1);
            String sp = s.substring(ii + 1, s.length());
            int ppp = Integer.parseInt(sp);
            dret = (new Double(sa)).doubleValue();
            dret *= Math.pow(10., ppp);

        }
        return dret;
    }


    public static String[] makeStringArray(Object ob) {
        String[] sret = null;
        if (ob instanceof String[]) {
            sret = (String[])ob;

        } else if (ob instanceof String) {
            sret = new String[1];
            sret[0] = (String)ob;

        } else if (ob instanceof ArrayList<?>) {
            ArrayList<? extends Object> v = (ArrayList<? extends Object>)ob;
]]>
</codefragment>
</duplication>
<duplication lines="48" tokens="213">
<file line="601" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/numeric/math/Matrix.java"/>
<file line="715" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/math/Matrix.java"/>
<codefragment>
<![CDATA[
        for (int i = 0; i < n2; i++) {
            c[i] = a[i][ic];
        }
        return c;
    }



    public int randomIndexFromOffsetColumn(int c, int off) {
        double r = Math.random();
        int ir;
        for (ir = off; (r -= a[ir][c]) > 0; ir++) {
            ;
        }
        return ir;
    }



    public double[] ev1vec(int np) {
        // find the vector with eigenvalue 1., assuming it exists... or
        // equivalently the null space of M-I, which is assumed to have
        // dimension 1;
        // actually just take a large power of the Matrix ***

        Matrix q = copy();
        for (int i = 0; i < np; i++) {
            q = q.prod(q);
        }

        double[] s = new double[n];
        for (int i = 0; i < n; i++) {
            s[i] = 1. / n;
        }
        s = q.rvprod(s);

        double t = 0.0;
        for (int i = 0; i < n; i++) {
            t += s[i];
        }
        for (int i = 0; i < n; i++) {
            s[i] /= t;
        }
        if (Math.abs(t - 1.) > 0.01) {
            Sp("WARNING - ev1vec in class Matrix chnaged size " + t);
        }
        return s;
    }
]]>
</codefragment>
</duplication>
<duplication lines="61" tokens="209">
<file line="384" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/swing/DFloatSlider.java"/>
<file line="326" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/swing/DSlider.java"/>
<codefragment>
<![CDATA[
            export();
            repaint();
        }
    }



    // map listeners to rfsXXX methods;

    public void mouseDragged(MouseEvent e) {
        int x = e.getX();
        int y = e.getY();
        rsfMouseDrag(x, y);
    }


    public void mouseMoved(MouseEvent e) {
    }


    public void mousePressed(MouseEvent e) {
        int x = e.getX();
        int y = e.getY();
        long when = e.getWhen();
        int modif = e.getModifiers();
        int button = 0;
        if (modif == InputEvent.BUTTON1_MASK) {
            button = 1;
        } else if (modif == InputEvent.BUTTON2_MASK) {
            button = 2;
        } else if (modif == InputEvent.BUTTON3_MASK) {
            button = 3;
        }
        rsfMouseDown(x, y, when, button);
    }



    public void mouseReleased(MouseEvent e) {
        int x = e.getX();
        int y = e.getY();
        rsfMouseUp(x, y);
    }



    public void mouseEntered(MouseEvent e) {
        requestFocus();
    }


    public void mouseExited(MouseEvent e) {
    }


    public void mouseClicked(MouseEvent e) {
        requestFocus();
    }


    public double getTotalRange() {
]]>
</codefragment>
</duplication>
<duplication lines="34" tokens="199">
<file line="24" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/interlish/reflect/Narrower.java"/>
<file line="22" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/xml/Narrower.java"/>
<codefragment>
<![CDATA[
        if (fcln.endsWith("int")) {
            ret = new Integer(makeInt(arg));

        } else if (fcln.endsWith("boolean")) {
            ret = new Boolean(makeBoolean(arg));

        } else if (fcln.endsWith("double")) {
            ret = new Double(makeDouble(arg));

        } else if (fcln.startsWith("java.lang.String")) {
            ret = arg;

        } else if (fcln.startsWith("[D")) {
            ret = makeDoubleArray(arg);

        } else if (fcln.startsWith("[I")) {
            ret = makeIntArray(arg);

        } else if (fcln.startsWith("[Ljava.lang.String")) {
            ret = makeStringArray(arg);

        } else if (fcln.startsWith("[Z")) {
            ret = makeBooleanArray(arg);

        } else if (fcln.startsWith("[[D")) {
            ret = makeDDArray(arg);

        } else if (fcln.startsWith("[[I")) {
            ret = makeIIArray(arg);

        } else if (fcln.endsWith("ArrayList")) {
            ret = makeArrayList(arg);

        } else if (fcln.endsWith("SColor")) {
]]>
</codefragment>
</duplication>
<duplication lines="50" tokens="196">
<file line="61" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/blocks/ScrollingCheckboxList.java"/>
<file line="59" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/blocks/ScrollingList.java"/>
<codefragment>
<![CDATA[
        if (renderer != null) {

            // TODO move renderer defs to XML;

            if (renderer.equals("quantity")) {
                drup.setCellRenderer(new DruListQuantityRenderer());

            } else if (renderer.equals("progress")) {
                drup.setCellRenderer(new DruListProgressRenderer());

            } else if (renderer.equals("color")) {
                drup.setCellRenderer(new DruListColorRenderer());

            } else {
                E.error("unrecognized renderer " + renderer);
            }
        }

        if (multiple) {
            drup.setMultiple();
        }

        if (clickAction != null) {
            if (clickAction.equals("toggle")) {
                drup.setToggleAction();
            } else {
                E.warning("unrecognized action " + clickAction);
            }
        }


        if (order != null) {
            if (order.equals("reverse")) {
                drup.setOrder(DruListPanel.REVERSE_ORDER);

            } else {
                E.warning("unknown list order " + order + " (only know reverse)");
            }
        }


        if (clickAreas != null) {
            for (ListClickArea lca : clickAreas) {
                drup.addClickAction(lca.makeActor());
            }
        }

    }

}
]]>
</codefragment>
</duplication>
<duplication lines="47" tokens="196">
<file line="306" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/swing/DChoice.java"/>
<file line="138" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/swing/DValueHistory.java"/>
<codefragment>
<![CDATA[
    }



    public void setLabelActor(LabelActor bl) {
        lact = bl;
    }



    public void deliverAction(String s, boolean b) {
        if (lact != null) {
            lact.labelAction(s, b);
        }
    }



    // icon methods to draw the button;
    public void paintIcon(Component c, Graphics g, int x, int y) {
        JComponent component = (JComponent)c;
        int iconWidth = getIconWidth();

        g.translate(x, y);

        g.setColor(component.isEnabled() ? Color.gray : Color.blue);

        g.drawLine(2, 0, iconWidth - 1, 0);
        g.drawLine(3, 1, 1 + (iconWidth - 3), 1);
        g.drawLine(5, 3, 3 + (iconWidth - 7), 3);
        g.drawLine(6, 4, 4 + (iconWidth - 9), 4);

        g.translate(-x, -y);
    }


    public int getIconWidth() {
        return 12;
    }


    public int getIconHeight() {
        return 5;
    }


    public void setUpdatable(Updatable u) {
]]>
</codefragment>
</duplication>
<duplication lines="23" tokens="194">
<file line="257" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/vis/SceneGraphBuilder.java"/>
<file line="341" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/vis/SceneGraphBuilder.java"/>
<codefragment>
<![CDATA[
        int nvert = 2 * nside * nstrip;

        int[] svc = new int[nstrip];
        for (int i = 0; i < nstrip; i++) {
            svc[i] = 2 * nside;
        }

        float[] datv = new float[3 * nvert];
        float[] datn = new float[3 * nvert];


        double dtheta = 2. * Math.PI / (nside-1);
        double[][] csas = new double[nside][2];
        double[][] csbs = new double[nside][2];
        for (int i = 0; i <  nside; i++) {
            double tha = i * dtheta;
            double thb = (i + 0.5) * dtheta;
            csas[i][0] = Math.cos(tha);
            csas[i][1] = Math.sin(tha);

            csbs[i][0] = Math.cos(thb);
            csbs[i][1] = Math.sin(thb);
        }
]]>
</codefragment>
</duplication>
<duplication lines="85" tokens="189">
<file line="191" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/dataview/FrameController.java"/>
<file line="147" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/dataview/gui/FramePlayerController.java"/>
<codefragment>
<![CDATA[
            framePlayer.start();
        }
    }


    public void stop() {
        if (framePlayer != null) {
            framePlayer.stop();
        }
    }




    public void faster() {
        speed *= 1.3;
    }

    public void slower() {
        speed /= 1.3;
    }


    public boolean canAdvance() {
        return (indexes != null && shownFrame < indexes.length-1);
    }


    public void advance() {
        showFrame(shownFrame + 1);
    }


    public double getSpeed() {
        return speed;
    }



    public void record() {
        E.missing();
        /*
        File f = FileChooser.getWriteFile();
        if (f != null) {
        makeAnimatedGif(f);
            }
            */

    }


    public void miniRecord() {
        E.missing();
        /*
        File f = FileChooser.getWriteFile();
        if (f != null) {
        makeMiniAnimatedGif(f, 160, 100);
            }
            */
    }



    public void makeMovie(File f) {
        makeAnimatedGif(f);
    }

    public void makeThumbnailMovie(File f) {
        makeMiniAnimatedGif(f, 160, 160);
    }



    public void makeAnimatedGif(File f) {
        stop();
        rewind();


        AnimatedGifEncoder enc = new AnimatedGifEncoder();

        enc.start(f);
        enc.setDelay(160);   // ms

        int ifr = 0;
        E.info("animated gif - frame " + ifr);
]]>
</codefragment>
</duplication>
<duplication lines="49" tokens="183">
<file line="140" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/serial/xml/XMLToken.java"/>
<file line="137" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/xml/XMLToken.java"/>
<codefragment>
<![CDATA[
            nvpa[i] = new NamedString(attNV[2*i], attNV[2*i+1]);
        }
        return nvpa;
    }



    public String getAttribute(String sat) {
        String sret = null;
        for (int i = 0; i < natt; i++) {
            if (attNV[2*i].equals(sat)) sret = attNV[2*i+1];
        }
        return sret;
    }


    public String getName() {
        return svalue;
    }

    public String getOpenTagString() {
        return ("<" + svalue + ">");
    }

    public String getCloseTagString() {
        return ("</" + svalue + ">");
    }



    public boolean closes(XMLToken start) {
        return (svalue.equals(start.getName()) && isClose());
    }


    public int getNumAttributes() {
        return natt;
    }


    public String getAttributeName(int i) {
        return attNV[2*i];
    }

    public String getAttributeValue(int i) {
        return attNV[2*i+1];
    }

}
]]>
</codefragment>
</duplication>
<duplication lines="40" tokens="180">
<file line="236" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/swing/DFloatSlider.java"/>
<file line="172" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/swing/DSlider.java"/>
<codefragment>
<![CDATA[
            g.drawString(label, 40, 20);
        }
    }



    private void paintArrows(Graphics g) {
        int w = getWidth();
        int h = getHeight();

        Color cbg = bgColor;
        Color cbr = cbg.brighter();
        Color cdk = cbg.darker();

        int hh = h / 2;
        g.setColor(cbr);
        g.drawLine(4, hh, 15, 4);

        g.drawLine(w - 15, h - 4, w - 15, 4);

        // g.drawLine(w-15, 4, w-10, hh);


        g.setColor(cdk);
        g.drawLine(15, 4, 15, h - 4);
        // g.drawLine(15, h-4, 10, hh);


        g.drawLine(4, hh, 15, h - 4);

        g.drawLine(w - 15, h - 4, w - 4, hh);
        g.drawLine(w - 15, 4, w - 4, hh);

    }


    private void paintKnob(Graphics g) {
        int width = getWidth();
        int height = getHeight();
        int hh = height / 2;
]]>
</codefragment>
</duplication>
<duplication lines="46" tokens="178">
<file line="321" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/interlish/reflect/ReflectionConstructor.java"/>
<file line="274" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/xml/ReflectionInstantiator.java"/>
<codefragment>
<![CDATA[
        }


        if (child == null) {
            E.warning("ReflectionInstantiator failed to get field " + name + " on " + parent + " "
                      + (parent != null ? parent.getClass().toString() : ""));
        }


        /*
         * POSERR did this do anything useful? if (child instanceof IDd &&
         * ((IDd)child).getID() == null) { // setAttributeField(child, "id",
         * name); // System.out.println("autoset id to " + name); }
         */
        return child;
    }



    public void applyAttributes(Object target, Attribute[] atta) {

        for (int i = 0; i < atta.length; i++) {
            Attribute att = atta[i];
            setAttributeField(target, att.getName(), att.getValue());
        }
    }



    public boolean setAttributeField(Object target, String name, String arg) {
        boolean bret = false;
        if (name.equals("class") || name.equals("package") || name.equals("provides")
                || name.equals("archive-hash")) {
            // already done; ADHOC

        } else {
            bret = setField(target, name, arg);
        }

        return bret;
    }


    // ADHOC suppressing warnings
    @SuppressWarnings( { "unchecked" })
    public boolean setField(Object ob, String sfin, Object argin) {
]]>
</codefragment>
</duplication>
<duplication lines="27" tokens="171">
<file line="462" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/interlish/reflect/ReflectionConstructor.java"/>
<file line="394" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/xml/ReflectionInstantiator.java"/>
<codefragment>
<![CDATA[
                    f.set(ob, d);

                } else if (ftyp == Double.TYPE && arg instanceof Double) {
                    f.set(ob, arg);

                } else if (ftyp == Boolean.TYPE && arg instanceof Boolean) {
                    f.set(ob, arg);

                } else if (ftyp == Integer.TYPE && arg instanceof Integer) {
                    f.set(ob, arg);

                } else if (f.getType().isArray() && arg instanceof ArrayList) {
                    setArrayField(ob, f, (ArrayList)arg);

                } else {
                    Object onarg = Narrower.narrow(ftyp.getName(), arg);

                    if (onarg != null) {
                        f.set(ob, onarg);
                    } else {
                        f.set(ob, arg);
                    }
                }
                ok = true;
            } catch (Exception e) {
                ok = false;
                E.error(" cant set field " + sf + " in " + ob + " from typed " +
]]>
</codefragment>
</duplication>
<duplication lines="34" tokens="165">
<file line="328" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/interlish/reflect/Narrower.java"/>
<file line="12" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/serial/DataIO.java"/>
<codefragment>
<![CDATA[
    public static double[] readDoubleArray(String sin) {
        String s = sin;
        if (s.startsWith("{")) {
            s = s.substring(1, s.indexOf("}"));
        }
        s = s.trim();

        String[] sa = s.split("[ ,\t\n\r]+");

        /*
        E.info("after splitting " + s);
        for (int i = 0; i < sa.length; i++) {
        E.info("item " + i + " " + sa[i]);
        }
        */

        int nt = sa.length;
        double[] value = new double[nt];

        try {
            for (int i = 0; i < nt; i++) {
                value[i] = (new Double(sa[i])).doubleValue();
            }
        } catch (Exception ex) {
            E.error("float reading cant extract " + nt + " doubles from " + s);
            for (int i = 0; i < nt; i++) {
                E.info("string " + i + "=xxx" + sa[i] + "xxx");
            }
        }

        return value;
    }

}
]]>
</codefragment>
</duplication>
<duplication lines="61" tokens="164">
<file line="84" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.java"/>
<file line="42" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/tmp/Tmp1A.java"/>
<codefragment>
<![CDATA[
    Column mconc;

    ReactionTable rtab;
    public VolumeGrid vgrid;

    StimulationTable stimTab;

    double dt;

    public int nel;
    int nspec;
    public String[] specieIDs;

    double[] volumes;
    double[] lnvolumes;
    double[] fdiff;
    double[] lnfdiff;

    double[] surfaceAreas;

    // WK 6 18 2007
    public boolean[] submembranes;
    public String[] regionLabels;
    public int[] eltregions;
    // WK

    int[][] neighbors;
    double[][] couplingConstants;
    double[][] lnCC;

    int[][] wkA;
    int[][] wkB;
    int[] wkReac;

    int[][] nparticle;

    int nreaction;
    public int nspecie;
    String[] speciesIDs;
    double[] diffusionConstants;

    int[][] reactantIndices;
    int[][] productIndices;

    int[][] reactantStochiometry;
    int[][] productStochiometry;

    double[] rates;
    double[] lnrates;

    int[][] stimtargets;

    double[] intlogs;
    double lndt;

    int ninjected = 0;

    InterpolatingStepGenerator interpSG;
    MersenneTwister random;
    int nwarn;
    int nngowarn = 0;         //added in v2.1.1 by BHK to keep track of a different type of warning
]]>
</codefragment>
</duplication>
<duplication lines="47" tokens="163">
<file line="96" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/disc/DiscSplitter.java"/>
<file line="103" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/disc/LineBoxer.java"/>
<codefragment>
<![CDATA[
                CurvedVolumeSlice vg = null;
                if (tpn.subAreaPeer == tp) {
                    // nothing to do for now - put line in when we
                    // do the first child of tpn
                    // E.info("skipping pt with peer " + tpn);

                } else if (tp.subAreaPeer != null && tp.subAreaPeer == tp.parent) {
                    // E.info("first pt after branch " + tpn);
                    TreePoint par = tp.parent;
                    E.info("starting a sub-branch at " + tp + " - " + tpn + " " + pGrid);

                    vg = baseGrid(tp, tpn, lbl);
                    pGrid.subPlaneConnect(tp, tpn, vg, par.partBranchOffset);
                    par.partBranchOffset += 2 * tpn.r;

                } else {
                    // normal case: make a new one or add a slice and connect
                    // it up with the centres aligned
                    if (pGrid == null) {
                        vg = baseGrid(tp, tpn, lbl);

                    } else {
                        // TODO - probably not what we want
                        // too much mumerical diffusion if boxes can have gradually changing
                        // sizes? restrict to a few dicrete multiples?
                        vg = baseGrid(tp, tpn, lbl);
                        pGrid.planeConnect(vg);
                    }
                }

                lbl = null; // only use it once
                if (vg != null) {
                    gridAL.add(vg);
                    recAdd(vg, tpn);
                } else {
                    // skipped the point that is the start of a new segment
                    // of different radius
                    recAdd(pGrid, tpn);
                }
            }
        }
    }




    public CurvedVolumeSlice baseGrid(TreePoint tpa, TreePoint tpb, String lbl) {
]]>
</codefragment>
</duplication>
<duplication lines="24" tokens="159">
<file line="16" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/graph/gui/Geom.java"/>
<file line="226" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/graph/gui/Iconizer.java"/>
<codefragment>
<![CDATA[
    public final static boolean pointIsInside(double[] xb, double[] yb, double x, double y) {
        int n = xb.length;
        int iwn = 0;
        for (int i = 0; i < n; i++) {
            int idir = 0;
            int p = (i + 1) % n;
            if (yb[i] <= y && yb[p] > y) {
                idir = 1;
            }

            if (yb[i] > y && yb[p] <= y) {
                idir = -1;
            }

            if (idir != 0) {
                double f = (y - yb[i]) / (yb[p] - yb[i]);
                double xc = f * xb[p] + (1. - f) * xb[i];
                int isid = (xc > x ? 1 : -1);
                iwn += isid * idir;
            }

        }
        return (iwn != 0);
    }
]]>
</codefragment>
</duplication>
<duplication lines="26" tokens="152">
<file line="338" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/grid/DeterministicGridCalc.java"/>
<file line="441" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/tmp/Tmp1A.java"/>
<codefragment>
<![CDATA[
        while (time < endtime) {

            // RO 5 13 2010: follows template in SteppedStochaticGridCalc
            if (time >= writeTime) {
                if (resultWriter != null) {
                    resultWriter.writeString(getGridConcsText(time));
                }
                writeTime += sdRun.outputInterval;
            }
            for (int i = 0; i < fnmsOut.length; i++) {
                if (time >= writeTimeArray[i]) {
                    resultWriter.writeToSiblingFile(getGridConcsPlainText_dumb(i, time), "-" +fnmsOut[i] + "-conc.txt");
                    writeTimeArray[i] += Double.valueOf(dtsOut[i]);
                }
            }

            time += advance(time);

            if (time > tlog) {
                E.info("time " + time + " dt=" + dt);
                tlog += Math.max(50 * sdRun.outputInterval, 5);
            }


            if (time >= stateSaveTime) {
                resultWriter.writeToSiblingFile(getStateText(), sdRun.stateSavePrefix +  "-" + Math.round(time) + ".nrds");
]]>
</codefragment>
</duplication>
<duplication lines="32" tokens="150">
<file line="330" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/interlish/reflect/Narrower.java"/>
<file line="14" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/serial/DataIO.java"/>
<file line="326" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/xml/Narrower.java"/>
<codefragment>
<![CDATA[
        if (s.startsWith("{")) {
            s = s.substring(1, s.indexOf("}"));
        }
        s = s.trim();

        String[] sa = s.split("[ ,\t\n\r]+");

        /*
        E.info("after splitting " + s);
        for (int i = 0; i < sa.length; i++) {
        E.info("item " + i + " " + sa[i]);
        }
        */

        int nt = sa.length;
        double[] value = new double[nt];

        try {
            for (int i = 0; i < nt; i++) {
                value[i] = (new Double(sa[i])).doubleValue();
            }
        } catch (Exception ex) {
            E.error("float reading cant extract " + nt + " doubles from " + s);
            for (int i = 0; i < nt; i++) {
                E.info("string " + i + "=xxx" + sa[i] + "xxx");
            }
        }

        return value;
    }

}
]]>
</codefragment>
</duplication>
<duplication lines="26" tokens="147">
<file line="338" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/grid/DeterministicGridCalc.java"/>
<file line="520" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.java"/>
<codefragment>
<![CDATA[
        while (time < endtime) {

            // RO 5 13 2010: follows template in SteppedStochaticGridCalc
            if (time >= writeTime) {
                if (resultWriter != null) {
                    resultWriter.writeString(getGridConcsText(time));
                }
                writeTime += sdRun.outputInterval;
            }
            for (int i = 0; i < fnmsOut.length; i++) {
                if (time >= writeTimeArray[i]) {
                    resultWriter.writeToSiblingFile(getGridConcsPlainText_dumb(i, time), "-" +fnmsOut[i] + "-conc.txt");
                    writeTimeArray[i] += Double.valueOf(dtsOut[i]);
                }
            }

            time += advance(time);

            if (time > tlog) {
                E.info("time " + time + " dt=" + dt);
                tlog += Math.max(50 * sdRun.outputInterval, 5);
            }


            if (time >= stateSaveTime) {
                resultWriter.writeToSiblingFile(getStateText(), sdRun.stateSavePrefix +  "-" + Math.round(time) + ".nrds");
]]>
</codefragment>
</duplication>
<duplication lines="9" tokens="145">
<file line="1340" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/graph/gui/Painter.java"/>
<file line="1354" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/graph/gui/Painter.java"/>
<codefragment>
<![CDATA[
    public void drawUpper3DIntMarks(float[][] ca, int n, int w, int h, double zp, double zd) {
        for (int i = 0; i < n; i++) {
            double z = zProj(ca[i][0], ca[i][1], ca[i][2]);
            double f = ca[i][4];
            if (z < (f * zd + (1.-f) * zp)) {

                int x = powx(xProj(ca[i][0], ca[i][1], ca[i][2]));
                int y =  powy(yProj(ca[i][0], ca[i][1], ca[i][2]));
                g.fillRect(x, y, w, h);
]]>
</codefragment>
</duplication>
<duplication lines="25" tokens="142">
<file line="520" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.java"/>
<file line="441" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/tmp/Tmp1A.java"/>
<codefragment>
<![CDATA[
        while (time < endtime) {

            if (time >= writeTime) {
                if (resultWriter != null) {
                    resultWriter.writeString(getGridConcsText(time));
                }
                writeTime += sdRun.outputInterval;
            }
            for (int i = 0; i < fnmsOut.length; i++) {
                if (time >= writeTimeArray[i]) {
                    resultWriter.writeToSiblingFile(getGridConcsPlainText_dumb(i, time), "-" + fnmsOut[i] + "-conc.txt");
                    writeTimeArray[i] += Double.valueOf(dtsOut[i]);
                }
            }


            time += advance(time);

            if (time > tlog) {
                E.info("time " + time + " dt=" + dt);
                tlog += Math.max(50 * sdRun.outputInterval, 5);
            }

            if (time >= stateSaveTime) {
                resultWriter.writeToFinalSiblingFile(getStateText(), sdRun.stateSavePrefix + Math.round(time) + ".nrds");
]]>
</codefragment>
</duplication>
<duplication lines="36" tokens="137">
<file line="87" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/interlish/reflect/ReflectionConstructor.java"/>
<file line="52" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/xml/ReflectionInstantiator.java"/>
<codefragment>
<![CDATA[
    }


    public void checkAddPackage(Object oret) {
        String scl = oret.getClass().getName();
        if (scl.startsWith("java")) {
            return;
        }

        int ild = scl.lastIndexOf(".");
        String pkg = scl.substring(0, ild);
        if (pkg.equals(wkpkg)) {
            // just same as before;

        } else {
            boolean got = false;
            for (int i = 0; i < npkg; i++) {
                if (pkgs[i].equals(pkg)) {
                    got = true;
                    break;
                }
            }
            if (!got) {
                pkgs[npkg++] = pkg;

                // System.out.println("Reflection instantiator added search package
                // " + pkg);
            }
        }
    }



    public Object newInstance(String scl) {
        Object oret = null;
        Class<?> c = null;
]]>
</codefragment>
</duplication>
<duplication lines="24" tokens="136">
<file line="337" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/numeric/mesh/Discretizer.java"/>
<file line="315" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/disc/SegmentSlicer.java"/>
<codefragment>
<![CDATA[
            } else {
                // chop up the carrot;
                double delf = fdist / (nadd+1);
                double ffa = (rb - ra) / dab;      // dr/dx
                double xa = ra / ffa;
                double xb = rb / ffa;
                // xa and xb are the end positions measured from where
                // the carrot comes to a point.
                double x = xa;

                // the integral of sqrt(r) dx is
                // 2/3 * dx / (rb-ra) * (rb^3/2 - ra^3/2)
                // so need dx such that this is delf (= total_int / nseg)

                for (int i = 0; i < nadd+1; i++) {
                    double ttt = (delf * ffa * 3./2. +
                                  Math.pow(ffa * x, 3./2.));
                    double dx = Math.pow(ttt, (2./3.)) / ffa - x;
                    x += dx;
                    if (i < nadd) {
                        dpos[i] = (x - xa) / dab;
                    }
                }
                if (Math.abs(xb - x) > 1.e-5) {
]]>
</codefragment>
</duplication>
<duplication lines="30" tokens="136">
<file line="393" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/interlish/reflect/ReflectionConstructor.java"/>
<file line="330" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/xml/ReflectionInstantiator.java"/>
<codefragment>
<![CDATA[
            return true;
        }

        if (arg.equals(ob)) {
            E.error("ReflectionInstantiator setField: " + "the child is the same as the parent " + ob);
            return true;
        }

        int icolon = sf.indexOf(":");
        if (icolon >= 0) {
            sf = sf.substring(0, icolon) + "_" + sf.substring(icolon + 1, sf.length());
        }

        boolean ok = false;

        Class c = ob.getClass();
        Field f = null;
        try {
            f = c.getField(sf);
        } catch (NoSuchFieldException e) {
        }



        if (f == null) {
            if (ob instanceof ArrayList) {
                ((ArrayList)ob).add(arg);
                ok = true;

            } else if (arg instanceof String && ob instanceof AttributeAddableTo) {
]]>
</codefragment>
</duplication>
<duplication lines="40" tokens="135">
<file line="255" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/report/E.java"/>
<file line="170" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/report/E.java"/>
<codefragment>
<![CDATA[
    }


    public static String getShortSource() {
        StackTraceElement[] stea = (new Exception()).getStackTrace();
        String ss = (" at " + stea[2].toString());
        if (ss.equals(lastShortSource)) {
            ss = "";
        } else {
            lastShortSource = ss;
        }
        return ss;
    }



    public static void delay() {
        pause(200);
    }


    public static void pause(int n) {
        try {

            Thread.sleep(n);
        } catch (Exception ex) {
        }
    }


    public static void newLine() {
        System.out.println("...");
    }


    public static void cacheAction(String s) {
        cachedAction = s;
    }

    public static void reportCached() {
]]>
</codefragment>
</duplication>
<duplication lines="11" tokens="135">
<file line="367" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/vis/SceneGraphBuilder.java"/>
<file line="382" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/vis/SceneGraphBuilder.java"/>
<codefragment>
<![CDATA[
        for (int ic = 0; ic < ncap; ic++) {
            double[][] incs = (ic % 2 == 0 ? csbs : csas);
            double[][] outcs = (ic % 2 == 0 ? csas : csbs);

            double t0 = ic * (0.5 * Math.PI / (ncap + 0.1));
            double t1 = (ic + 1) * (0.5 * Math.PI / (ncap + 0.1));
            double s0 = Math.sin(t0);
            double c0 = Math.cos(t0);
            double s1 = Math.sin(t1);
            double c1 = Math.cos(t1);
            vnStrip(datv, datn, koff, nside, c1 * ra, c0 * ra, -1 * s1 * ra, -1 * s0 * ra, -s1, c1, -s0, c0, incs, outcs);
]]>
</codefragment>
</duplication>
<duplication lines="46" tokens="133">
<file line="14" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/serial/xml/XMLWriter.java"/>
<file line="10" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/xml/XMLWriter.java"/>
<codefragment>
<![CDATA[
public class XMLWriter {

    boolean conciseTags;
    boolean quoteStrings;


    public XMLWriter() {
        conciseTags = false;
        quoteStrings = true;
    }


    public void setConciseTags(boolean b) {
        conciseTags = b;
    }


    public void setQuoteStrings(boolean b) {
        quoteStrings = b;
    }


    public static void err(String s) {
        System.out.println(s);
    }


    public static XMLWriter newInstance() {
        return new XMLWriter();
    }


    public static String serialize(Object ob) {
        return getSerialization(ob);
    }


    public static String getSerialization(Object ob) {
        return newInstance().writeObject(ob);
    }



    public String writeObject(Object obj) {
        StringBuffer sb = new StringBuffer();
        appendObject(sb, "", null, obj);
]]>
</codefragment>
</duplication>
<duplication lines="6" tokens="130">
<file line="1329" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/graph/gui/Painter.java"/>
<file line="1342" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/graph/gui/Painter.java"/>
<codefragment>
<![CDATA[
            double z = zProj(ca[i][0], ca[i][1], ca[i][2]);
            double f = ca[i][4];
            if (z < (f * zd + (1.-f) * zp)) {
                int x = powx(xProj(ca[i][0], ca[i][1], ca[i][2]));
                int y =  powy(yProj(ca[i][0], ca[i][1], ca[i][2]));
                g.fillRect(x, y, 1, 1);
]]>
</codefragment>
</duplication>
<duplication lines="47" tokens="130">
<file line="195" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/grid/DeterministicGridCalc.java"/>
<file line="379" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.java"/>
<file line="335" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/tmp/Tmp1A.java"/>
<codefragment>
<![CDATA[
                    }
                }
            }
        }

    }

    @SuppressWarnings("boxing")
    // RO 5 13 2010: Commented out in favor of new version above.
    // private String getGridConcsText(double time) {
    // StringBuffer sb = new StringBuffer();
    // sb.append("gridConcentrations " + nel + " " + nspec + " " + time + " ");
    // for (int i = 0; i < nspec; i++) {
    // sb.append(specieIDs[i] + " ");
    // }
    // sb.append("\n");
    //
    // for (int i = 0; i < nel; i++) {
    // // sb.append("");
    // for (int j = 0; j < nspec; j++) {
    // sb.append(String.format(" %g5 ", wkB[i][j]));
    // }
    // sb.append("\n");
    // }
    // return sb.toString();
    // }
    // RO
    private String getGridConcsText(double time) {
        StringBuffer sb = new StringBuffer();
        // TODO tag specific to integer quantities;
        int nspecout = ispecout.length;
        if (nspecout == 0) {
            return "";
        }

        sb.append("gridConcentrations " + nel + " " + nspecout + " " + time + " ");
        for (int i = 0; i < nspecout; i++) {
            sb.append(specieIDs[ispecout[i]] + " ");
        }
        sb.append("\n");
        for (int i = 0; i < nel; i++) {
            for (int j = 0; j < nspecout; j++) {
                // rcc May 2010: this was wrong, was it just saving species j,
                // not species ispecout[j]
                // sb.append(stringd(wkA[i][j]));
                if (writeConcentration) {
                    sb.append(stringd(wkA[i][ispecout[j]]));
]]>
</codefragment>
</duplication>
<duplication lines="50" tokens="129">
<file line="16" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/serial/om/OmFileReader.java"/>
<file line="16" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/serial/om/OmFileWriter.java"/>
<codefragment>
<![CDATA[
    public OmFileReader(File f) {
        file = f;
    }


    public File getFile() {
        return file;
    }

    public File getResourceDir() {
        /*
        String fnm = FileUtil.getRootName(file);
        String resnm = fnm + "_resources";
        File fparent = file.getParentFile();
        File fres = new File(fparent, resnm);
        if (fres.exists()) {
           // OK;
        } else {
           fres.mkdir();
        }
        return fres;
        */
        return file.getParentFile();
    }



    public void writeResource(Object oext, String resnm) {
        File fres = new File(getResourceDir(), resnm);
        Archivist.storeXMLOnly(oext, fres);
    }



    public Object readResource(String resnm) {
        Object ret = null;

        File f = new File(getResourceDir(), resnm);
        if (f.exists()) {

            String ftxt = FileUtil.readStringFromFile(f);
            ret = Deserializer.deserialize(ftxt);

        } else {
            E.error("no such resource file " + f);
        }
        return ret;
    }

}
]]>
</codefragment>
</duplication>
<duplication lines="34" tokens="129">
<file line="9" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/serial/xml/XMLChecker.java"/>
<file line="8" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/xml/XMLChecker.java"/>
<codefragment>
<![CDATA[
public class XMLChecker {



    public static void checkXML(String s, boolean bshow) {
        long starttime = System.currentTimeMillis();
        XMLTokenizer tkz = new XMLTokenizer(s);
        int nerror = 0;
        int nread = 0;

        while (true) {
            XMLToken xmlt = tkz.nextToken();
            if (bshow) {
                System.out.println("item " + nread + "  " + xmlt);
            }
            nread++;
            if (xmlt.isNone()) {
                break;
            }
        }
        long endtime = System.currentTimeMillis();

        System.out.println("  Total tags: " + nread + "\n  total errors: " + nerror +
                           "\n  tokenizing took " + (int)(endtime - starttime) + " ms");
    }








    public static String deGarbage(String sin) {
]]>
</codefragment>
</duplication>
<duplication lines="53" tokens="128">
<file line="138" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/dataview/FrameController.java"/>
<file line="95" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/dataview/gui/FramePlayerController.java"/>
<codefragment>
<![CDATA[
    }



    public void sliderMoved() {
        int ival = frameSlider.getValue();
        showFrame(ival);
    }


    public void rewind() {
        stop();
        showFrame(0);
    }





    public void pause() {
        if (isPaused) {
            dePause();
            start();

        } else {
            rePause();
            stop();
        }
    }


    public void dePause() {
        isPaused = false;
        pauseButton.setLabelText(" pause ");
    }

    private void rePause() {
        isPaused = true;
        pauseButton.setLabelText("resume");
    }


    public void play() {
        stop();
        rewind();
        start();
        dePause();
    }


    private void start() {
        if (indexes != null) {
            framePlayer = null; // new FramePlayer(this);
]]>
</codefragment>
</duplication>
<duplication lines="6" tokens="124">
<file line="1329" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/graph/gui/Painter.java"/>
<file line="1356" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/graph/gui/Painter.java"/>
<codefragment>
<![CDATA[
            double z = zProj(ca[i][0], ca[i][1], ca[i][2]);
            double f = ca[i][4];
            if (z < (f * zd + (1.-f) * zp)) {
                int x = powx(xProj(ca[i][0], ca[i][1], ca[i][2]));
                int y =  powy(yProj(ca[i][0], ca[i][1], ca[i][2]));
                g.fillRect(x, y, 1, 1);
]]>
</codefragment>
</duplication>
<duplication lines="32" tokens="123">
<file line="243" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/interlish/reflect/ReflectionConstructor.java"/>
<file line="214" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/xml/ReflectionInstantiator.java"/>
<codefragment>
<![CDATA[
        Object child = null;

        if (parent != null) {
            checkAddPackage(parent); // EFF inefficient
        }

        // Three possibilities:
        // 1 there is an attribute called class;
        // 2 the parent has a field called name;
        // 3 the name is a class name;


        if (atta == null) {
            atta = new Attribute[0];
        }


        // process special attributes and instantiate child if class is known
        // (case 1);
        String classname = null;
        for (int i = 0; i < atta.length; i++) {
            Attribute att = atta[i];
            String attName = att.getName();
            String attValue = att.getValue();

            if (attName.equals("package")) {
                StringTokenizer stok = new StringTokenizer(attValue, ", ");
                while (stok.hasMoreTokens()) {
                    addSearchPackage(stok.nextToken());
                }

            } else if (attName.equals("archive-hash")) {
]]>
</codefragment>
</duplication>
<duplication lines="26" tokens="120">
<file line="62" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/swing/dnd/RegionDropTarget.java"/>
<file line="48" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/swing/dnd/TextFieldDropTarget.java"/>
<codefragment>
<![CDATA[
                textCanvas.paintImmediately(dragBounds);
            } else {
                dragBounds = new Rectangle();
            }

            Point p = dtde.getLocation();

            Object obj = DragAndDrop.getDnD();

            if (obj instanceof ImageDragSource) {
                ImageDragSource ids = (ImageDragSource)obj;

                BufferedImage bim = ids.getDragImage();
                Point poff = ids.getDragImageOffset();

                int bw = bim.getWidth();
                int bh = bim.getHeight();

                if (bim == null) {
                    E.warning("no drag image?");
                } else {

                    // And remember where we are about to draw the new ghost image
                    dragBounds.setRect(p.x - poff.x, p.y - poff.y, bw, bh);

                    Graphics g = textCanvas.getGraphics();
]]>
</codefragment>
</duplication>
<duplication lines="22" tokens="120">
<file line="267" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/grid/DeterministicGridCalc.java"/>
<file line="426" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.java"/>
<file line="382" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/tmp/Tmp1A.java"/>
<codefragment>
<![CDATA[
                        sb.append(stringd((PARTICLES_PUVC * wkv * volumes[i])));
                    }

                }
            }
        }
        sb.append("\n");
        return sb.toString();
    }


    @SuppressWarnings("boxing")
    private String getStateText() {
        StringBuffer sb = new StringBuffer();
        sb.append("nrds " + nel + " " + specieIDs.length + "\n");
        for (int i = 0; i < specieIDs.length; i++) {
            sb.append(specieIDs[i] + " ");
        }
        sb.append("\n");
        for (int i = 0; i < nel; i++) {
            for (int j = 0; j < specieIDs.length; j++) {
                sb.append(stringd(wkA[i][j]));
]]>
</codefragment>
</duplication>
<duplication lines="19" tokens="119">
<file line="159" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/dataview/AxisPainter.java"/>
<file line="79" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/graph/gui/YAxisCanvas.java"/>
<codefragment>
<![CDATA[
        int ii = intervals[iiind];
        dy = Math.pow(10.0, powten) * ii;

        int i0 = (int)(ylow / dy);
        int i1 = (int)(yhigh / dy);

        for (int i = i0; i <= i1; i++) {
            double yy = i * dy;
            String lab = "0";
            if (i == 0) {
                // OK;

            } else if (dy >= 0.999 && dy < 1.e4) {
                lab = String.valueOf((int)(yy));
            } else {
                lab = String.valueOf((float)(yy));
            }

            int iy = height - bm - (int)((height - bm) * (yy - ylow) / (yhigh - ylow));
]]>
</codefragment>
</duplication>
<duplication lines="12" tokens="117">
<file line="1173" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/graph/gui/Painter.java"/>
<file line="1192" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/graph/gui/Painter.java"/>
<file line="1209" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/graph/gui/Painter.java"/>
<codefragment>
<![CDATA[
    final void drawOutline(double xa, double ya, double ra,
                           double xb, double yb, double rb) {

        double vy = xb - xa;
        double vx = -(yb - ya);
        double vl = Math.sqrt(vx * vx + vy * vy);
        if (vl <= 0.0) vl = 1.e-6; // ***
        vx /= vl;
        vy /= vl;

        drawLine(xa - ra * vx, ya - ra * vy,  xb - rb * vx, yb - rb * vy);
        drawLine(xa + ra * vx, ya + ra * vy,  xb + rb * vx, yb + rb * vy);
]]>
</codefragment>
</duplication>
<duplication lines="38" tokens="112">
<file line="78" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/dataview/gui/CCVizController.java"/>
<file line="140" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/dataview/gui/DViewController.java"/>
<codefragment>
<![CDATA[
    }

    public void requestClose() {
        exit();
    }


    public void reload() {
        E.info("time to reload...");
    }


    public void requestExit() {
        exit();
    }


    public void exit() {
        System.exit(0);
    }


    public void syncOptions() {
        String[] sa = new String[0];
        if (dataHandler != null) {
            sa = dataHandler.getViewOptions();
        }
        viewMenu.setOptions(sa);
    }


    public void setViewStyle(String s) {

        if (dataHandler != null) {
            dataHandler.setViewStyle(s);
        }

        basicController.repaint();
]]>
</codefragment>
</duplication>
<duplication lines="13" tokens="112">
<file line="155" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/swing/RolloverEffect.java"/>
<file line="155" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/graph/gui/RolloverEffect.java"/>
<file line="71" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/util/ColorUtil.java"/>
<codefragment>
<![CDATA[
    public static Color linMod(Color c, int d) {
        int r = c.getRed();
        int g = c.getGreen();
        int b = c.getBlue();

        r += d;
        g += d;
        b += d;
        r = (r > 0 ? (r < 255 ? r : 255) : 0);
        g = (g > 0 ? (g < 255 ? g : 255) : 0);
        b = (b > 0 ? (b < 255 ? b : 255) : 0);
        return new Color(r, g, b);
    }
]]>
</codefragment>
</duplication>
<duplication lines="20" tokens="111">
<file line="105" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/dataview/AxisPainter.java"/>
<file line="74" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/graph/gui/XAxisCanvas.java"/>
<codefragment>
<![CDATA[
        int i1 = (int)(xr[1] / dx);

        for (int i = i0; i <= i1; i++) {
            double xx = i * dx;
            String lab = "0";
            if (i == 0) {
                // OK;

            } else if (dx >= 0.999 && dx < 1.e4) {
                lab = String.valueOf((int)(xx));
            } else {
                lab = String.valueOf((float)(xx));
            }
            int off = lab.length();
            off = 1 - 4 * off;
            if (i * dx < 0.0) {
                off -= 4;
            }

            int ix = (int)(lm + (width - lm) * (xx - xr[0]) / (xr[1] - xr[0]));
]]>
</codefragment>
</duplication>
<duplication lines="37" tokens="110">
<file line="104" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/disc/DiscBoxer.java"/>
<file line="107" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/disc/DiscSplitter.java"/>
<file line="114" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/disc/LineBoxer.java"/>
<codefragment>
<![CDATA[
                    vg = baseGrid(tp, tpn, lbl);
                    pGrid.subPlaneConnect(tp, tpn, vg, par.partBranchOffset);
                    par.partBranchOffset += 2 * tpn.r;

                } else {
                    // normal case: make a new one or add a slice and connect
                    // it up with the centres aligned
                    if (pGrid == null) {
                        vg = baseGrid(tp, tpn, lbl);

                    } else {
                        // TODO - probably not what we want
                        // too much mumerical diffusion if boxes can have gradually changing
                        // sizes? restrict to a few dicrete multiples?
                        vg = baseGrid(tp, tpn, lbl);
                        pGrid.planeConnect(vg);
                    }

                }

                lbl = null; // only use it once
                if (vg != null) {
                    gridAL.add(vg);
                    recAdd(vg, tpn);
                } else {
                    // skipped the point that is the start of a new segment
                    // of different radius
                    recAdd(pGrid, tpn);
                }
            }
        }
    }




    public VolumeSlice baseGrid(TreePoint tpa, TreePoint tpb, String lbl) {
]]>
</codefragment>
</duplication>
<duplication lines="26" tokens="107">
<file line="29" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/numeric/math/Matrix.java"/>
<file line="75" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/math/Matrix.java"/>
<codefragment>
<![CDATA[
    }


    public double[] flatten() {
        double[] d = new double[n1 * n2];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                d[n * i + j] = a[i][j];
            }
        }
        return d;
    }


    public void Sp(String s) {
        System.out.println(s);
    }


    public final int dim() {
        return n;
    }


    public Matrix copy() {
        Matrix m = new Matrix(n);
]]>
</codefragment>
</duplication>
<duplication lines="47" tokens="106">
<file line="188" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/swing/DFloatSlider.java"/>
<file line="136" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/swing/DSlider.java"/>
<codefragment>
<![CDATA[
        }
    }


    /*
    private void ensureRangeCovers() {
       if (linmin > linvalue) {
          linmin = linvalue;
       }
       if (linmax < linvalue) {
          linmax = linvalue;
       }
    }
    */


    public Dimension getMinimumSize() {
        return new Dimension(80, 20);
    }


    public Dimension getPreferredSize() {
        return new Dimension(140, 22);
    }



    public void paintComponent(Graphics g) {
        realPaint(g);
    }



    public void realPaint(Graphics g) {
        int w = getWidth();
        int h = getHeight();
        if (bgColor == null) {
            bgColor = getBackground();
        }
        g.setColor(bgColor);
        g.fillRect(0, 0, w, h);

        paintArrows(g);

        paintKnob(g);

        if (label != null) {
]]>
</codefragment>
</duplication>
<duplication lines="28" tokens="106">
<file line="44" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/serial/xml/XMLChecker.java"/>
<file line="42" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/xml/XMLChecker.java"/>
<codefragment>
<![CDATA[
        if (s.startsWith("<")) {
            // fine;

        } else {
            int iob = s.indexOf("<");

            if (iob > 0) {
                String junk = s.substring(0, iob);
                if (junk.trim().length() > 0) {

                    System.out.println("WARNING - garbage at start of xml file - first < is at " +
                                       iob + " preceded by ---" + junk + "---");
                }
                s = s.substring(iob, s.length());

            } else {
                E.error(" - xml file contains no xml " + s);
                s = null;
            }
        }

        return s;
    }




}
]]>
</codefragment>
</duplication>
<duplication lines="38" tokens="105">
<file line="76" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/gui/edit/DruCheckboxMenuItem.java"/>
<file line="65" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/gui/edit/DruMenuItem.java"/>
<codefragment>
<![CDATA[
    }


    public void setEnableOnSelection(String depends) {
        enableOn = depends;
    }


    public void setSelectionSource(SelectionSource source) {
        selectionSource = source;
    }


    public void sync() {
//      E.info("dmi syncing  enable=" + enableOn);
        if (selectionSource != null && enableOn != null) {
            String s = selectionSource.getSelectionType();
            if (enableOn.indexOf(s) >= 0) {
                dItem.setEnabled(true);
            } else {
                dItem.setEnabled(false);
            }

        }
    }


    public void setInfo(String s) {
        info = s;
    }


    public void setInfoReceiver(InfoReceiver irec) {
        infoReceiver = irec;
    }


}
]]>
</codefragment>
</duplication>
<duplication lines="29" tokens="105">
<file line="86" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/swing/DTreeDragSource.java"/>
<file line="77" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/swing/dnd/RegionDragSource.java"/>
<codefragment>
<![CDATA[
        source.startDrag(dge, Cursor.getPredefinedCursor(Cursor.HAND_CURSOR), dragImg, imgOffset, transferable, this);

    }





    /*
     * Drag Event Handlers
     */
    public void dragEnter(DragSourceDragEvent dsde) {
    }

    public void dragExit(DragSourceEvent dse) {
    }

    public void dragOver(DragSourceDragEvent dsde) {
    }

    public void dropActionChanged(DragSourceDragEvent dsde) {
        System.out.println("Action: " + dsde.getDropAction());
        System.out.println("Target Action: " + dsde.getTargetActions());
        System.out.println("User Action: " + dsde.getUserAction());
    }



    public void dragDropEnd(DragSourceDropEvent dsde) {
]]>
</codefragment>
</duplication>
<duplication lines="18" tokens="105">
<file line="244" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/grid/DeterministicGridCalc.java"/>
<file line="406" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.java"/>
<file line="362" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/tmp/Tmp1A.java"/>
<codefragment>
<![CDATA[
                    sb.append(stringd(wkA[i][ispecout[j]] * volumes[i] * PARTICLES_PUVC));

                }
            }
            sb.append("\n");
        }
        return sb.toString();
    }

    private String getGridConcsPlainText_dumb(int filenum, double time) {
        StringBuffer sb = new StringBuffer();
        // TODO tag specific to integer quantities;
        sb.append(stringd(time));

        for (int j = 0; j < specIndexesOut[filenum].length; j++) {
            for (int i = 0; i < nel; i++) {
                // WK 6 17 2007
                if (regionsOut[filenum].equals("default") || regionsOut[filenum].equals(regionLabels[eltregions[i]])) {
]]>
</codefragment>
</duplication>
<duplication lines="15" tokens="103">
<file line="91" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/blocks/Choice.java"/>
<file line="51" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/blocks/RadioButtons.java"/>
<codefragment>
<![CDATA[
            sopts = new String[sa.length];
            slabs = new String[sa.length];

            for (int i = 0; i < sa.length; i++) {
                String s = sa[i].trim();
                sopts[i] = s;
                slabs[i] = s;
            }

            if (labels != null) {
                String[] sb = labels.split(",");
                for (int i = 0; i < sa.length && i < sopts.length; i++) {
                    slabs[i] = sb[i].trim();
                }
            }
]]>
</codefragment>
</duplication>
<duplication lines="28" tokens="102">
<file line="52" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/blocks/List.java"/>
<file line="55" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/druid/blocks/ScrollingList.java"/>
<codefragment>
<![CDATA[
        DruListPanel drup = (DruListPanel)dp;
        drup.setAction(action);


        if (renderer != null) {

            // TODO move renderer defs to XML;

            if (renderer.equals("quantity")) {
                drup.setCellRenderer(new DruListQuantityRenderer());

            } else if (renderer.equals("progress")) {
                drup.setCellRenderer(new DruListProgressRenderer());

            } else if (renderer.equals("color")) {
                drup.setCellRenderer(new DruListColorRenderer());

            } else {
                E.error("unrecognized renderer " + renderer);
            }
        }

        if (multiple) {
            drup.setMultiple();
        }


        if (order != null) {
]]>
</codefragment>
</duplication>
<duplication lines="27" tokens="102">
<file line="901" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/grid/SteppedStochaticGridCalc.java"/>
<file line="824" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/stochdiff/numeric/tmp/Tmp1A.java"/>
<codefragment>
<![CDATA[
        }
        // WK
        // if (ngo < (# of neighbors)*SHARED_DIFF_PARTICLES) then do
        // shared_diffusion
        // else then do independent_diffusion
        if (ngo <= (inbr.length) * SHARED_DIFF_PARTICLES) // SHARED diffusion
        {
            wkB[iel][k] -= ngo;
            for (int i = 0; i < ngo; i++) {
                double r = random.random();
                int io = 0;
                while (r > fshare[io]) {
                    io++;
                }

                wkB[inbr[io]][k] += 1;
            }
        } else // MULTINOMIAL diffusion
        {
            ngo_remaining = ngo;         //**KTB  ngo_remaining is number of particles not yet diffused.  initially this is ngo
            //KTB 09-23-2011, use multi-nomial instead of separate binomials to calculate lnpgo, from ngo_remaining
            // WK 9 11 2007
            double prev = 0;
            for (int j = 0; j < inbr.length - 1; j++) {
                //double lnpgo = Math.log(fSharedExit[iel][k][j] - prev);  (KTB) old method - INDEPENDENT
                //BHK and KTB implemented the multinomial using tables instead of gaussianStep for small N, and use symmetry of binomial 09/23/11
                double pgoTmp = (fSharedExit[iel][k][j] - prev)/(fSharedExit[iel][k][inbr.length-1]-prev);
]]>
</codefragment>
</duplication>
<duplication lines="40" tokens="100">
<file line="34" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/act/FunctionSignature.java"/>
<file line="90" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/act/MethodSignature.java"/>
<codefragment>
<![CDATA[
    }


    public int getTypeCode() {
        return type;
    }


    public static String getTypeInfo(int itc) {
        String ret = "";
        if (itc == RECEIVE) {
            ret = "Handlers: functions that are called when an event occurs in a connected component.";

        } else if (itc == SEND) {
            ret = "Senders: these send an event to any connected components. The handler \n" +
                  "on the receiving component will be called.";


        } else if (itc == SETTER) {
            ret = "Setters: these set a value for use later, but have no other effect: \n" +
                  "the value is available to connected components if they ask for it";

        } else if (itc == GETTER) {
            ret = "Getters: give access to quantities in connected components.";
        }
        return ret;
    }


    public void setInfo(String s) {
        info = s;
    }


    public String getName() {
        return functionName;
    }


    public String toJavaScriptStub() {
]]>
</codefragment>
</duplication>
<duplication lines="37" tokens="100">
<file line="216" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/graph/gui/DataDisplay.java"/>
<file line="119" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/graph/gui/MovieDisplay.java"/>
<codefragment>
<![CDATA[
        pwCanvas.requestRepaint();
    }


    public void setXRange(double low, double high) {
        pwCanvas.setXRange(low, high);
    }


    public double[] getXRange() {
        return pwCanvas.getXRange();
    }


    public double[] getYRange() {
        return pwCanvas.getYRange();
    }


    public void setFixedAspectRatio(double ar) {
        pwCanvas.setFixedAspectRatio(ar);
    }


    public void viewChanged() {
        if (pwCanvas != null) {
            pwCanvas.repaint();
        }
    }


    public void reframe() {
        pwCanvas.reframe();
    }


    public static void main(String[] argv) {
]]>
</codefragment>
</duplication>
<duplication lines="19" tokens="100">
<file line="993" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/graph/gui/Painter.java"/>
<file line="1027" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/graph/gui/Painter.java"/>
<codefragment>
<![CDATA[
        for (int i = 0; i < nel; i++) {
            double[] xb = mesh[i][0];
            double[] yb = mesh[i][1];


            double fc = (dat[i] - ctMin) / dc;
            if (fc < 0.) {
                fc = 0.;
            }
            int ic = (int)(255 * fc);
            if (ic > 255) {
                ic = 255;
            }
            if (ic < 0) {
                ic = 0;
            }
            fillPolygon(xb, yb, xb.length, colorTable[ic]);
        }
    }
]]>
</codefragment>
</duplication>
<duplication lines="14" tokens="100">
<file line="233" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/catacomb/serial/xml/XMLReader.java"/>
<file line="226" path="/home/zbyszek/neuro/neurord/stochdiff/src/main/java/org/textensor/xml/XMLReader.java"/>
<codefragment>
<![CDATA[
                            StringBuffer sbo = (StringBuffer)child;
                            String ssf = sbo.toString();
                            if (ssf.endsWith(">") || next.svalue.startsWith("<") || ssf.length() == 0) {
                                sbo.append(next.svalue);

                            } else {
                                sbo.append(" ");
                                sbo.append(next.svalue);
                            }


                        } else {
                            if (child instanceof String && ((String)child).length() > 0) {
                                child = child + " " + next.svalue;
]]>
</codefragment>
</duplication>
</pmd-cpd>